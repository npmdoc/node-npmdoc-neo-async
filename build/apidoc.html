<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/suguru03/neo-async"

    >neo-async (v2.1.0)</a>
</h1>
<h4>Neo-Async is thought to be used as a drop-in replacement for Async, it almost fully covers its functionality and runs faster </h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.neo-async">module neo-async</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.all">
            function <span class="apidocSignatureSpan">neo-async.</span>all
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.allLimit">
            function <span class="apidocSignatureSpan">neo-async.</span>allLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.allSeries">
            function <span class="apidocSignatureSpan">neo-async.</span>allSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.angelFall">
            function <span class="apidocSignatureSpan">neo-async.</span>angelFall
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.angelfall">
            function <span class="apidocSignatureSpan">neo-async.</span>angelfall
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.any">
            function <span class="apidocSignatureSpan">neo-async.</span>any
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.anyLimit">
            function <span class="apidocSignatureSpan">neo-async.</span>anyLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.anySeries">
            function <span class="apidocSignatureSpan">neo-async.</span>anySeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.apply">
            function <span class="apidocSignatureSpan">neo-async.</span>apply
            <span class="apidocSignatureSpan">(func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.applyEach">
            function <span class="apidocSignatureSpan">neo-async.</span>applyEach
            <span class="apidocSignatureSpan">(fns)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.applyEachSeries">
            function <span class="apidocSignatureSpan">neo-async.</span>applyEachSeries
            <span class="apidocSignatureSpan">(fns)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.asyncify">
            function <span class="apidocSignatureSpan">neo-async.</span>asyncify
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.auto">
            function <span class="apidocSignatureSpan">neo-async.</span>auto
            <span class="apidocSignatureSpan">(tasks, concurrency, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.autoInject">
            function <span class="apidocSignatureSpan">neo-async.</span>autoInject
            <span class="apidocSignatureSpan">(tasks, concurrency, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.cargo">
            function <span class="apidocSignatureSpan">neo-async.</span>cargo
            <span class="apidocSignatureSpan">(worker, payload)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.compose">
            function <span class="apidocSignatureSpan">neo-async.</span>compose
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.concat">
            function <span class="apidocSignatureSpan">neo-async.</span>concat
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.concatLimit">
            function <span class="apidocSignatureSpan">neo-async.</span>concatLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.concatSeries">
            function <span class="apidocSignatureSpan">neo-async.</span>concatSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.constant">
            function <span class="apidocSignatureSpan">neo-async.</span>constant
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.createLogger">
            function <span class="apidocSignatureSpan">neo-async.</span>createLogger
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.detect">
            function <span class="apidocSignatureSpan">neo-async.</span>detect
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.detectLimit">
            function <span class="apidocSignatureSpan">neo-async.</span>detectLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.detectSeries">
            function <span class="apidocSignatureSpan">neo-async.</span>detectSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.dir">
            function <span class="apidocSignatureSpan">neo-async.</span>dir
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.doDuring">
            function <span class="apidocSignatureSpan">neo-async.</span>doDuring
            <span class="apidocSignatureSpan">(iterator, test, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.doUntil">
            function <span class="apidocSignatureSpan">neo-async.</span>doUntil
            <span class="apidocSignatureSpan">(iterator, test, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.doWhilst">
            function <span class="apidocSignatureSpan">neo-async.</span>doWhilst
            <span class="apidocSignatureSpan">(iterator, test, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.during">
            function <span class="apidocSignatureSpan">neo-async.</span>during
            <span class="apidocSignatureSpan">(test, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.each">
            function <span class="apidocSignatureSpan">neo-async.</span>each
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.eachLimit">
            function <span class="apidocSignatureSpan">neo-async.</span>eachLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.eachOf">
            function <span class="apidocSignatureSpan">neo-async.</span>eachOf
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.eachOfLimit">
            function <span class="apidocSignatureSpan">neo-async.</span>eachOfLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.eachOfSeries">
            function <span class="apidocSignatureSpan">neo-async.</span>eachOfSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.eachSeries">
            function <span class="apidocSignatureSpan">neo-async.</span>eachSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.ensureAsync">
            function <span class="apidocSignatureSpan">neo-async.</span>ensureAsync
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.every">
            function <span class="apidocSignatureSpan">neo-async.</span>every
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.everyLimit">
            function <span class="apidocSignatureSpan">neo-async.</span>everyLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.everySeries">
            function <span class="apidocSignatureSpan">neo-async.</span>everySeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.fast">
            function <span class="apidocSignatureSpan">neo-async.</span>fast
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.filter">
            function <span class="apidocSignatureSpan">neo-async.</span>filter
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.filterLimit">
            function <span class="apidocSignatureSpan">neo-async.</span>filterLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.filterSeries">
            function <span class="apidocSignatureSpan">neo-async.</span>filterSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.find">
            function <span class="apidocSignatureSpan">neo-async.</span>find
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.findLimit">
            function <span class="apidocSignatureSpan">neo-async.</span>findLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.findSeries">
            function <span class="apidocSignatureSpan">neo-async.</span>findSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.foldl">
            function <span class="apidocSignatureSpan">neo-async.</span>foldl
            <span class="apidocSignatureSpan">(collection, result, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.foldr">
            function <span class="apidocSignatureSpan">neo-async.</span>foldr
            <span class="apidocSignatureSpan">(collection, result, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.forEach">
            function <span class="apidocSignatureSpan">neo-async.</span>forEach
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.forEachLimit">
            function <span class="apidocSignatureSpan">neo-async.</span>forEachLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.forEachOf">
            function <span class="apidocSignatureSpan">neo-async.</span>forEachOf
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.forEachOfLimit">
            function <span class="apidocSignatureSpan">neo-async.</span>forEachOfLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.forEachOfSeries">
            function <span class="apidocSignatureSpan">neo-async.</span>forEachOfSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.forEachSeries">
            function <span class="apidocSignatureSpan">neo-async.</span>forEachSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.forever">
            function <span class="apidocSignatureSpan">neo-async.</span>forever
            <span class="apidocSignatureSpan">(iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.groupBy">
            function <span class="apidocSignatureSpan">neo-async.</span>groupBy
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.groupByLimit">
            function <span class="apidocSignatureSpan">neo-async.</span>groupByLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.groupBySeries">
            function <span class="apidocSignatureSpan">neo-async.</span>groupBySeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.inject">
            function <span class="apidocSignatureSpan">neo-async.</span>inject
            <span class="apidocSignatureSpan">(collection, result, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.iterator">
            function <span class="apidocSignatureSpan">neo-async.</span>iterator
            <span class="apidocSignatureSpan">(tasks)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.log">
            function <span class="apidocSignatureSpan">neo-async.</span>log
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.map">
            function <span class="apidocSignatureSpan">neo-async.</span>map
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.mapLimit">
            function <span class="apidocSignatureSpan">neo-async.</span>mapLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.mapSeries">
            function <span class="apidocSignatureSpan">neo-async.</span>mapSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.mapValues">
            function <span class="apidocSignatureSpan">neo-async.</span>mapValues
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.mapValuesLimit">
            function <span class="apidocSignatureSpan">neo-async.</span>mapValuesLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.mapValuesSeries">
            function <span class="apidocSignatureSpan">neo-async.</span>mapValuesSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.memoize">
            function <span class="apidocSignatureSpan">neo-async.</span>memoize
            <span class="apidocSignatureSpan">(fn, hasher)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.nextTick">
            function <span class="apidocSignatureSpan">neo-async.</span>nextTick
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.omit">
            function <span class="apidocSignatureSpan">neo-async.</span>omit
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.omitLimit">
            function <span class="apidocSignatureSpan">neo-async.</span>omitLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.omitSeries">
            function <span class="apidocSignatureSpan">neo-async.</span>omitSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.parallel">
            function <span class="apidocSignatureSpan">neo-async.</span>parallel
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.parallelLimit">
            function <span class="apidocSignatureSpan">neo-async.</span>parallelLimit
            <span class="apidocSignatureSpan">(tasks, limit, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.pick">
            function <span class="apidocSignatureSpan">neo-async.</span>pick
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.pickLimit">
            function <span class="apidocSignatureSpan">neo-async.</span>pickLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.pickSeries">
            function <span class="apidocSignatureSpan">neo-async.</span>pickSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.priorityQueue">
            function <span class="apidocSignatureSpan">neo-async.</span>priorityQueue
            <span class="apidocSignatureSpan">(worker, concurrency)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.queue">
            function <span class="apidocSignatureSpan">neo-async.</span>queue
            <span class="apidocSignatureSpan">(worker, concurrency)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.race">
            function <span class="apidocSignatureSpan">neo-async.</span>race
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.reduce">
            function <span class="apidocSignatureSpan">neo-async.</span>reduce
            <span class="apidocSignatureSpan">(collection, result, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.reduceRight">
            function <span class="apidocSignatureSpan">neo-async.</span>reduceRight
            <span class="apidocSignatureSpan">(collection, result, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.reflect">
            function <span class="apidocSignatureSpan">neo-async.</span>reflect
            <span class="apidocSignatureSpan">(func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.reflectAll">
            function <span class="apidocSignatureSpan">neo-async.</span>reflectAll
            <span class="apidocSignatureSpan">(tasks)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.reject">
            function <span class="apidocSignatureSpan">neo-async.</span>reject
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.rejectLimit">
            function <span class="apidocSignatureSpan">neo-async.</span>rejectLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.rejectSeries">
            function <span class="apidocSignatureSpan">neo-async.</span>rejectSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.retry">
            function <span class="apidocSignatureSpan">neo-async.</span>retry
            <span class="apidocSignatureSpan">(opts, task, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.retryable">
            function <span class="apidocSignatureSpan">neo-async.</span>retryable
            <span class="apidocSignatureSpan">(opts, task)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.safe">
            function <span class="apidocSignatureSpan">neo-async.</span>safe
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.select">
            function <span class="apidocSignatureSpan">neo-async.</span>select
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.selectLimit">
            function <span class="apidocSignatureSpan">neo-async.</span>selectLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.selectSeries">
            function <span class="apidocSignatureSpan">neo-async.</span>selectSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.seq">
            function <span class="apidocSignatureSpan">neo-async.</span>seq
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.series">
            function <span class="apidocSignatureSpan">neo-async.</span>series
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.setImmediate">
            function <span class="apidocSignatureSpan">neo-async.</span>setImmediate
            <span class="apidocSignatureSpan">(callback, arg1, arg2, arg3)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.some">
            function <span class="apidocSignatureSpan">neo-async.</span>some
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.someLimit">
            function <span class="apidocSignatureSpan">neo-async.</span>someLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.someSeries">
            function <span class="apidocSignatureSpan">neo-async.</span>someSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.sortBy">
            function <span class="apidocSignatureSpan">neo-async.</span>sortBy
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.sortByLimit">
            function <span class="apidocSignatureSpan">neo-async.</span>sortByLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.sortBySeries">
            function <span class="apidocSignatureSpan">neo-async.</span>sortBySeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.timeout">
            function <span class="apidocSignatureSpan">neo-async.</span>timeout
            <span class="apidocSignatureSpan">(func, millisec, info)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.times">
            function <span class="apidocSignatureSpan">neo-async.</span>times
            <span class="apidocSignatureSpan">(n, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.timesLimit">
            function <span class="apidocSignatureSpan">neo-async.</span>timesLimit
            <span class="apidocSignatureSpan">(n, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.timesSeries">
            function <span class="apidocSignatureSpan">neo-async.</span>timesSeries
            <span class="apidocSignatureSpan">(n, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.transform">
            function <span class="apidocSignatureSpan">neo-async.</span>transform
            <span class="apidocSignatureSpan">(collection, accumulator, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.transformLimit">
            function <span class="apidocSignatureSpan">neo-async.</span>transformLimit
            <span class="apidocSignatureSpan">(collection, limit, accumulator, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.transformSeries">
            function <span class="apidocSignatureSpan">neo-async.</span>transformSeries
            <span class="apidocSignatureSpan">(collection, accumulator, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.unmemoize">
            function <span class="apidocSignatureSpan">neo-async.</span>unmemoize
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.until">
            function <span class="apidocSignatureSpan">neo-async.</span>until
            <span class="apidocSignatureSpan">(test, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.waterfall">
            function <span class="apidocSignatureSpan">neo-async.</span>waterfall
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.whilst">
            function <span class="apidocSignatureSpan">neo-async.</span>whilst
            <span class="apidocSignatureSpan">(test, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.wrapSync">
            function <span class="apidocSignatureSpan">neo-async.</span>wrapSync
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">neo-async.</span>async</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">neo-async.</span>default</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">neo-async.</span>VERSION</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.neo-async.async">module neo-async.async</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.all">
            function <span class="apidocSignatureSpan">neo-async.async.</span>all
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.allLimit">
            function <span class="apidocSignatureSpan">neo-async.async.</span>allLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.allSeries">
            function <span class="apidocSignatureSpan">neo-async.async.</span>allSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.angelFall">
            function <span class="apidocSignatureSpan">neo-async.async.</span>angelFall
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.angelfall">
            function <span class="apidocSignatureSpan">neo-async.async.</span>angelfall
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.any">
            function <span class="apidocSignatureSpan">neo-async.async.</span>any
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.anyLimit">
            function <span class="apidocSignatureSpan">neo-async.async.</span>anyLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.anySeries">
            function <span class="apidocSignatureSpan">neo-async.async.</span>anySeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.apply">
            function <span class="apidocSignatureSpan">neo-async.async.</span>apply
            <span class="apidocSignatureSpan">(func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.applyEach">
            function <span class="apidocSignatureSpan">neo-async.async.</span>applyEach
            <span class="apidocSignatureSpan">(fns)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.applyEachSeries">
            function <span class="apidocSignatureSpan">neo-async.async.</span>applyEachSeries
            <span class="apidocSignatureSpan">(fns)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.asyncify">
            function <span class="apidocSignatureSpan">neo-async.async.</span>asyncify
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.auto">
            function <span class="apidocSignatureSpan">neo-async.async.</span>auto
            <span class="apidocSignatureSpan">(tasks, concurrency, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.autoInject">
            function <span class="apidocSignatureSpan">neo-async.async.</span>autoInject
            <span class="apidocSignatureSpan">(tasks, concurrency, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.cargo">
            function <span class="apidocSignatureSpan">neo-async.async.</span>cargo
            <span class="apidocSignatureSpan">(worker, payload)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.compose">
            function <span class="apidocSignatureSpan">neo-async.async.</span>compose
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.concat">
            function <span class="apidocSignatureSpan">neo-async.async.</span>concat
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.concatLimit">
            function <span class="apidocSignatureSpan">neo-async.async.</span>concatLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.concatSeries">
            function <span class="apidocSignatureSpan">neo-async.async.</span>concatSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.constant">
            function <span class="apidocSignatureSpan">neo-async.async.</span>constant
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.createLogger">
            function <span class="apidocSignatureSpan">neo-async.async.</span>createLogger
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.detect">
            function <span class="apidocSignatureSpan">neo-async.async.</span>detect
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.detectLimit">
            function <span class="apidocSignatureSpan">neo-async.async.</span>detectLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.detectSeries">
            function <span class="apidocSignatureSpan">neo-async.async.</span>detectSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.dir">
            function <span class="apidocSignatureSpan">neo-async.async.</span>dir
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.doDuring">
            function <span class="apidocSignatureSpan">neo-async.async.</span>doDuring
            <span class="apidocSignatureSpan">(iterator, test, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.doUntil">
            function <span class="apidocSignatureSpan">neo-async.async.</span>doUntil
            <span class="apidocSignatureSpan">(iterator, test, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.doWhilst">
            function <span class="apidocSignatureSpan">neo-async.async.</span>doWhilst
            <span class="apidocSignatureSpan">(iterator, test, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.during">
            function <span class="apidocSignatureSpan">neo-async.async.</span>during
            <span class="apidocSignatureSpan">(test, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.each">
            function <span class="apidocSignatureSpan">neo-async.async.</span>each
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.eachLimit">
            function <span class="apidocSignatureSpan">neo-async.async.</span>eachLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.eachOf">
            function <span class="apidocSignatureSpan">neo-async.async.</span>eachOf
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.eachOfLimit">
            function <span class="apidocSignatureSpan">neo-async.async.</span>eachOfLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.eachOfSeries">
            function <span class="apidocSignatureSpan">neo-async.async.</span>eachOfSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.eachSeries">
            function <span class="apidocSignatureSpan">neo-async.async.</span>eachSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.ensureAsync">
            function <span class="apidocSignatureSpan">neo-async.async.</span>ensureAsync
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.every">
            function <span class="apidocSignatureSpan">neo-async.async.</span>every
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.everyLimit">
            function <span class="apidocSignatureSpan">neo-async.async.</span>everyLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.everySeries">
            function <span class="apidocSignatureSpan">neo-async.async.</span>everySeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.fast">
            function <span class="apidocSignatureSpan">neo-async.async.</span>fast
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.filter">
            function <span class="apidocSignatureSpan">neo-async.async.</span>filter
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.filterLimit">
            function <span class="apidocSignatureSpan">neo-async.async.</span>filterLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.filterSeries">
            function <span class="apidocSignatureSpan">neo-async.async.</span>filterSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.find">
            function <span class="apidocSignatureSpan">neo-async.async.</span>find
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.findLimit">
            function <span class="apidocSignatureSpan">neo-async.async.</span>findLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.findSeries">
            function <span class="apidocSignatureSpan">neo-async.async.</span>findSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.foldl">
            function <span class="apidocSignatureSpan">neo-async.async.</span>foldl
            <span class="apidocSignatureSpan">(collection, result, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.foldr">
            function <span class="apidocSignatureSpan">neo-async.async.</span>foldr
            <span class="apidocSignatureSpan">(collection, result, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.forEach">
            function <span class="apidocSignatureSpan">neo-async.async.</span>forEach
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.forEachLimit">
            function <span class="apidocSignatureSpan">neo-async.async.</span>forEachLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.forEachOf">
            function <span class="apidocSignatureSpan">neo-async.async.</span>forEachOf
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.forEachOfLimit">
            function <span class="apidocSignatureSpan">neo-async.async.</span>forEachOfLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.forEachOfSeries">
            function <span class="apidocSignatureSpan">neo-async.async.</span>forEachOfSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.forEachSeries">
            function <span class="apidocSignatureSpan">neo-async.async.</span>forEachSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.forever">
            function <span class="apidocSignatureSpan">neo-async.async.</span>forever
            <span class="apidocSignatureSpan">(iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.groupBy">
            function <span class="apidocSignatureSpan">neo-async.async.</span>groupBy
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.groupByLimit">
            function <span class="apidocSignatureSpan">neo-async.async.</span>groupByLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.groupBySeries">
            function <span class="apidocSignatureSpan">neo-async.async.</span>groupBySeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.inject">
            function <span class="apidocSignatureSpan">neo-async.async.</span>inject
            <span class="apidocSignatureSpan">(collection, result, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.iterator">
            function <span class="apidocSignatureSpan">neo-async.async.</span>iterator
            <span class="apidocSignatureSpan">(tasks)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.log">
            function <span class="apidocSignatureSpan">neo-async.async.</span>log
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.map">
            function <span class="apidocSignatureSpan">neo-async.async.</span>map
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.mapLimit">
            function <span class="apidocSignatureSpan">neo-async.async.</span>mapLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.mapSeries">
            function <span class="apidocSignatureSpan">neo-async.async.</span>mapSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.mapValues">
            function <span class="apidocSignatureSpan">neo-async.async.</span>mapValues
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.mapValuesLimit">
            function <span class="apidocSignatureSpan">neo-async.async.</span>mapValuesLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.mapValuesSeries">
            function <span class="apidocSignatureSpan">neo-async.async.</span>mapValuesSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.memoize">
            function <span class="apidocSignatureSpan">neo-async.async.</span>memoize
            <span class="apidocSignatureSpan">(fn, hasher)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.nextTick">
            function <span class="apidocSignatureSpan">neo-async.async.</span>nextTick
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.omit">
            function <span class="apidocSignatureSpan">neo-async.async.</span>omit
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.omitLimit">
            function <span class="apidocSignatureSpan">neo-async.async.</span>omitLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.omitSeries">
            function <span class="apidocSignatureSpan">neo-async.async.</span>omitSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.parallel">
            function <span class="apidocSignatureSpan">neo-async.async.</span>parallel
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.parallelLimit">
            function <span class="apidocSignatureSpan">neo-async.async.</span>parallelLimit
            <span class="apidocSignatureSpan">(tasks, limit, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.pick">
            function <span class="apidocSignatureSpan">neo-async.async.</span>pick
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.pickLimit">
            function <span class="apidocSignatureSpan">neo-async.async.</span>pickLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.pickSeries">
            function <span class="apidocSignatureSpan">neo-async.async.</span>pickSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.priorityQueue">
            function <span class="apidocSignatureSpan">neo-async.async.</span>priorityQueue
            <span class="apidocSignatureSpan">(worker, concurrency)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.queue">
            function <span class="apidocSignatureSpan">neo-async.async.</span>queue
            <span class="apidocSignatureSpan">(worker, concurrency)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.race">
            function <span class="apidocSignatureSpan">neo-async.async.</span>race
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.reduce">
            function <span class="apidocSignatureSpan">neo-async.async.</span>reduce
            <span class="apidocSignatureSpan">(collection, result, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.reduceRight">
            function <span class="apidocSignatureSpan">neo-async.async.</span>reduceRight
            <span class="apidocSignatureSpan">(collection, result, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.reflect">
            function <span class="apidocSignatureSpan">neo-async.async.</span>reflect
            <span class="apidocSignatureSpan">(func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.reflectAll">
            function <span class="apidocSignatureSpan">neo-async.async.</span>reflectAll
            <span class="apidocSignatureSpan">(tasks)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.reject">
            function <span class="apidocSignatureSpan">neo-async.async.</span>reject
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.rejectLimit">
            function <span class="apidocSignatureSpan">neo-async.async.</span>rejectLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.rejectSeries">
            function <span class="apidocSignatureSpan">neo-async.async.</span>rejectSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.retry">
            function <span class="apidocSignatureSpan">neo-async.async.</span>retry
            <span class="apidocSignatureSpan">(opts, task, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.retryable">
            function <span class="apidocSignatureSpan">neo-async.async.</span>retryable
            <span class="apidocSignatureSpan">(opts, task)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.safe">
            function <span class="apidocSignatureSpan">neo-async.async.</span>safe
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.select">
            function <span class="apidocSignatureSpan">neo-async.async.</span>select
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.selectLimit">
            function <span class="apidocSignatureSpan">neo-async.async.</span>selectLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.selectSeries">
            function <span class="apidocSignatureSpan">neo-async.async.</span>selectSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.seq">
            function <span class="apidocSignatureSpan">neo-async.async.</span>seq
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.series">
            function <span class="apidocSignatureSpan">neo-async.async.</span>series
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.setImmediate">
            function <span class="apidocSignatureSpan">neo-async.async.</span>setImmediate
            <span class="apidocSignatureSpan">(callback, arg1, arg2, arg3)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.some">
            function <span class="apidocSignatureSpan">neo-async.async.</span>some
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.someLimit">
            function <span class="apidocSignatureSpan">neo-async.async.</span>someLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.someSeries">
            function <span class="apidocSignatureSpan">neo-async.async.</span>someSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.sortBy">
            function <span class="apidocSignatureSpan">neo-async.async.</span>sortBy
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.sortByLimit">
            function <span class="apidocSignatureSpan">neo-async.async.</span>sortByLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.sortBySeries">
            function <span class="apidocSignatureSpan">neo-async.async.</span>sortBySeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.timeout">
            function <span class="apidocSignatureSpan">neo-async.async.</span>timeout
            <span class="apidocSignatureSpan">(func, millisec, info)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.times">
            function <span class="apidocSignatureSpan">neo-async.async.</span>times
            <span class="apidocSignatureSpan">(n, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.timesLimit">
            function <span class="apidocSignatureSpan">neo-async.async.</span>timesLimit
            <span class="apidocSignatureSpan">(n, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.timesSeries">
            function <span class="apidocSignatureSpan">neo-async.async.</span>timesSeries
            <span class="apidocSignatureSpan">(n, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.transform">
            function <span class="apidocSignatureSpan">neo-async.async.</span>transform
            <span class="apidocSignatureSpan">(collection, accumulator, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.transformLimit">
            function <span class="apidocSignatureSpan">neo-async.async.</span>transformLimit
            <span class="apidocSignatureSpan">(collection, limit, accumulator, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.transformSeries">
            function <span class="apidocSignatureSpan">neo-async.async.</span>transformSeries
            <span class="apidocSignatureSpan">(collection, accumulator, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.unmemoize">
            function <span class="apidocSignatureSpan">neo-async.async.</span>unmemoize
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.until">
            function <span class="apidocSignatureSpan">neo-async.async.</span>until
            <span class="apidocSignatureSpan">(test, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.waterfall">
            function <span class="apidocSignatureSpan">neo-async.async.</span>waterfall
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.whilst">
            function <span class="apidocSignatureSpan">neo-async.async.</span>whilst
            <span class="apidocSignatureSpan">(test, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.async.wrapSync">
            function <span class="apidocSignatureSpan">neo-async.async.</span>wrapSync
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">neo-async.async.</span>default</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">neo-async.async.</span>VERSION</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.neo-async.default">module neo-async.default</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.all">
            function <span class="apidocSignatureSpan">neo-async.default.</span>all
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.allLimit">
            function <span class="apidocSignatureSpan">neo-async.default.</span>allLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.allSeries">
            function <span class="apidocSignatureSpan">neo-async.default.</span>allSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.angelFall">
            function <span class="apidocSignatureSpan">neo-async.default.</span>angelFall
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.angelfall">
            function <span class="apidocSignatureSpan">neo-async.default.</span>angelfall
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.any">
            function <span class="apidocSignatureSpan">neo-async.default.</span>any
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.anyLimit">
            function <span class="apidocSignatureSpan">neo-async.default.</span>anyLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.anySeries">
            function <span class="apidocSignatureSpan">neo-async.default.</span>anySeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.apply">
            function <span class="apidocSignatureSpan">neo-async.default.</span>apply
            <span class="apidocSignatureSpan">(func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.applyEach">
            function <span class="apidocSignatureSpan">neo-async.default.</span>applyEach
            <span class="apidocSignatureSpan">(fns)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.applyEachSeries">
            function <span class="apidocSignatureSpan">neo-async.default.</span>applyEachSeries
            <span class="apidocSignatureSpan">(fns)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.asyncify">
            function <span class="apidocSignatureSpan">neo-async.default.</span>asyncify
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.auto">
            function <span class="apidocSignatureSpan">neo-async.default.</span>auto
            <span class="apidocSignatureSpan">(tasks, concurrency, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.autoInject">
            function <span class="apidocSignatureSpan">neo-async.default.</span>autoInject
            <span class="apidocSignatureSpan">(tasks, concurrency, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.cargo">
            function <span class="apidocSignatureSpan">neo-async.default.</span>cargo
            <span class="apidocSignatureSpan">(worker, payload)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.compose">
            function <span class="apidocSignatureSpan">neo-async.default.</span>compose
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.concat">
            function <span class="apidocSignatureSpan">neo-async.default.</span>concat
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.concatLimit">
            function <span class="apidocSignatureSpan">neo-async.default.</span>concatLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.concatSeries">
            function <span class="apidocSignatureSpan">neo-async.default.</span>concatSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.constant">
            function <span class="apidocSignatureSpan">neo-async.default.</span>constant
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.createLogger">
            function <span class="apidocSignatureSpan">neo-async.default.</span>createLogger
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.detect">
            function <span class="apidocSignatureSpan">neo-async.default.</span>detect
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.detectLimit">
            function <span class="apidocSignatureSpan">neo-async.default.</span>detectLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.detectSeries">
            function <span class="apidocSignatureSpan">neo-async.default.</span>detectSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.dir">
            function <span class="apidocSignatureSpan">neo-async.default.</span>dir
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.doDuring">
            function <span class="apidocSignatureSpan">neo-async.default.</span>doDuring
            <span class="apidocSignatureSpan">(iterator, test, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.doUntil">
            function <span class="apidocSignatureSpan">neo-async.default.</span>doUntil
            <span class="apidocSignatureSpan">(iterator, test, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.doWhilst">
            function <span class="apidocSignatureSpan">neo-async.default.</span>doWhilst
            <span class="apidocSignatureSpan">(iterator, test, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.during">
            function <span class="apidocSignatureSpan">neo-async.default.</span>during
            <span class="apidocSignatureSpan">(test, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.each">
            function <span class="apidocSignatureSpan">neo-async.default.</span>each
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.eachLimit">
            function <span class="apidocSignatureSpan">neo-async.default.</span>eachLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.eachOf">
            function <span class="apidocSignatureSpan">neo-async.default.</span>eachOf
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.eachOfLimit">
            function <span class="apidocSignatureSpan">neo-async.default.</span>eachOfLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.eachOfSeries">
            function <span class="apidocSignatureSpan">neo-async.default.</span>eachOfSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.eachSeries">
            function <span class="apidocSignatureSpan">neo-async.default.</span>eachSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.ensureAsync">
            function <span class="apidocSignatureSpan">neo-async.default.</span>ensureAsync
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.every">
            function <span class="apidocSignatureSpan">neo-async.default.</span>every
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.everyLimit">
            function <span class="apidocSignatureSpan">neo-async.default.</span>everyLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.everySeries">
            function <span class="apidocSignatureSpan">neo-async.default.</span>everySeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.fast">
            function <span class="apidocSignatureSpan">neo-async.default.</span>fast
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.filter">
            function <span class="apidocSignatureSpan">neo-async.default.</span>filter
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.filterLimit">
            function <span class="apidocSignatureSpan">neo-async.default.</span>filterLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.filterSeries">
            function <span class="apidocSignatureSpan">neo-async.default.</span>filterSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.find">
            function <span class="apidocSignatureSpan">neo-async.default.</span>find
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.findLimit">
            function <span class="apidocSignatureSpan">neo-async.default.</span>findLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.findSeries">
            function <span class="apidocSignatureSpan">neo-async.default.</span>findSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.foldl">
            function <span class="apidocSignatureSpan">neo-async.default.</span>foldl
            <span class="apidocSignatureSpan">(collection, result, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.foldr">
            function <span class="apidocSignatureSpan">neo-async.default.</span>foldr
            <span class="apidocSignatureSpan">(collection, result, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.forEach">
            function <span class="apidocSignatureSpan">neo-async.default.</span>forEach
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.forEachLimit">
            function <span class="apidocSignatureSpan">neo-async.default.</span>forEachLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.forEachOf">
            function <span class="apidocSignatureSpan">neo-async.default.</span>forEachOf
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.forEachOfLimit">
            function <span class="apidocSignatureSpan">neo-async.default.</span>forEachOfLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.forEachOfSeries">
            function <span class="apidocSignatureSpan">neo-async.default.</span>forEachOfSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.forEachSeries">
            function <span class="apidocSignatureSpan">neo-async.default.</span>forEachSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.forever">
            function <span class="apidocSignatureSpan">neo-async.default.</span>forever
            <span class="apidocSignatureSpan">(iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.groupBy">
            function <span class="apidocSignatureSpan">neo-async.default.</span>groupBy
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.groupByLimit">
            function <span class="apidocSignatureSpan">neo-async.default.</span>groupByLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.groupBySeries">
            function <span class="apidocSignatureSpan">neo-async.default.</span>groupBySeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.inject">
            function <span class="apidocSignatureSpan">neo-async.default.</span>inject
            <span class="apidocSignatureSpan">(collection, result, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.iterator">
            function <span class="apidocSignatureSpan">neo-async.default.</span>iterator
            <span class="apidocSignatureSpan">(tasks)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.log">
            function <span class="apidocSignatureSpan">neo-async.default.</span>log
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.map">
            function <span class="apidocSignatureSpan">neo-async.default.</span>map
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.mapLimit">
            function <span class="apidocSignatureSpan">neo-async.default.</span>mapLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.mapSeries">
            function <span class="apidocSignatureSpan">neo-async.default.</span>mapSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.mapValues">
            function <span class="apidocSignatureSpan">neo-async.default.</span>mapValues
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.mapValuesLimit">
            function <span class="apidocSignatureSpan">neo-async.default.</span>mapValuesLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.mapValuesSeries">
            function <span class="apidocSignatureSpan">neo-async.default.</span>mapValuesSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.memoize">
            function <span class="apidocSignatureSpan">neo-async.default.</span>memoize
            <span class="apidocSignatureSpan">(fn, hasher)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.nextTick">
            function <span class="apidocSignatureSpan">neo-async.default.</span>nextTick
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.omit">
            function <span class="apidocSignatureSpan">neo-async.default.</span>omit
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.omitLimit">
            function <span class="apidocSignatureSpan">neo-async.default.</span>omitLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.omitSeries">
            function <span class="apidocSignatureSpan">neo-async.default.</span>omitSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.parallel">
            function <span class="apidocSignatureSpan">neo-async.default.</span>parallel
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.parallelLimit">
            function <span class="apidocSignatureSpan">neo-async.default.</span>parallelLimit
            <span class="apidocSignatureSpan">(tasks, limit, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.pick">
            function <span class="apidocSignatureSpan">neo-async.default.</span>pick
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.pickLimit">
            function <span class="apidocSignatureSpan">neo-async.default.</span>pickLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.pickSeries">
            function <span class="apidocSignatureSpan">neo-async.default.</span>pickSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.priorityQueue">
            function <span class="apidocSignatureSpan">neo-async.default.</span>priorityQueue
            <span class="apidocSignatureSpan">(worker, concurrency)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.queue">
            function <span class="apidocSignatureSpan">neo-async.default.</span>queue
            <span class="apidocSignatureSpan">(worker, concurrency)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.race">
            function <span class="apidocSignatureSpan">neo-async.default.</span>race
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.reduce">
            function <span class="apidocSignatureSpan">neo-async.default.</span>reduce
            <span class="apidocSignatureSpan">(collection, result, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.reduceRight">
            function <span class="apidocSignatureSpan">neo-async.default.</span>reduceRight
            <span class="apidocSignatureSpan">(collection, result, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.reflect">
            function <span class="apidocSignatureSpan">neo-async.default.</span>reflect
            <span class="apidocSignatureSpan">(func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.reflectAll">
            function <span class="apidocSignatureSpan">neo-async.default.</span>reflectAll
            <span class="apidocSignatureSpan">(tasks)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.reject">
            function <span class="apidocSignatureSpan">neo-async.default.</span>reject
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.rejectLimit">
            function <span class="apidocSignatureSpan">neo-async.default.</span>rejectLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.rejectSeries">
            function <span class="apidocSignatureSpan">neo-async.default.</span>rejectSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.retry">
            function <span class="apidocSignatureSpan">neo-async.default.</span>retry
            <span class="apidocSignatureSpan">(opts, task, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.retryable">
            function <span class="apidocSignatureSpan">neo-async.default.</span>retryable
            <span class="apidocSignatureSpan">(opts, task)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.safe">
            function <span class="apidocSignatureSpan">neo-async.default.</span>safe
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.select">
            function <span class="apidocSignatureSpan">neo-async.default.</span>select
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.selectLimit">
            function <span class="apidocSignatureSpan">neo-async.default.</span>selectLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.selectSeries">
            function <span class="apidocSignatureSpan">neo-async.default.</span>selectSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.seq">
            function <span class="apidocSignatureSpan">neo-async.default.</span>seq
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.series">
            function <span class="apidocSignatureSpan">neo-async.default.</span>series
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.setImmediate">
            function <span class="apidocSignatureSpan">neo-async.default.</span>setImmediate
            <span class="apidocSignatureSpan">(callback, arg1, arg2, arg3)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.some">
            function <span class="apidocSignatureSpan">neo-async.default.</span>some
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.someLimit">
            function <span class="apidocSignatureSpan">neo-async.default.</span>someLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.someSeries">
            function <span class="apidocSignatureSpan">neo-async.default.</span>someSeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.sortBy">
            function <span class="apidocSignatureSpan">neo-async.default.</span>sortBy
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.sortByLimit">
            function <span class="apidocSignatureSpan">neo-async.default.</span>sortByLimit
            <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.sortBySeries">
            function <span class="apidocSignatureSpan">neo-async.default.</span>sortBySeries
            <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.timeout">
            function <span class="apidocSignatureSpan">neo-async.default.</span>timeout
            <span class="apidocSignatureSpan">(func, millisec, info)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.times">
            function <span class="apidocSignatureSpan">neo-async.default.</span>times
            <span class="apidocSignatureSpan">(n, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.timesLimit">
            function <span class="apidocSignatureSpan">neo-async.default.</span>timesLimit
            <span class="apidocSignatureSpan">(n, limit, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.timesSeries">
            function <span class="apidocSignatureSpan">neo-async.default.</span>timesSeries
            <span class="apidocSignatureSpan">(n, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.transform">
            function <span class="apidocSignatureSpan">neo-async.default.</span>transform
            <span class="apidocSignatureSpan">(collection, accumulator, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.transformLimit">
            function <span class="apidocSignatureSpan">neo-async.default.</span>transformLimit
            <span class="apidocSignatureSpan">(collection, limit, accumulator, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.transformSeries">
            function <span class="apidocSignatureSpan">neo-async.default.</span>transformSeries
            <span class="apidocSignatureSpan">(collection, accumulator, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.unmemoize">
            function <span class="apidocSignatureSpan">neo-async.default.</span>unmemoize
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.until">
            function <span class="apidocSignatureSpan">neo-async.default.</span>until
            <span class="apidocSignatureSpan">(test, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.waterfall">
            function <span class="apidocSignatureSpan">neo-async.default.</span>waterfall
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.whilst">
            function <span class="apidocSignatureSpan">neo-async.default.</span>whilst
            <span class="apidocSignatureSpan">(test, iterator, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.neo-async.default.wrapSync">
            function <span class="apidocSignatureSpan">neo-async.default.</span>wrapSync
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">neo-async.default.</span>VERSION</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.neo-async" id="apidoc.module.neo-async">module neo-async</a></h1>


    <h2>
        <a href="#apidoc.element.neo-async.all" id="apidoc.element.neo-async.all">
        function <span class="apidocSignatureSpan">neo-async.</span>all
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function every(collection, iterator, callback) {
  callback = callback || noop;
  deny(collection, iterator, done);

  function done(err, res) {
    if (err) {
      return callback(err);
    }
    callback(null, !res);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.allLimit" id="apidoc.element.neo-async.allLimit">
        function <span class="apidocSignatureSpan">neo-async.</span>allLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function everyLimit(collection, limit, iterator, callback) {
  callback = callback || noop;
  denyLimit(collection, limit, iterator, done);

  function done(err, res) {
    if (err) {
      return callback(err);
    }
    callback(null, !res);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.allSeries" id="apidoc.element.neo-async.allSeries">
        function <span class="apidocSignatureSpan">neo-async.</span>allSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function everySeries(collection, iterator, callback) {
  callback = callback || noop;
  denySeries(collection, iterator, done);

  function done(err, res) {
    if (err) {
      return callback(err);
    }
    callback(null, !res);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.angelFall" id="apidoc.element.neo-async.angelFall">
        function <span class="apidocSignatureSpan">neo-async.</span>angelFall
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function angelFall(tasks, callback) {
  callback = callback || noop;
  if (!checkWaterfallTasks(tasks, callback)) {
    return;
  }
  var completed = 0;
  var sync = false;
  var size = tasks.length;
  var func = tasks[completed];
  var args = [];
  var iterate = function() {
    switch (func.length) {
      case 0:
        try {
          next(null, func());
        } catch (e) {
          next(e);
        }
        return;
      case 1:
        return func(next);
      case 2:
        return func(args[1], next);
      case 3:
        return func(args[1], args[2], next);
      case 4:
        return func(args[1], args[2], args[3], next);
      case 5:
        return func(args[1], args[2], args[3], args[4], next);
      default:
        args = slice(args, 1);
        args[func.length - 1] = next;
        return func.apply(null, args);
    }
  };
  iterate();

  function next(err, res) {
    if (err) {
      iterate = throwError;
      callback = onlyOnce(callback);
      callback(err);
      return;
    }
    if (++completed === size) {
      iterate = throwError;
      var done = callback;
      callback = throwError;
      if (arguments.length === 2) {
        done(err, res);
      } else {
        done.apply(null, createArray(arguments));
      }
      return;
    }
    func = tasks[completed];
    args = arguments;
    if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *   function(arg1, empty1, empty2, empty3, next) {
 *     setTimeout(function() {
 *       order.push(4);
 *       next(null, 1, 2, 3, 4);
 *     }, 40);
 *   }
 * ];
 * async.<span class="apidocCodeKeywordSpan">angelFall</span>(tasks, function(err, arg1, arg2, arg3, arg4) {
 *   console.log(arg1, arg2, arg3, arg4); // 1 2 3 4
 * });
 *
 */
function angelFall(tasks, callback) {
  callback = callback || noop;
  if (!checkWaterfallTasks(tasks, callback)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.angelfall" id="apidoc.element.neo-async.angelfall">
        function <span class="apidocSignatureSpan">neo-async.</span>angelfall
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function angelFall(tasks, callback) {
  callback = callback || noop;
  if (!checkWaterfallTasks(tasks, callback)) {
    return;
  }
  var completed = 0;
  var sync = false;
  var size = tasks.length;
  var func = tasks[completed];
  var args = [];
  var iterate = function() {
    switch (func.length) {
      case 0:
        try {
          next(null, func());
        } catch (e) {
          next(e);
        }
        return;
      case 1:
        return func(next);
      case 2:
        return func(args[1], next);
      case 3:
        return func(args[1], args[2], next);
      case 4:
        return func(args[1], args[2], args[3], next);
      case 5:
        return func(args[1], args[2], args[3], args[4], next);
      default:
        args = slice(args, 1);
        args[func.length - 1] = next;
        return func.apply(null, args);
    }
  };
  iterate();

  function next(err, res) {
    if (err) {
      iterate = throwError;
      callback = onlyOnce(callback);
      callback(err);
      return;
    }
    if (++completed === size) {
      iterate = throwError;
      var done = callback;
      callback = throwError;
      if (arguments.length === 2) {
        done(err, res);
      } else {
        done.apply(null, createArray(arguments));
      }
      return;
    }
    func = tasks[completed];
    args = arguments;
    if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.any" id="apidoc.element.neo-async.any">
        function <span class="apidocSignatureSpan">neo-async.</span>any
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function some(collection, iterator, callback) {
  callback = callback || noop;
  detect(collection, iterator, done);

  function done(err, res) {
    if (err) {
      return callback(err);
    }
    callback(null, !!res);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.anyLimit" id="apidoc.element.neo-async.anyLimit">
        function <span class="apidocSignatureSpan">neo-async.</span>anyLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function someLimit(collection, limit, iterator, callback) {
  callback = callback || noop;
  detectLimit(collection, limit, iterator, done);

  function done(err, res) {
    if (err) {
      return callback(err);
    }
    callback(null, !!res);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.anySeries" id="apidoc.element.neo-async.anySeries">
        function <span class="apidocSignatureSpan">neo-async.</span>anySeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function someSeries(collection, iterator, callback) {
  callback = callback || noop;
  detectSeries(collection, iterator, done);

  function done(err, res) {
    if (err) {
      return callback(err);
    }
    callback(null, !!res);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.apply" id="apidoc.element.neo-async.apply">
        function <span class="apidocSignatureSpan">neo-async.</span>apply
        <span class="apidocSignatureSpan">(func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function apply(func) {
  switch (arguments.length) {
    case 0:
    case 1:
      return func;
    case 2:
      return func.bind(null, arguments[1]);
    case 3:
      return func.bind(null, arguments[1], arguments[2]);
    case 4:
      return func.bind(null, arguments[1], arguments[2], arguments[3]);
    case 5:
      return func.bind(null, arguments[1], arguments[2], arguments[3], arguments[4]);
    default:
      var size = arguments.length;
      var index = 0;
      var args = Array(size);
      args[index] = null;
      while (++index &#x3c; size) {
        args[index] = arguments[index];
      }
      return func.bind.apply(func, args);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * @private
 */
function createImmediate(safeMode) {
  var delay = function delay(fn) {
    var args = slice(arguments, 1);
    setTimeout(function() {
      fn.<span class="apidocCodeKeywordSpan">apply</span>(null, args);
    });
  };
  asyncSetImmediate = typeof setImmediate === func ? setImmediate : delay;
  if (typeof process === obj &#x26;&#x26; typeof process.nextTick === func) {
    nextTick = /^v0.10/.test(process.version) ? asyncSetImmediate : process.nextTick;
    asyncNextTick = /^v0/.test(process.version) ? asyncSetImmediate : process.nextTick;
  } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.applyEach" id="apidoc.element.neo-async.applyEach">
        function <span class="apidocSignatureSpan">neo-async.</span>applyEach
        <span class="apidocSignatureSpan">(fns)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function applyEach(fns) {

  var go = function() {
    var self = this;
    var args = createArray(arguments);
    var callback = args.pop() || noop;
    return func(fns, iterator, callback);

    function iterator(fn, done) {
      fn.apply(self, args.concat([done]));
    }
  };
  if (arguments.length &#x3e; 1) {
    var args = slice(arguments, 1);
    return go.apply(this, args);
  } else {
    return go;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.applyEachSeries" id="apidoc.element.neo-async.applyEachSeries">
        function <span class="apidocSignatureSpan">neo-async.</span>applyEachSeries
        <span class="apidocSignatureSpan">(fns)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function applyEach(fns) {

  var go = function() {
    var self = this;
    var args = createArray(arguments);
    var callback = args.pop() || noop;
    return func(fns, iterator, callback);

    function iterator(fn, done) {
      fn.apply(self, args.concat([done]));
    }
  };
  if (arguments.length &#x3e; 1) {
    var args = slice(arguments, 1);
    return go.apply(this, args);
  } else {
    return go;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.asyncify" id="apidoc.element.neo-async.asyncify">
        function <span class="apidocSignatureSpan">neo-async.</span>asyncify
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asyncify(fn) {
  return function( /* args..., callback */ ) {
    var args = createArray(arguments);
    var callback = args.pop();
    var result;
    try {
      result = fn.apply(this, args);
    } catch (e) {
      return callback(e);
    }
    if (result &#x26;&#x26; typeof result === obj &#x26;&#x26; typeof result.then === func) {
      result.then(function(value) {
        callback(null, value);
      }, function(err) {
        callback(err.message ? err : new Error(err));
      });
    } else {
      callback(null, result);
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.auto" id="apidoc.element.neo-async.auto">
        function <span class="apidocSignatureSpan">neo-async.</span>auto
        <span class="apidocSignatureSpan">(tasks, concurrency, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function auto(tasks, concurrency, callback) {
  if (typeof concurrency === func) {
    callback = concurrency;
    concurrency = null;
  }
  var keys = nativeKeys(tasks);
  var rest = keys.length;
  var results = {};
  if (rest === 0) {
    return callback(null, results);
  }
  var runningTasks = 0;
  var readyTasks = [];
  var listeners = {};
  callback = onlyOnce(callback || noop);
  concurrency = concurrency || rest;

  baseEachSync(tasks, iterator, keys);
  proceedQueue();

  function iterator(task, key) {
    // no dependencies
    var _task, _taskSize;
    if (!isArray(task)) {
      _task = task;
      _taskSize = 0;
      readyTasks.push([_task, _taskSize, done]);
      return;
    }
    var dependencySize = task.length - 1;
    _task = task[dependencySize];
    _taskSize = dependencySize;
    if (dependencySize === 0) {
      readyTasks.push([_task, _taskSize, done]);
      return;
    }
    // dependencies
    var index = -1;
    while (++index &#x3c; dependencySize) {
      var dependencyName = task[index];
      if (notInclude(keys, dependencyName)) {
        var msg = &#x27;async.auto task `&#x27; + dependencyName + &#x27;` has non-existent dependency in &#x27; + task.join(&#x27;, &#x27;);
        throw new Error(msg);
      }
      var taskListeners = listeners[dependencyName];
      if (!taskListeners) {
        taskListeners = listeners[dependencyName] = [];
      }
      taskListeners.push(taskListener);
    }

    function done(err, arg) {
      if (key === null) {
        throwError();
      }
      runningTasks--;
      rest--;
      arg = arguments.length &#x3c;= 2 ? arg : slice(arguments, 1);
      if (err) {
        var safeResults = objectClone(results);
        safeResults[key] = arg;
        key = null;
        var _callback = callback;
        callback = noop;
        _callback(err, safeResults);
        return;
      }
      results[key] = arg;
      taskComplete(key);
      key = null;
    }

    function taskListener() {
      if (--dependencySize === 0) {
        readyTasks.push([_task, _taskSize, done]);
      }
    }
  }

  function proceedQueue() {
    if (readyTasks.length === 0 &#x26;&#x26; runningTasks === 0) {
      if (rest !== 0) {
        throw new Error(&#x27;async.auto task has cyclic dependencies&#x27;);
      }
      return callback(null, results);
    }
    while (readyTasks.length &#x26;&#x26; runningTasks &#x3c; concurrency &#x26;&#x26; callback !== noop) {
      runningTasks++;
      var array = readyTasks.shift();
      if (array[1] === 0) {
        array[0](array[2]);
      } else {
        array[0](results, array[2]);
      }
    }
  }

  function taskComplete(key) {
    var taskListeners = listeners[key] || [];
    arrayEachSync(taskListeners, function(task) {
      task();
    });
    proceedQueue();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.autoInject" id="apidoc.element.neo-async.autoInject">
        function <span class="apidocSignatureSpan">neo-async.</span>autoInject
        <span class="apidocSignatureSpan">(tasks, concurrency, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function autoInject(tasks, concurrency, callback) {
  var newTasks = {};
  baseEachSync(tasks, iterator, nativeKeys(tasks));
  auto(newTasks, concurrency, callback);

  function iterator(task, key) {
    var params;
    var taskLength = task.length;

    if (isArray(task)) {
      if (taskLength === 0) {
        throw new Error(&#x27;autoInject task functions require explicit parameters.&#x27;);
      }
      params = createArray(task);
      taskLength = params.length - 1;
      task = params[taskLength];
      if (taskLength === 0) {
        newTasks[key] = task;
        return;
      }
    } else if (taskLength === 1) {
      newTasks[key] = task;
      return;
    } else {
      params = parseParams(task);
      if (taskLength === 0 &#x26;&#x26; params.length === 0) {
        throw new Error(&#x27;autoInject task functions require explicit parameters.&#x27;);
      }
      taskLength = params.length - 1;
    }
    params[taskLength] = newTask;
    newTasks[key] = params;

    function newTask(results, done) {
      switch (taskLength) {
        case 1:
          task(results[params[0]], done);
          break;
        case 2:
          task(results[params[0]], results[params[1]], done);
          break;
        case 3:
          task(results[params[0]], results[params[1]], results[params[2]], done);
          break;
        default:
          var i = -1;
          while(++i &#x3c; taskLength) {
            params[i] = results[params[i]];
          }
          params[i] = done;
          task.apply(null, params);
          break;
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.cargo" id="apidoc.element.neo-async.cargo">
        function <span class="apidocSignatureSpan">neo-async.</span>cargo
        <span class="apidocSignatureSpan">(worker, payload)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cargo(worker, payload) {
  return baseQueue(false, worker, 1, payload);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.compose" id="apidoc.element.neo-async.compose">
        function <span class="apidocSignatureSpan">neo-async.</span>compose
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compose() {
  return seq.apply(null, reverse(arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.concat" id="apidoc.element.neo-async.concat">
        function <span class="apidocSignatureSpan">neo-async.</span>concat
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function concat(collection, iterator, callback) {
  callback = callback || noop;
  var size;
  var completed = 0;
  var result = [];

  if (isArray(collection)) {
    size = collection.length;
    arrayEach(collection, iterator, done);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    symbolEach(collection, iterator, done);
  } else if (typeof collection === obj) {
    var keys = nativeKeys(collection);
    size = keys.length;
    baseEach(collection, iterator, done, keys);
  }
  if (!size) {
    callback(null, result);
  }

  function done(err, array) {
    if (array) {
      Array.prototype.push.apply(result, isArray(array) ? array : [array]);
    }
    if (err) {
      callback = once(callback);
      callback(err, createArray(result));
    } else if (++completed === size) {
      callback(null, result);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, [num]);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">concat</span>(array, iterator, function(err, res) {
*   console.log(res); // [1, 2, 3];
*   console.log(order); // [1, 2, 3]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.concatLimit" id="apidoc.element.neo-async.concatLimit">
        function <span class="apidocSignatureSpan">neo-async.</span>concatLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function concatLimit(collection, limit, iterator, callback) {
  callback = callback || noop;
  var result = [];
  var size, index, key, iter, item, iterate;
  var sync = false;
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    var keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null, result);
  }
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    if (started &#x3c; size) {
      iterator(collection[started++], onlyOnce(done));
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      iterator(collection[index], index, onlyOnce(done));
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      iterator(item.value, onlyOnce(done));
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      iterator(item.value, started++, onlyOnce(done));
    }
  }

  function objectIterator() {
    if (started &#x3c; size) {
      iterator(collection[keys[started++]], onlyOnce(done));
    }
  }

  function objectIteratorWithKey() {
    if (started &#x3c; size) {
      key = keys[started++];
      iterator(collection[key], key, onlyOnce(done));
    }
  }

  function done(err, array) {
    if (array) {
      Array.prototype.push.apply(result, isArray(array) ? array : [array]);
    }
    if (err) {
      iterate = noop;
      callback = once(callback);
      callback(err, result);
    } else if (++completed === size) {
      iterate = throwError;
      callback = onlyOnce(callback);
      callback(null, result);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 5, 3, 4, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, [num]);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">concatLimit</span>(array, 2, iterator, function(err, res) {
*   console.log(res); // [1, 3, 5, 2, 4]
*   console.log(order); // [1, 3, 5, 2, 4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.concatSeries" id="apidoc.element.neo-async.concatSeries">
        function <span class="apidocSignatureSpan">neo-async.</span>concatSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function concatSeries(collection, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, keys, iter, values, iterate;
  var sync = false;
  var result = [];
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null, result);
  }
  iterate();

  function arrayIterator() {
    iterator(collection[completed], done);
  }

  function arrayIteratorWithIndex() {
    iterator(collection[completed], completed, done);
  }

  function symbolIterator() {
    iterator(iter.next().value, done);
  }

  function symbolIteratorWithKey() {
    values = iter.next().value;
    iterator(values, completed, done);
  }

  function objectIterator() {
    iterator(collection[keys[completed]], done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    iterator(collection[key], key, done);
  }

  function done(err, array) {
    if (array) {
      Array.prototype.push.apply(result, isArray(array) ? array : [array]);
    }
    if (err) {
      callback(err, result);
    } else if (++completed === size) {
      iterate = throwError;
      callback(null, result);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, [num]);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">concatSeries</span>(array, iterator, function(err, res) {
*   console.log(res); // [1, 3, 2];
*   console.log(order); // [1, 3, 2]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.constant" id="apidoc.element.neo-async.constant">
        function <span class="apidocSignatureSpan">neo-async.</span>constant
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function constant() {
  var args = [null].concat(createArray(arguments));
  return function(callback) {
    callback = arguments[arguments.length - 1];
    callback.apply(this, args);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.createLogger" id="apidoc.element.neo-async.createLogger">
        function <span class="apidocSignatureSpan">neo-async.</span>createLogger
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createLogger(name) {
  return function(fn) {
    var args = slice(arguments, 1);
    args.push(done);
    fn.apply(null, args);
  };

  function done(err) {
    if (typeof console === obj) {
      if (err) {
        if (console.error) {
          console.error(err);
        }
        return;
      }
      if (console[name]) {
        var args = slice(arguments, 1);
        arrayEachSync(args, function(arg) {
          console[name](arg);
        });
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.detect" id="apidoc.element.neo-async.detect">
        function <span class="apidocSignatureSpan">neo-async.</span>detect
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (collection, iterator, callback) {
  callback = callback || noop;
  var size, keys;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    arrayEach(collection, iterator, createCallback);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    symbolEach(collection, iterator, createCallback);
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    baseEach(collection, iterator, createCallback, keys);
  }
  if (!size) {
    callback(null);
  }

  function createCallback(value) {
    var called = false;
    return function done(err, res) {
      if (called) {
        throwError();
      }
      called = true;
      if (err) {
        callback = once(callback);
        callback(err);
      } else if (!!res === bool) {
        callback = once(callback);
        callback(null, value);
      } else if (++completed === size) {
        callback(null);
      }
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">detect</span>(array, iterator, function(err, res) {
*   console.log(res); // 1
*   console.log(order); // [1]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.detectLimit" id="apidoc.element.neo-async.detectLimit">
        function <span class="apidocSignatureSpan">neo-async.</span>detectLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detectLimit = function (collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, value, keys, iter, item, iterate;
  var sync = false;
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null);
  }
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, createCallback(value));
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, index, createCallback(value));
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, createCallback(value));
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, started++, createCallback(value));
    }
  }

  function objectIterator() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[keys[index]];
      iterator(value, createCallback(value));
    }
  }

  function objectIteratorWithKey() {
    if (started &#x3c; size) {
      key = keys[started++];
      value = collection[key];
      iterator(value, key, createCallback(value));
    }
  }

  function createCallback(value) {
    var called = false;
    return function(err, res) {
      if (called) {
        throwError();
      }
      called = true;
      if (err) {
        iterate = noop;
        callback = once(callback);
        callback(err);
      } else if (!!res === bool) {
        iterate = noop;
        callback = once(callback);
        callback(null, value);
      } else if (++completed === size) {
        callback(null);
      } else if (sync) {
        nextTick(iterate);
      } else {
        sync = true;
        iterate();
      }
      sync = false;
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 5, 3, 4, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">detectLimit</span>(array, 2, iterator, function(err, res) {
*   console.log(res); // 1
*   console.log(order); // [1]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.detectSeries" id="apidoc.element.neo-async.detectSeries">
        function <span class="apidocSignatureSpan">neo-async.</span>detectSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detectSeries = function (collection, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, value, keys, iter, iterate;
  var sync = false;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null);
  }
  iterate();

  function arrayIterator() {
    value = collection[completed];
    iterator(value, done);
  }

  function arrayIteratorWithIndex() {
    value = collection[completed];
    iterator(value, completed, done);
  }

  function symbolIterator() {
    value = iter.next().value;
    iterator(value, done);
  }

  function symbolIteratorWithKey() {
    value = iter.next().value;
    iterator(value, completed, done);
  }

  function objectIterator() {
    value = collection[keys[completed]];
    iterator(value, done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    value = collection[key];
    iterator(value, key, done);
  }

  function done(err, res) {
    if (err) {
      callback(err);
    } else if (!!res === bool) {
      iterate = throwError;
      callback(null, value);
    } else if (++completed === size) {
      iterate = throwError;
      callback(null);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">detectSeries</span>(array, iterator, function(err, res) {
*   console.log(res); // 1
*   console.log(order); // [1]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.dir" id="apidoc.element.neo-async.dir">
        function <span class="apidocSignatureSpan">neo-async.</span>dir
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dir = function (fn) {
  var args = slice(arguments, 1);
  args.push(done);
  fn.apply(null, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.doDuring" id="apidoc.element.neo-async.doDuring">
        function <span class="apidocSignatureSpan">neo-async.</span>doDuring
        <span class="apidocSignatureSpan">(iterator, test, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doDuring(iterator, test, callback) {
  callback = callback || noop;
  iterate(null, true);

  function iterate(err, truth) {
    if (err) {
      return callback(err);
    }
    if (truth) {
      iterator(done);
    } else {
      callback(null);
    }
  }

  function done(err, res) {
    if (err) {
      return callback(err);
    }
    switch (arguments.length) {
      case 0:
      case 1:
        test(iterate);
        break;
      case 2:
        test(res, iterate);
        break;
      default:
        var args = slice(arguments, 1);
        args.push(iterate);
        test.apply(null, args);
        break;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.doUntil" id="apidoc.element.neo-async.doUntil">
        function <span class="apidocSignatureSpan">neo-async.</span>doUntil
        <span class="apidocSignatureSpan">(iterator, test, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doUntil(iterator, test, callback) {
  callback = callback || noop;
  var sync = false;
  next();

  function iterate() {
    if (sync) {
      nextTick(next);
    } else {
      sync = true;
      iterator(done);
    }
    sync = false;
  }

  function next() {
    iterator(done);
  }

  function done(err, arg) {
    if (err) {
      return callback(err);
    }
    if (arguments.length &#x3c;= 2) {
      if (!test(arg)) {
        iterate();
      } else {
        callback(null, arg);
      }
      return;
    }
    arg = slice(arguments, 1);
    if (!test.apply(null, arg)) {
      iterate();
    } else {
      callback.apply(null, [null].concat(arg));
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.doWhilst" id="apidoc.element.neo-async.doWhilst">
        function <span class="apidocSignatureSpan">neo-async.</span>doWhilst
        <span class="apidocSignatureSpan">(iterator, test, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doWhilst(iterator, test, callback) {
  callback = callback || noop;
  var sync = false;
  next();

  function iterate() {
    if (sync) {
      nextTick(next);
    } else {
      sync = true;
      iterator(done);
    }
    sync = false;
  }

  function next() {
    iterator(done);
  }

  function done(err, arg) {
    if (err) {
      return callback(err);
    }
    if (arguments.length &#x3c;= 2) {
      if (test(arg)) {
        iterate();
      } else {
        callback(null, arg);
      }
      return;
    }
    arg = slice(arguments, 1);
    if (test.apply(null, arg)) {
      iterate();
    } else {
      callback.apply(null, [null].concat(arg));
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.during" id="apidoc.element.neo-async.during">
        function <span class="apidocSignatureSpan">neo-async.</span>during
        <span class="apidocSignatureSpan">(test, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function during(test, iterator, callback) {
  callback = callback || noop;
  _test();

  function _test() {
    test(iterate);
  }

  function iterate(err, truth) {
    if (err) {
      return callback(err);
    }
    if (truth) {
      iterator(done);
    } else {
      callback(null);
    }
  }

  function done(err) {
    if (err) {
      return callback(err);
    }
    _test();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.each" id="apidoc.element.neo-async.each">
        function <span class="apidocSignatureSpan">neo-async.</span>each
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function each(collection, iterator, callback) {
  callback = callback || noop;
  var size, keys;
  var completed = 0;
  if (isArray(collection)) {
    size = collection.length;
    arrayEach(collection, iterator, done);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    symbolEach(collection, iterator, done);
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    baseEach(collection, iterator, done, keys);
  }
  if (!size) {
    callback(null);
  }

  function done(err, bool) {
    if (err) {
      callback = once(callback);
      callback(err);
    } else if (++completed === size) {
      callback(null);
    } else if (bool === false) {
      callback = once(callback);
      callback(null);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done();
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">each</span>(array, iterator, function(err, res) {
*   console.log(res); // undefined
*   console.log(order); // [1, 2, 3]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.eachLimit" id="apidoc.element.neo-async.eachLimit">
        function <span class="apidocSignatureSpan">neo-async.</span>eachLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachLimit(collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, keys, iter, item, iterate;
  var sync = false;
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  } else {
    return callback(null);
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null);
  }
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    if (started &#x3c; size) {
      iterator(collection[started++], done);
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      iterator(collection[index], index, done);
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      iterator(item.value, done);
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      iterator(item.value, started++, done);
    }
  }

  function objectIterator() {
    if (started &#x3c; size) {
      iterator(collection[keys[started++]], done);
    }
  }

  function objectIteratorWithKey() {
    index = started++;
    if (index &#x3c; size) {
      key = keys[index];
      iterator(collection[key], key, done);
    }
  }

  function done(err, bool) {
    if (err) {
      iterate = noop;
      callback = once(callback);
      callback(err);
    } else if (++completed === size) {
      iterate = throwError;
      callback = onlyOnce(callback);
      callback(null);
    } else if (bool === false) {
      iterate = noop;
      callback = once(callback);
      callback(null);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 5, 3, 4, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done();
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">eachLimit</span>(array, 2, iterator, function(err, res) {
*   console.log(res); // undefined
*   console.log(order); // [1, 3, 5, 2, 4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.eachOf" id="apidoc.element.neo-async.eachOf">
        function <span class="apidocSignatureSpan">neo-async.</span>eachOf
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function each(collection, iterator, callback) {
  callback = callback || noop;
  var size, keys;
  var completed = 0;
  if (isArray(collection)) {
    size = collection.length;
    arrayEach(collection, iterator, done);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    symbolEach(collection, iterator, done);
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    baseEach(collection, iterator, done, keys);
  }
  if (!size) {
    callback(null);
  }

  function done(err, bool) {
    if (err) {
      callback = once(callback);
      callback(err);
    } else if (++completed === size) {
      callback(null);
    } else if (bool === false) {
      callback = once(callback);
      callback(null);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.eachOfLimit" id="apidoc.element.neo-async.eachOfLimit">
        function <span class="apidocSignatureSpan">neo-async.</span>eachOfLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachLimit(collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, keys, iter, item, iterate;
  var sync = false;
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  } else {
    return callback(null);
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null);
  }
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    if (started &#x3c; size) {
      iterator(collection[started++], done);
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      iterator(collection[index], index, done);
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      iterator(item.value, done);
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      iterator(item.value, started++, done);
    }
  }

  function objectIterator() {
    if (started &#x3c; size) {
      iterator(collection[keys[started++]], done);
    }
  }

  function objectIteratorWithKey() {
    index = started++;
    if (index &#x3c; size) {
      key = keys[index];
      iterator(collection[key], key, done);
    }
  }

  function done(err, bool) {
    if (err) {
      iterate = noop;
      callback = once(callback);
      callback(err);
    } else if (++completed === size) {
      iterate = throwError;
      callback = onlyOnce(callback);
      callback(null);
    } else if (bool === false) {
      iterate = noop;
      callback = once(callback);
      callback(null);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.eachOfSeries" id="apidoc.element.neo-async.eachOfSeries">
        function <span class="apidocSignatureSpan">neo-async.</span>eachOfSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachSeries(collection, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, keys, iter, value, iterate;
  var sync = false;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null);
  }
  iterate();

  function arrayIterator() {
    iterator(collection[completed], done);
  }

  function arrayIteratorWithIndex() {
    iterator(collection[completed], completed, done);
  }

  function symbolIterator() {
    iterator(iter.next().value, done);
  }

  function symbolIteratorWithKey() {
    value = iter.next().value;
    iterator(value, completed, done);
  }

  function objectIterator() {
    iterator(collection[keys[completed]], done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    iterator(collection[key], key, done);
  }

  function done(err, bool) {
    if (err) {
      callback(err);
    } else if (++completed === size) {
      iterate = throwError;
      callback(null);
    } else if (bool === false) {
      iterate = throwError;
      callback(null);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.eachSeries" id="apidoc.element.neo-async.eachSeries">
        function <span class="apidocSignatureSpan">neo-async.</span>eachSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachSeries(collection, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, keys, iter, value, iterate;
  var sync = false;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null);
  }
  iterate();

  function arrayIterator() {
    iterator(collection[completed], done);
  }

  function arrayIteratorWithIndex() {
    iterator(collection[completed], completed, done);
  }

  function symbolIterator() {
    iterator(iter.next().value, done);
  }

  function symbolIteratorWithKey() {
    value = iter.next().value;
    iterator(value, completed, done);
  }

  function objectIterator() {
    iterator(collection[keys[completed]], done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    iterator(collection[key], key, done);
  }

  function done(err, bool) {
    if (err) {
      callback(err);
    } else if (++completed === size) {
      iterate = throwError;
      callback(null);
    } else if (bool === false) {
      iterate = throwError;
      callback(null);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done();
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">eachSeries</span>(array, iterator, function(err, res) {
*   console.log(res); // undefined
*   console.log(order); // [1, 3, 2]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.ensureAsync" id="apidoc.element.neo-async.ensureAsync">
        function <span class="apidocSignatureSpan">neo-async.</span>ensureAsync
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ensureAsync(fn) {
  return function( /* ...args, callback */ ) {
    var args = createArray(arguments);
    var lastIndex = args.length - 1;
    var callback = args[lastIndex];
    var sync = true;
    args[lastIndex] = done;
    fn.apply(this, args);
    sync = false;

    function done() {
      var innerArgs = createArray(arguments);
      if (sync) {
        nextTick(function() {
          callback.apply(null, innerArgs);
        });
      } else {
        callback.apply(null, innerArgs);
      }
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.every" id="apidoc.element.neo-async.every">
        function <span class="apidocSignatureSpan">neo-async.</span>every
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function every(collection, iterator, callback) {
  callback = callback || noop;
  deny(collection, iterator, done);

  function done(err, res) {
    if (err) {
      return callback(err);
    }
    callback(null, !res);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">every</span>(array, iterator, function(err, res) {
*   console.log(res); // false
*   console.log(order); // [1, 2]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.everyLimit" id="apidoc.element.neo-async.everyLimit">
        function <span class="apidocSignatureSpan">neo-async.</span>everyLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function everyLimit(collection, limit, iterator, callback) {
  callback = callback || noop;
  denyLimit(collection, limit, iterator, done);

  function done(err, res) {
    if (err) {
      return callback(err);
    }
    callback(null, !res);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 5, 3, 4, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">everyLimit</span>(array, 2, iterator, function(err, res) {
*   console.log(res); // false
*   console.log(order); // [1, 3, 5, 2]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.everySeries" id="apidoc.element.neo-async.everySeries">
        function <span class="apidocSignatureSpan">neo-async.</span>everySeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function everySeries(collection, iterator, callback) {
  callback = callback || noop;
  denySeries(collection, iterator, done);

  function done(err, res) {
    if (err) {
      return callback(err);
    }
    callback(null, !res);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">everySeries</span>(array, iterator, function(err, res) {
*   console.log(res); // false
*   console.log(order); // [1, 3, 2]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.fast" id="apidoc.element.neo-async.fast">
        function <span class="apidocSignatureSpan">neo-async.</span>fast
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fast() {
  createImmediate(false);
  return exports;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.filter" id="apidoc.element.neo-async.filter">
        function <span class="apidocSignatureSpan">neo-async.</span>filter
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filter = function (collection, iterator, callback) {
  callback = callback || noop;
  var size, keys, result;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    result = Array(size);
    arrayEach(collection, iterator, createCallback);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    result = Array(size);
    symbolEach(collection, iterator, createCallback);
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    result = Array(size);
    baseEach(collection, iterator, createCallback, keys);
  }
  if (!size) {
    return callback(null, []);
  }

  function createCallback(index, value) {
    return function done(err, res) {
      if (index === null) {
        throwError();
      }
      if (err) {
        index = null;
        callback = once(callback);
        callback(err);
        return;
      }
      if (!!res === bool) {
        result[index] = value;
      }
      index = null;
      if (++completed === size) {
        callback(null, compact(result));
      }
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">filter</span>(array, iterator, function(err, res) {
*   console.log(res); // [1, 3];
*   console.log(order); // [1, 2, 3]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.filterLimit" id="apidoc.element.neo-async.filterLimit">
        function <span class="apidocSignatureSpan">neo-async.</span>filterLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filterLimit = function (collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, value, keys, iter, item, iterate, result;
  var sync = false;
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null, []);
  }
  result = Array(size);
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, createCallback(value, index));
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, index, createCallback(value, index));
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, createCallback(value, started++));
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, started, createCallback(value, started++));
    }
  }

  function objectIterator() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[keys[index]];
      iterator(value, createCallback(value, index));
    }
  }

  function objectIteratorWithKey() {
    index = started++;
    if (index &#x3c; size) {
      key = keys[index];
      value = collection[key];
      iterator(value, key, createCallback(value, index));
    }
  }

  function createCallback(value, index) {
    return function(err, res) {
      if (index === null) {
        throwError();
      }
      if (err) {
        index = null;
        iterate = noop;
        callback = once(callback);
        callback(err);
        return;
      }
      if (!!res === bool) {
        result[index] = value;
      }
      index = null;
      if (++completed === size) {
        callback = onlyOnce(callback);
        callback(null, compact(result));
      } else if (sync) {
        nextTick(iterate);
      } else {
        sync = true;
        iterate();
      }
      sync = false;
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 5, 3, 4, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">filterLimit</span>(array, 2, iterator, function(err, res) {
*   console.log(res); // [1, 5, 3]
*   console.log(order); // [1, 3, 5, 2, 4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.filterSeries" id="apidoc.element.neo-async.filterSeries">
        function <span class="apidocSignatureSpan">neo-async.</span>filterSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filterSeries = function (collection, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, value, keys, iter, iterate;
  var sync = false;
  var completed = 0;
  var result = [];

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null, []);
  }
  iterate();

  function arrayIterator() {
    value = collection[completed];
    iterator(value, done);
  }

  function arrayIteratorWithIndex() {
    value = collection[completed];
    iterator(value, completed, done);
  }

  function symbolIterator() {
    value = iter.next().value;
    iterator(value, done);
  }

  function symbolIteratorWithKey() {
    value = iter.next().value;
    iterator(value, completed, done);
  }

  function objectIterator() {
    key = keys[completed];
    value = collection[key];
    iterator(value, done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    value = collection[key];
    iterator(value, key, done);
  }

  function done(err, res) {
    if (err) {
      callback(err);
      return;
    }
    if (!!res === bool) {
      result[result.length] = value;
    }
    if (++completed === size) {
      iterate = throwError;
      callback(null, result);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">filterSeries</span>(array, iterator, function(err, res) {
*   console.log(res); // [1, 3];
*   console.log(order); // [1, 3, 2]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.find" id="apidoc.element.neo-async.find">
        function <span class="apidocSignatureSpan">neo-async.</span>find
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">find = function (collection, iterator, callback) {
  callback = callback || noop;
  var size, keys;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    arrayEach(collection, iterator, createCallback);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    symbolEach(collection, iterator, createCallback);
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    baseEach(collection, iterator, createCallback, keys);
  }
  if (!size) {
    callback(null);
  }

  function createCallback(value) {
    var called = false;
    return function done(err, res) {
      if (called) {
        throwError();
      }
      called = true;
      if (err) {
        callback = once(callback);
        callback(err);
      } else if (!!res === bool) {
        callback = once(callback);
        callback(null, value);
      } else if (++completed === size) {
        callback(null);
      }
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.findLimit" id="apidoc.element.neo-async.findLimit">
        function <span class="apidocSignatureSpan">neo-async.</span>findLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findLimit = function (collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, value, keys, iter, item, iterate;
  var sync = false;
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null);
  }
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, createCallback(value));
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, index, createCallback(value));
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, createCallback(value));
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, started++, createCallback(value));
    }
  }

  function objectIterator() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[keys[index]];
      iterator(value, createCallback(value));
    }
  }

  function objectIteratorWithKey() {
    if (started &#x3c; size) {
      key = keys[started++];
      value = collection[key];
      iterator(value, key, createCallback(value));
    }
  }

  function createCallback(value) {
    var called = false;
    return function(err, res) {
      if (called) {
        throwError();
      }
      called = true;
      if (err) {
        iterate = noop;
        callback = once(callback);
        callback(err);
      } else if (!!res === bool) {
        iterate = noop;
        callback = once(callback);
        callback(null, value);
      } else if (++completed === size) {
        callback(null);
      } else if (sync) {
        nextTick(iterate);
      } else {
        sync = true;
        iterate();
      }
      sync = false;
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.findSeries" id="apidoc.element.neo-async.findSeries">
        function <span class="apidocSignatureSpan">neo-async.</span>findSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findSeries = function (collection, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, value, keys, iter, iterate;
  var sync = false;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null);
  }
  iterate();

  function arrayIterator() {
    value = collection[completed];
    iterator(value, done);
  }

  function arrayIteratorWithIndex() {
    value = collection[completed];
    iterator(value, completed, done);
  }

  function symbolIterator() {
    value = iter.next().value;
    iterator(value, done);
  }

  function symbolIteratorWithKey() {
    value = iter.next().value;
    iterator(value, completed, done);
  }

  function objectIterator() {
    value = collection[keys[completed]];
    iterator(value, done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    value = collection[key];
    iterator(value, key, done);
  }

  function done(err, res) {
    if (err) {
      callback(err);
    } else if (!!res === bool) {
      iterate = throwError;
      callback(null, value);
    } else if (++completed === size) {
      iterate = throwError;
      callback(null);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.foldl" id="apidoc.element.neo-async.foldl">
        function <span class="apidocSignatureSpan">neo-async.</span>foldl
        <span class="apidocSignatureSpan">(collection, result, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduce(collection, result, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, keys, iter, iterate;
  var sync = false;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 4 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 4 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 4 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null, result);
  }
  iterate(result);

  function arrayIterator(result) {
    iterator(result, collection[completed], done);
  }

  function arrayIteratorWithIndex(result) {
    iterator(result, collection[completed], completed, done);
  }

  function symbolIterator() {
    iterator(result, iter.next().value, done);
  }

  function symbolIteratorWithKey() {
    iterator(result, iter.next().value, completed, done);
  }

  function objectIterator(result) {
    iterator(result, collection[keys[completed]], done);
  }

  function objectIteratorWithKey(result) {
    key = keys[completed];
    iterator(result, collection[key], key, done);
  }

  function done(err, result) {
    if (err) {
      callback(err, result);
    } else if (++completed === size) {
      iterator = throwError;
      callback(null, result);
    } else if (sync) {
      nextTick(function() {
        iterate(result);
      });
    } else {
      sync = true;
      iterate(result);
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.foldr" id="apidoc.element.neo-async.foldr">
        function <span class="apidocSignatureSpan">neo-async.</span>foldr
        <span class="apidocSignatureSpan">(collection, result, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduceRight(collection, result, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var resIndex, index, key, keys, iter, item, col, iterate;
  var sync = false;

  if (isArray(collection)) {
    resIndex = collection.length;
    iterate = iterator.length === 4 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    resIndex = collection.size;
    col = Array(resIndex);
    iter = collection[iteratorSymbol]();
    index = -1;
    while ((item = iter.next()).done === false) {
      col[++index] = item.value;
    }
    collection = col;
    iterate = iterator.length === 4 ? arrayIteratorWithIndex : arrayIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    resIndex = keys.length;
    iterate = iterator.length === 4 ? objectIteratorWithKey : objectIterator;
  }
  if (!resIndex) {
    return callback(null, result);
  }
  iterate(result);

  function arrayIterator(result) {
    iterator(result, collection[--resIndex], done);
  }

  function arrayIteratorWithIndex(result) {
    iterator(result, collection[--resIndex], resIndex, done);
  }

  function objectIterator(result) {
    iterator(result, collection[keys[--resIndex]], done);
  }

  function objectIteratorWithKey(result) {
    key = keys[--resIndex];
    iterator(result, collection[key], key, done);
  }

  function done(err, result) {
    if (err) {
      callback(err, result);
    } else if (resIndex === 0) {
      iterate = throwError;
      callback(null, result);
    } else if (sync) {
      nextTick(function() {
        iterate(result);
      });
    } else {
      sync = true;
      iterate(result);
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.forEach" id="apidoc.element.neo-async.forEach">
        function <span class="apidocSignatureSpan">neo-async.</span>forEach
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function each(collection, iterator, callback) {
  callback = callback || noop;
  var size, keys;
  var completed = 0;
  if (isArray(collection)) {
    size = collection.length;
    arrayEach(collection, iterator, done);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    symbolEach(collection, iterator, done);
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    baseEach(collection, iterator, done, keys);
  }
  if (!size) {
    callback(null);
  }

  function done(err, bool) {
    if (err) {
      callback = once(callback);
      callback(err);
    } else if (++completed === size) {
      callback(null);
    } else if (bool === false) {
      callback = once(callback);
      callback(null);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.forEachLimit" id="apidoc.element.neo-async.forEachLimit">
        function <span class="apidocSignatureSpan">neo-async.</span>forEachLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachLimit(collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, keys, iter, item, iterate;
  var sync = false;
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  } else {
    return callback(null);
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null);
  }
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    if (started &#x3c; size) {
      iterator(collection[started++], done);
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      iterator(collection[index], index, done);
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      iterator(item.value, done);
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      iterator(item.value, started++, done);
    }
  }

  function objectIterator() {
    if (started &#x3c; size) {
      iterator(collection[keys[started++]], done);
    }
  }

  function objectIteratorWithKey() {
    index = started++;
    if (index &#x3c; size) {
      key = keys[index];
      iterator(collection[key], key, done);
    }
  }

  function done(err, bool) {
    if (err) {
      iterate = noop;
      callback = once(callback);
      callback(err);
    } else if (++completed === size) {
      iterate = throwError;
      callback = onlyOnce(callback);
      callback(null);
    } else if (bool === false) {
      iterate = noop;
      callback = once(callback);
      callback(null);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.forEachOf" id="apidoc.element.neo-async.forEachOf">
        function <span class="apidocSignatureSpan">neo-async.</span>forEachOf
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function each(collection, iterator, callback) {
  callback = callback || noop;
  var size, keys;
  var completed = 0;
  if (isArray(collection)) {
    size = collection.length;
    arrayEach(collection, iterator, done);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    symbolEach(collection, iterator, done);
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    baseEach(collection, iterator, done, keys);
  }
  if (!size) {
    callback(null);
  }

  function done(err, bool) {
    if (err) {
      callback = once(callback);
      callback(err);
    } else if (++completed === size) {
      callback(null);
    } else if (bool === false) {
      callback = once(callback);
      callback(null);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.forEachOfLimit" id="apidoc.element.neo-async.forEachOfLimit">
        function <span class="apidocSignatureSpan">neo-async.</span>forEachOfLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachLimit(collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, keys, iter, item, iterate;
  var sync = false;
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  } else {
    return callback(null);
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null);
  }
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    if (started &#x3c; size) {
      iterator(collection[started++], done);
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      iterator(collection[index], index, done);
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      iterator(item.value, done);
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      iterator(item.value, started++, done);
    }
  }

  function objectIterator() {
    if (started &#x3c; size) {
      iterator(collection[keys[started++]], done);
    }
  }

  function objectIteratorWithKey() {
    index = started++;
    if (index &#x3c; size) {
      key = keys[index];
      iterator(collection[key], key, done);
    }
  }

  function done(err, bool) {
    if (err) {
      iterate = noop;
      callback = once(callback);
      callback(err);
    } else if (++completed === size) {
      iterate = throwError;
      callback = onlyOnce(callback);
      callback(null);
    } else if (bool === false) {
      iterate = noop;
      callback = once(callback);
      callback(null);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.forEachOfSeries" id="apidoc.element.neo-async.forEachOfSeries">
        function <span class="apidocSignatureSpan">neo-async.</span>forEachOfSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachSeries(collection, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, keys, iter, value, iterate;
  var sync = false;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null);
  }
  iterate();

  function arrayIterator() {
    iterator(collection[completed], done);
  }

  function arrayIteratorWithIndex() {
    iterator(collection[completed], completed, done);
  }

  function symbolIterator() {
    iterator(iter.next().value, done);
  }

  function symbolIteratorWithKey() {
    value = iter.next().value;
    iterator(value, completed, done);
  }

  function objectIterator() {
    iterator(collection[keys[completed]], done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    iterator(collection[key], key, done);
  }

  function done(err, bool) {
    if (err) {
      callback(err);
    } else if (++completed === size) {
      iterate = throwError;
      callback(null);
    } else if (bool === false) {
      iterate = throwError;
      callback(null);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.forEachSeries" id="apidoc.element.neo-async.forEachSeries">
        function <span class="apidocSignatureSpan">neo-async.</span>forEachSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachSeries(collection, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, keys, iter, value, iterate;
  var sync = false;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null);
  }
  iterate();

  function arrayIterator() {
    iterator(collection[completed], done);
  }

  function arrayIteratorWithIndex() {
    iterator(collection[completed], completed, done);
  }

  function symbolIterator() {
    iterator(iter.next().value, done);
  }

  function symbolIteratorWithKey() {
    value = iter.next().value;
    iterator(value, completed, done);
  }

  function objectIterator() {
    iterator(collection[keys[completed]], done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    iterator(collection[key], key, done);
  }

  function done(err, bool) {
    if (err) {
      callback(err);
    } else if (++completed === size) {
      iterate = throwError;
      callback(null);
    } else if (bool === false) {
      iterate = throwError;
      callback(null);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.forever" id="apidoc.element.neo-async.forever">
        function <span class="apidocSignatureSpan">neo-async.</span>forever
        <span class="apidocSignatureSpan">(iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forever(iterator, callback) {
  var sync = false;
  iterate();

  function iterate() {
    iterator(next);
  }

  function next(err) {
    if (err) {
      if (callback) {
        return callback(err);
      }
      throw err;
    }
    if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.groupBy" id="apidoc.element.neo-async.groupBy">
        function <span class="apidocSignatureSpan">neo-async.</span>groupBy
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function groupBy(collection, iterator, callback) {
  callback = callback || noop;
  var size;
  var completed = 0;
  var result = {};

  if (isArray(collection)) {
    size = collection.length;
    arrayEach(collection, iterator, createCallback);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    symbolEach(collection, iterator, createCallback);
  } else if (typeof collection === obj) {
    var keys = nativeKeys(collection);
    size = keys.length;
    baseEach(collection, iterator, createCallback, keys);
  }
  if (!size) {
    callback(null, {});
  }

  function createCallback(value) {
    var called = false;
    return function done(err, key) {
      if (called) {
        throwError();
      }
      called = true;
      if (err) {
        callback = once(callback);
        callback(err, objectClone(result));
        return;
      }
      var array = result[key];
      if (!array) {
        array = result[key] = [value];
      } else {
        array.push(value);
      }
      if (++completed === size) {
        callback(null, result);
      }
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [4.2, 6.4, 6.1];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, Math.floor(num));
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">groupBy</span>(array, iterator, function(err, res) {
*   console.log(res); // { &#x27;4&#x27;: [4.2], &#x27;6&#x27;: [6.1, 6.4] }
*   console.log(order); // [4.2, 6.1, 6.4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.groupByLimit" id="apidoc.element.neo-async.groupByLimit">
        function <span class="apidocSignatureSpan">neo-async.</span>groupByLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function groupByLimit(collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, value, keys, iter, item, iterate;
  var sync = false;
  var started = 0;
  var completed = 0;
  var result = {};

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null, result);
  }
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    if (started &#x3c; size) {
      value = collection[started++];
      iterator(value, createCallback(value));
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, index, createCallback(value));
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, createCallback(value));
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, started++, createCallback(value));
    }
  }

  function objectIterator() {
    if (started &#x3c; size) {
      value = collection[keys[started++]];
      iterator(value, createCallback(value));
    }
  }

  function objectIteratorWithKey() {
    if (started &#x3c; size) {
      key = keys[started++];
      value = collection[key];
      iterator(value, key, createCallback(value));
    }
  }

  function createCallback(value) {
    var called = false;
    return function(err, key) {
      if (called) {
        throwError();
      }
      called = true;
      if (err) {
        iterate = noop;
        callback = once(callback);
        callback(err, objectClone(result));
        return;
      }
      var array = result[key];
      if (!array) {
        result[key] = [value];
      } else {
        array.push(value);
      }
      if (++completed === size) {
        callback(null, result);
      } else if (sync) {
        nextTick(iterate);
      } else {
        sync = true;
        iterate();
      }
      sync = false;
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1.1, 5.9, 3.2, 3.9, 2.1];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, Math.floor(num));
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">groupByLimit</span>(array, 2, iterator, function(err, res) {
*   console.log(res); // { &#x27;1&#x27;: [1.1], &#x27;3&#x27;: [3.2, 3.9], &#x27;5&#x27;: [5.9], &#x27;2&#x27;: [2.1] }
*   console.log(order); // [1.1, 3.2, 5.9, 2.1, 3.9]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.groupBySeries" id="apidoc.element.neo-async.groupBySeries">
        function <span class="apidocSignatureSpan">neo-async.</span>groupBySeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function groupBySeries(collection, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, value, keys, iter, iterate;
  var sync = false;
  var completed = 0;
  var result = {};

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null, result);
  }
  iterate();

  function arrayIterator() {
    value = collection[completed];
    iterator(value, done);
  }

  function arrayIteratorWithIndex() {
    value = collection[completed];
    iterator(value, completed, done);
  }

  function symbolIterator() {
    value = iter.next().value;
    iterator(value, done);
  }

  function symbolIteratorWithKey() {
    value = iter.next().value;
    iterator(value, completed, done);
  }

  function objectIterator() {
    value = collection[keys[completed]];
    iterator(value, done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    value = collection[key];
    iterator(value, key, done);
  }

  function done(err, key) {
    if (err) {
      iterate = throwError;
      callback = onlyOnce(callback);
      callback(err, objectClone(result));
      return;
    }
    var array = result[key];
    if (!array) {
      array = result[key] = [value];
    } else {
      array.push(value);
    }
    if (++completed === size) {
      iterate = throwError;
      callback(null, result);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [4.2, 6.4, 6.1];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, Math.floor(num));
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">groupBySeries</span>(array, iterator, function(err, res) {
*   console.log(res); // { &#x27;4&#x27;: [4.2], &#x27;6&#x27;: [6.4, 6.1] }
*   console.log(order); // [4.2, 6.4, 6.1]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.inject" id="apidoc.element.neo-async.inject">
        function <span class="apidocSignatureSpan">neo-async.</span>inject
        <span class="apidocSignatureSpan">(collection, result, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduce(collection, result, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, keys, iter, iterate;
  var sync = false;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 4 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 4 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 4 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null, result);
  }
  iterate(result);

  function arrayIterator(result) {
    iterator(result, collection[completed], done);
  }

  function arrayIteratorWithIndex(result) {
    iterator(result, collection[completed], completed, done);
  }

  function symbolIterator() {
    iterator(result, iter.next().value, done);
  }

  function symbolIteratorWithKey() {
    iterator(result, iter.next().value, completed, done);
  }

  function objectIterator(result) {
    iterator(result, collection[keys[completed]], done);
  }

  function objectIteratorWithKey(result) {
    key = keys[completed];
    iterator(result, collection[key], key, done);
  }

  function done(err, result) {
    if (err) {
      callback(err, result);
    } else if (++completed === size) {
      iterator = throwError;
      callback(null, result);
    } else if (sync) {
      nextTick(function() {
        iterate(result);
      });
    } else {
      sync = true;
      iterate(result);
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.iterator" id="apidoc.element.neo-async.iterator">
        function <span class="apidocSignatureSpan">neo-async.</span>iterator
        <span class="apidocSignatureSpan">(tasks)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function iterator(tasks) {
  var size = 0;
  var keys = [];
  if (isArray(tasks)) {
    size = tasks.length;
  } else {
    keys = nativeKeys(tasks);
    size = keys.length;
  }
  return makeCallback(0);

  function makeCallback(index) {
    var fn = function() {
      if (size) {
        var key = keys[index] || index;
        tasks[key].apply(null, createArray(arguments));
      }
      return fn.next();
    };
    fn.next = function() {
      return (index &#x3c; size - 1) ? makeCallback(index + 1) : null;
    };
    return fn;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.log" id="apidoc.element.neo-async.log">
        function <span class="apidocSignatureSpan">neo-async.</span>log
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">log = function (fn) {
  var args = slice(arguments, 1);
  args.push(done);
  fn.apply(null, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done();
*   }, num * 10);
* };
* async.each(array, iterator, function(err, res) {
*   console.<span class="apidocCodeKeywordSpan">log</span>(res); // undefined
*   console.log(order); // [1, 2, 3]
* });
*
* @example
*
* // array with index
* var order = [];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.map" id="apidoc.element.neo-async.map">
        function <span class="apidocSignatureSpan">neo-async.</span>map
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (collection, iterator, callback) {
  callback = callback || noop;
  var size, keys, result;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    result = init(size);
    arrayEach(collection, iterator, createCallback);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    result = init(size);
    symbolEach(collection, iterator, createCallback);
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    result = init(size);
    baseEach(collection, iterator, createCallback, keys);
  }
  if (!size) {
    callback(null, init());
  }

  function createCallback(key) {
    return function done(err, res) {
      if (key === null) {
        throwError();
      }
      if (err) {
        key = null;
        callback = once(callback);
        callback(err, clone(result));
        return;
      }
      result[key] = res;
      key = null;
      if (++completed === size) {
        callback(null, result);
      }
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">map</span>(array, iterator, function(err, res) {
*   console.log(res); // [1, 3, 2];
*   console.log(order); // [1, 2, 3]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.mapLimit" id="apidoc.element.neo-async.mapLimit">
        function <span class="apidocSignatureSpan">neo-async.</span>mapLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mapLimit(collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, keys, iter, item, result, iterate;
  var sync = false;
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null, []);
  }
  result = Array(size);
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    index = started++;
    if (index &#x3c; size) {
      iterator(collection[index], createCallback(index));
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      iterator(collection[index], index, createCallback(index));
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      iterator(item.value, createCallback(started++));
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      iterator(item.value, started, createCallback(started++));
    }
  }

  function objectIterator() {
    index = started++;
    if (index &#x3c; size) {
      iterator(collection[keys[index]], createCallback(index));
    }
  }

  function objectIteratorWithKey() {
    index = started++;
    if (index &#x3c; size) {
      key = keys[index];
      iterator(collection[key], key, createCallback(index));
    }
  }

  function createCallback(index) {
    return function(err, res) {
      if (index === null) {
        throwError();
      }
      if (err) {
        index = null;
        iterate = noop;
        callback = once(callback);
        callback(err, createArray(result));
        return;
      }
      result[index] = res;
      index = null;
      if (++completed === size) {
        iterate = throwError;
        callback(null, result);
        callback = throwError;
      } else if (sync) {
        nextTick(iterate);
      } else {
        sync = true;
        iterate();
      }
      sync = false;
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 5, 3, 4, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">mapLimit</span>(array, 2, iterator, function(err, res) {
*   console.log(res); // [1, 5, 3, 4, 2]
*   console.log(order); // [1, 3, 5, 2, 4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.mapSeries" id="apidoc.element.neo-async.mapSeries">
        function <span class="apidocSignatureSpan">neo-async.</span>mapSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mapSeries(collection, iterator, callback) {
  callback = callback || noop;
  var size, key, keys, iter, value, result, iterate;
  var sync = false;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null, []);
  }
  result = Array(size);
  iterate();

  function arrayIterator() {
    iterator(collection[completed], done);
  }

  function arrayIteratorWithIndex() {
    iterator(collection[completed], completed, done);
  }

  function symbolIterator() {
    iterator(iter.next().value, done);
  }

  function symbolIteratorWithKey() {
    value = iter.next().value;
    iterator(value, completed, done);
  }

  function objectIterator() {
    iterator(collection[keys[completed]], done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    iterator(collection[key], key, done);
  }

  function done(err, res) {
    if (err) {
      iterate = throwError;
      callback = onlyOnce(callback);
      callback(err, createArray(result));
      return;
    }
    result[completed] = res;
    if (++completed === size) {
      iterate = throwError;
      callback(null, result);
      callback = throwError;
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">mapSeries</span>(array, iterator, function(err, res) {
*   console.log(res); // [1, 3, 2];
*   console.log(order); // [1, 3, 2]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.mapValues" id="apidoc.element.neo-async.mapValues">
        function <span class="apidocSignatureSpan">neo-async.</span>mapValues
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapValues = function (collection, iterator, callback) {
  callback = callback || noop;
  var size, keys, result;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    result = init(size);
    arrayEach(collection, iterator, createCallback);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    result = init(size);
    symbolEach(collection, iterator, createCallback);
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    result = init(size);
    baseEach(collection, iterator, createCallback, keys);
  }
  if (!size) {
    callback(null, init());
  }

  function createCallback(key) {
    return function done(err, res) {
      if (key === null) {
        throwError();
      }
      if (err) {
        key = null;
        callback = once(callback);
        callback(err, clone(result));
        return;
      }
      result[key] = res;
      key = null;
      if (++completed === size) {
        callback(null, result);
      }
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">mapValues</span>(array, iterator, function(err, res) {
*   console.log(res); // { &#x27;0&#x27;: 1, &#x27;1&#x27;: 3, &#x27;2&#x27;: 2 }
*   console.log(order); // [1, 2, 3]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.mapValuesLimit" id="apidoc.element.neo-async.mapValuesLimit">
        function <span class="apidocSignatureSpan">neo-async.</span>mapValuesLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mapValuesLimit(collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, keys, iter, item, iterate;
  var sync = false;
  var result = {};
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null, result);
  }
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    index = started++;
    if (index &#x3c; size) {
      iterator(collection[index], createCallback(index));
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      iterator(collection[index], index, createCallback(index));
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      iterator(item.value, createCallback(started++));
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      iterator(item.value, started, createCallback(started++));
    }
  }

  function objectIterator() {
    index = started++;
    if (index &#x3c; size) {
      key = keys[index];
      iterator(collection[key], createCallback(key));
    }
  }

  function objectIteratorWithKey() {
    index = started++;
    if (index &#x3c; size) {
      key = keys[index];
      iterator(collection[key], key, createCallback(key));
    }
  }

  function createCallback(key) {
    return function(err, res) {
      if (key === null) {
        throwError();
      }
      if (err) {
        key = null;
        iterate = noop;
        callback = once(callback);
        callback(err, objectClone(result));
        return;
      }
      result[key] = res;
      key = null;
      if (++completed === size) {
        callback(null, result);
      } else if (sync) {
        nextTick(iterate);
      } else {
        sync = true;
        iterate();
      }
      sync = false;
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 5, 3, 4, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">mapValuesLimit</span>(array, 2, iterator, function(err, res) {
*   console.log(res); // { &#x27;0&#x27;: 1, &#x27;1&#x27;: 5, &#x27;2&#x27;: 3, &#x27;3&#x27;: 4, &#x27;4&#x27;: 2 }
*   console.log(order); // [1, 3, 5, 2, 4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.mapValuesSeries" id="apidoc.element.neo-async.mapValuesSeries">
        function <span class="apidocSignatureSpan">neo-async.</span>mapValuesSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mapValuesSeries(collection, iterator, callback) {
  callback = callback || noop;
  var size, key, keys, iter, value, iterate;
  var sync = false;
  var result = {};
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null, result);
  }
  iterate();

  function arrayIterator() {
    key = completed;
    iterator(collection[completed], done);
  }

  function arrayIteratorWithIndex() {
    key = completed;
    iterator(collection[completed], completed, done);
  }

  function symbolIterator() {
    key = completed;
    value = iter.next().value;
    iterator(value, done);
  }

  function symbolIteratorWithKey() {
    key = completed;
    value = iter.next().value;
    iterator(value, completed, done);
  }

  function objectIterator() {
    key = keys[completed];
    iterator(collection[key], done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    iterator(collection[key], key, done);
  }

  function done(err, res) {
    if (err) {
      iterate = throwError;
      callback = onlyOnce(callback);
      callback(err, objectClone(result));
      return;
    }
    result[key] = res;
    if (++completed === size) {
      iterate = throwError;
      callback(null, result);
      callback = throwError;
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">mapValuesSeries</span>(array, iterator, function(err, res) {
*   console.log(res); // { &#x27;0&#x27;: 1, &#x27;1&#x27;: 3, &#x27;2&#x27;: 2 }
*   console.log(order); // [1, 3, 2]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.memoize" id="apidoc.element.neo-async.memoize">
        function <span class="apidocSignatureSpan">neo-async.</span>memoize
        <span class="apidocSignatureSpan">(fn, hasher)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function memoize(fn, hasher) {
  hasher = hasher || function(hash) {
    return hash;
  };

  var memo = {};
  var queues = {};
  var memoized = function() {
    var args = createArray(arguments);
    var callback = args.pop();
    var key = hasher.apply(null, args);
    if (has(memo, key)) {
      nextTick(function() {
        callback.apply(null, memo[key]);
      });
      return;
    }
    if (has(queues, key)) {
      return queues[key].push(callback);
    }

    queues[key] = [callback];
    args.push(done);
    fn.apply(null, args);

    function done() {
      var args = createArray(arguments);
      memo[key] = args;
      var q = queues[key];
      delete queues[key];

      var i = -1;
      var size = q.length;
      while (++i &#x3c; size) {
        q[i].apply(null, args);
      }
    }
  };
  memoized.memo = memo;
  memoized.unmemoized = fn;
  return memoized;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.nextTick" id="apidoc.element.neo-async.nextTick">
        function <span class="apidocSignatureSpan">neo-async.</span>nextTick
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nextTick(callback) {
  if (typeof callback !== &#x27;function&#x27;)
    throw new TypeError(&#x27;callback is not a function&#x27;);
  // on the way out, don&#x27;t bother. it won&#x27;t get fired anyway.
  if (process._exiting)
    return;

  var args;
  if (arguments.length &#x3e; 1) {
    args = new Array(arguments.length - 1);
    for (var i = 1; i &#x3c; arguments.length; i++)
      args[i - 1] = arguments[i];
  }

  nextTickQueue.push({
    callback,
    domain: process.domain || null,
    args
  });
  tickInfo[kLength]++;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.omit" id="apidoc.element.neo-async.omit">
        function <span class="apidocSignatureSpan">neo-async.</span>omit
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">omit = function (collection, iterator, callback) {
  callback = callback || noop;
  var size, keys;
  var completed = 0;
  var result = {};

  if (isArray(collection)) {
    size = collection.length;
    arrayEach(collection, iterator, createCallback);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    symbolEach(collection, iterator, createCallback);
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    baseEach(collection, iterator, createCallback, keys);
  }
  if (!size) {
    return callback(null, {});
  }

  function createCallback(key, value) {
    return function done(err, res) {
      if (key === null) {
        throwError();
      }
      if (err) {
        key = null;
        callback = once(callback);
        callback(err, objectClone(result));
        return;
      }
      if (!!res === bool) {
        result[key] = value;
      }
      key = null;
      if (++completed === size) {
        callback(null, result);
      }
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2, 4];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">omit</span>(array, iterator, function(err, res) {
*   console.log(res); // { &#x27;2&#x27;: 2, &#x27;3&#x27;: 4 }
*   console.log(order); // [1, 2, 3, 4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.omitLimit" id="apidoc.element.neo-async.omitLimit">
        function <span class="apidocSignatureSpan">neo-async.</span>omitLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">omitLimit = function (collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, value, keys, iter, item, iterate;
  var sync = false;
  var result = {};
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null, {});
  }
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, createCallback(value, index));
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, index, createCallback(value, index));
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, createCallback(value, started++));
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, started, createCallback(value, started++));
    }
  }

  function objectIterator() {
    if (started &#x3c; size) {
      key = keys[started++];
      value = collection[key];
      iterator(value, createCallback(value, key));
    }
  }

  function objectIteratorWithKey() {
    if (started &#x3c; size) {
      key = keys[started++];
      value = collection[key];
      iterator(value, key, createCallback(value, key));
    }
  }

  function createCallback(value, key) {
    return function(err, res) {
      if (key === null) {
        throwError();
      }
      if (err) {
        key = null;
        iterate = noop;
        callback = once(callback);
        callback(err, objectClone(result));
        return;
      }
      if (!!res === bool) {
        result[key] = value;
      }
      key = null;
      if (++completed === size) {
        iterate = throwError;
        callback = onlyOnce(callback);
        callback(null, result);
      } else if (sync) {
        nextTick(iterate);
      } else {
        sync = true;
        iterate();
      }
      sync = false;
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 5, 3, 4, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">omitLimit</span>(array, 2, iterator, function(err, res) {
*   console.log(res); // { &#x27;3&#x27;: 4, &#x27;4&#x27;: 2 }
*   console.log(order); // [1, 3, 5, 2, 4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.omitSeries" id="apidoc.element.neo-async.omitSeries">
        function <span class="apidocSignatureSpan">neo-async.</span>omitSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">omitSeries = function (collection, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, value, keys, iter, iterate;
  var sync = false;
  var result = {};
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null, {});
  }
  iterate();

  function arrayIterator() {
    key = completed;
    value = collection[completed];
    iterator(value, done);
  }

  function arrayIteratorWithIndex() {
    key = completed;
    value = collection[completed];
    iterator(value, completed, done);
  }

  function symbolIterator() {
    key = completed;
    value = iter.next().value;
    iterator(value, done);
  }

  function symbolIteratorWithKey() {
    key = completed;
    value = iter.next().value;
    iterator(value, key, done);
  }

  function objectIterator() {
    key = keys[completed];
    value = collection[key];
    iterator(value, done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    value = collection[key];
    iterator(value, key, done);
  }

  function done(err, res) {
    if (err) {
      callback(err, result);
      return;
    }
    if (!!res === bool) {
      result[key] = value;
    }
    if (++completed === size) {
      iterate = throwError;
      callback(null, result);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2, 4];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">omitSeries</span>(array, iterator, function(err, res) {
*   console.log(res); // { &#x27;2&#x27;: 2, &#x27;3&#x27;: 4 }
*   console.log(order); // [1, 3, 2, 4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.parallel" id="apidoc.element.neo-async.parallel">
        function <span class="apidocSignatureSpan">neo-async.</span>parallel
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parallel(tasks, callback) {
  callback = callback || noop;
  var size, keys, result;
  var completed = 0;

  if (isArray(tasks)) {
    size = tasks.length;
    result = Array(size);
    arrayEach(tasks, createCallback);
  } else if (tasks &#x26;&#x26; typeof tasks === obj) {
    keys = nativeKeys(tasks);
    size = keys.length;
    result = {};
    baseEach(tasks, createCallback, keys);
  }
  if (!size) {
    callback(null, result);
  }

  function createCallback(key) {
    return function(err, res) {
      if (key === null) {
        throwError();
      }
      if (err) {
        key = null;
        callback = once(callback);
        callback(err, result);
        return;
      }
      result[key] = arguments.length &#x3c;= 2 ? res : slice(arguments, 1);
      key = null;
      if (++completed === size) {
        callback(null, result);
      }
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*  function(done) {
*    setTimeout(function() {
*      order.push(4);
*      done(null, 4);
*    }, 20);
*  }
* ];
* async.<span class="apidocCodeKeywordSpan">parallel</span>(tasks, function(err, res) {
*   console.log(res); // [1, 2, 3, 4];
*   console.log(order); // [1, 4, 2, 3]
* });
*
* @example
*
* var order = [];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.parallelLimit" id="apidoc.element.neo-async.parallelLimit">
        function <span class="apidocSignatureSpan">neo-async.</span>parallelLimit
        <span class="apidocSignatureSpan">(tasks, limit, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parallelLimit(tasks, limit, callback) {
  callback = callback || noop;
  var size, index, key, keys, result, iterate;
  var sync = false;
  var started = 0;
  var completed = 0;

  if (isArray(tasks)) {
    size = tasks.length;
    result = Array(size);
    iterate = arrayIterator;
  } else if (tasks &#x26;&#x26; typeof tasks === obj) {
    keys = nativeKeys(tasks);
    size = keys.length;
    result = {};
    iterate = objectIterator;
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null, result);
  }
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    index = started++;
    if (index &#x3c; size) {
      tasks[index](createCallback(index));
    }
  }

  function objectIterator() {
    if (started &#x3c; size) {
      key = keys[started++];
      tasks[key](createCallback(key));
    }
  }

  function createCallback(key) {
    return function(err, res) {
      if (key === null) {
        throwError();
      }
      if (err) {
        key = null;
        iterate = noop;
        callback = once(callback);
        callback(err, result);
        return;
      }
      result[key] = arguments.length &#x3c;= 2 ? res : slice(arguments, 1);
      key = null;
      if (++completed === size) {
        callback(null, result);
      } else if (sync) {
        nextTick(iterate);
      } else {
        sync = true;
        iterate();
      }
      sync = false;
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*  function(done) {
*    setTimeout(function() {
*      order.push(4);
*      done(null, 4);
*    }, 40);
*  }
* ];
* async.<span class="apidocCodeKeywordSpan">parallelLimit</span>(tasks, 2, function(err, res) {
*   console.log(res); // [1, 2, 3, 4];
*   console.log(order); // [1, 3, 2, 4]
* });
*
* @example
*
* var order = [];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.pick" id="apidoc.element.neo-async.pick">
        function <span class="apidocSignatureSpan">neo-async.</span>pick
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pick = function (collection, iterator, callback) {
  callback = callback || noop;
  var size, keys;
  var completed = 0;
  var result = {};

  if (isArray(collection)) {
    size = collection.length;
    arrayEach(collection, iterator, createCallback);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    symbolEach(collection, iterator, createCallback);
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    baseEach(collection, iterator, createCallback, keys);
  }
  if (!size) {
    return callback(null, {});
  }

  function createCallback(key, value) {
    return function done(err, res) {
      if (key === null) {
        throwError();
      }
      if (err) {
        key = null;
        callback = once(callback);
        callback(err, objectClone(result));
        return;
      }
      if (!!res === bool) {
        result[key] = value;
      }
      key = null;
      if (++completed === size) {
        callback(null, result);
      }
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2, 4];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">pick</span>(array, iterator, function(err, res) {
*   console.log(res); // { &#x27;0&#x27;: 1, &#x27;1&#x27;: 3 }
*   console.log(order); // [1, 2, 3, 4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.pickLimit" id="apidoc.element.neo-async.pickLimit">
        function <span class="apidocSignatureSpan">neo-async.</span>pickLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pickLimit = function (collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, value, keys, iter, item, iterate;
  var sync = false;
  var result = {};
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null, {});
  }
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, createCallback(value, index));
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, index, createCallback(value, index));
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, createCallback(value, started++));
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, started, createCallback(value, started++));
    }
  }

  function objectIterator() {
    if (started &#x3c; size) {
      key = keys[started++];
      value = collection[key];
      iterator(value, createCallback(value, key));
    }
  }

  function objectIteratorWithKey() {
    if (started &#x3c; size) {
      key = keys[started++];
      value = collection[key];
      iterator(value, key, createCallback(value, key));
    }
  }

  function createCallback(value, key) {
    return function(err, res) {
      if (key === null) {
        throwError();
      }
      if (err) {
        key = null;
        iterate = noop;
        callback = once(callback);
        callback(err, objectClone(result));
        return;
      }
      if (!!res === bool) {
        result[key] = value;
      }
      key = null;
      if (++completed === size) {
        iterate = throwError;
        callback = onlyOnce(callback);
        callback(null, result);
      } else if (sync) {
        nextTick(iterate);
      } else {
        sync = true;
        iterate();
      }
      sync = false;
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 5, 3, 4, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">pickLimit</span>(array, 2, iterator, function(err, res) {
*   console.log(res); // { &#x27;0&#x27;: 1, &#x27;1&#x27;: 5, &#x27;2&#x27;: 3 }
*   console.log(order); // [1, 3, 5, 2, 4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.pickSeries" id="apidoc.element.neo-async.pickSeries">
        function <span class="apidocSignatureSpan">neo-async.</span>pickSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pickSeries = function (collection, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, value, keys, iter, iterate;
  var sync = false;
  var result = {};
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null, {});
  }
  iterate();

  function arrayIterator() {
    key = completed;
    value = collection[completed];
    iterator(value, done);
  }

  function arrayIteratorWithIndex() {
    key = completed;
    value = collection[completed];
    iterator(value, completed, done);
  }

  function symbolIterator() {
    key = completed;
    value = iter.next().value;
    iterator(value, done);
  }

  function symbolIteratorWithKey() {
    key = completed;
    value = iter.next().value;
    iterator(value, key, done);
  }

  function objectIterator() {
    key = keys[completed];
    value = collection[key];
    iterator(value, done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    value = collection[key];
    iterator(value, key, done);
  }

  function done(err, res) {
    if (err) {
      callback(err, result);
      return;
    }
    if (!!res === bool) {
      result[key] = value;
    }
    if (++completed === size) {
      iterate = throwError;
      callback(null, result);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2, 4];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">pickSeries</span>(array, iterator, function(err, res) {
*   console.log(res); // { &#x27;0&#x27;: 1, &#x27;1&#x27;: 3 }
*   console.log(order); // [1, 3, 2, 4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.priorityQueue" id="apidoc.element.neo-async.priorityQueue">
        function <span class="apidocSignatureSpan">neo-async.</span>priorityQueue
        <span class="apidocSignatureSpan">(worker, concurrency)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function priorityQueue(worker, concurrency) {
  var q = baseQueue(true, worker, concurrency);
  q.push = push;
  delete q.unshift;
  return q;

  function push(tasks, priority, callback) {
    q.started = true;
    priority = priority || 0;
    var _tasks = isArray(tasks) ? tasks : [tasks];
    var taskSize = _tasks.length;

    if (tasks === undefined || taskSize === 0) {
      if (q.idle()) {
        nextTick(q.drain);
      }
      return;
    }

    callback = typeof callback === func ? callback : noop;
    var nextNode = q._tasks.head;
    while (nextNode &#x26;&#x26; priority &#x3e;= nextNode.priority) {
      nextNode = nextNode.next;
    }
    while (taskSize--) {
      var item = {
        data: _tasks[taskSize],
        priority: priority,
        callback: callback
      };
      if (nextNode) {
        q._tasks.insertBefore(nextNode, item);
      } else {
        q._tasks.push(item);
      }
      nextTick(q.process);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.queue" id="apidoc.element.neo-async.queue">
        function <span class="apidocSignatureSpan">neo-async.</span>queue
        <span class="apidocSignatureSpan">(worker, concurrency)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function queue(worker, concurrency) {
  return baseQueue(true, worker, concurrency);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.race" id="apidoc.element.neo-async.race">
        function <span class="apidocSignatureSpan">neo-async.</span>race
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function race(tasks, callback) {
  callback = once(callback || noop);
  var size, keys;
  var index = -1;
  if (isArray(tasks)) {
    size = tasks.length;
    while (++index &#x3c; size) {
      tasks[index](callback);
    }
  } else if (tasks &#x26;&#x26; typeof tasks === obj) {
    keys = nativeKeys(tasks);
    size = keys.length;
    while (++index &#x3c; size) {
      tasks[keys[index]](callback);
    }
  } else {
    return callback(new TypeError(&#x27;First argument to race must be a collection of functions&#x27;));
  }
  if (!size) {
    callback(null);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*   function(done) {
*     setTimeout(function() {
*       called++;
*       done(null, &#x27;3&#x27;);
*     }, 10);
*   }
* ];
* async.<span class="apidocCodeKeywordSpan">race</span>(tasks, function(err, res) {
*   console.log(res); // &#x27;3&#x27;
*   console.log(called); // 1
*   setTimeout(function() {
*     console.log(called); // 3
*   }, 50);
* });
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.reduce" id="apidoc.element.neo-async.reduce">
        function <span class="apidocSignatureSpan">neo-async.</span>reduce
        <span class="apidocSignatureSpan">(collection, result, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduce(collection, result, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, keys, iter, iterate;
  var sync = false;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 4 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 4 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 4 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null, result);
  }
  iterate(result);

  function arrayIterator(result) {
    iterator(result, collection[completed], done);
  }

  function arrayIteratorWithIndex(result) {
    iterator(result, collection[completed], completed, done);
  }

  function symbolIterator() {
    iterator(result, iter.next().value, done);
  }

  function symbolIteratorWithKey() {
    iterator(result, iter.next().value, completed, done);
  }

  function objectIterator(result) {
    iterator(result, collection[keys[completed]], done);
  }

  function objectIteratorWithKey(result) {
    key = keys[completed];
    iterator(result, collection[key], key, done);
  }

  function done(err, result) {
    if (err) {
      callback(err, result);
    } else if (++completed === size) {
      iterator = throwError;
      callback(null, result);
    } else if (sync) {
      nextTick(function() {
        iterate(result);
      });
    } else {
      sync = true;
      iterate(result);
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var collection = [1, 3, 2, 4];
* var iterator = function(result, num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, result + num);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">reduce</span>(collection, 0, iterator, function(err, res) {
*   console.log(res); // 10
*   console.log(order); // [1, 3, 2, 4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.reduceRight" id="apidoc.element.neo-async.reduceRight">
        function <span class="apidocSignatureSpan">neo-async.</span>reduceRight
        <span class="apidocSignatureSpan">(collection, result, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduceRight(collection, result, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var resIndex, index, key, keys, iter, item, col, iterate;
  var sync = false;

  if (isArray(collection)) {
    resIndex = collection.length;
    iterate = iterator.length === 4 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    resIndex = collection.size;
    col = Array(resIndex);
    iter = collection[iteratorSymbol]();
    index = -1;
    while ((item = iter.next()).done === false) {
      col[++index] = item.value;
    }
    collection = col;
    iterate = iterator.length === 4 ? arrayIteratorWithIndex : arrayIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    resIndex = keys.length;
    iterate = iterator.length === 4 ? objectIteratorWithKey : objectIterator;
  }
  if (!resIndex) {
    return callback(null, result);
  }
  iterate(result);

  function arrayIterator(result) {
    iterator(result, collection[--resIndex], done);
  }

  function arrayIteratorWithIndex(result) {
    iterator(result, collection[--resIndex], resIndex, done);
  }

  function objectIterator(result) {
    iterator(result, collection[keys[--resIndex]], done);
  }

  function objectIteratorWithKey(result) {
    key = keys[--resIndex];
    iterator(result, collection[key], key, done);
  }

  function done(err, result) {
    if (err) {
      callback(err, result);
    } else if (resIndex === 0) {
      iterate = throwError;
      callback(null, result);
    } else if (sync) {
      nextTick(function() {
        iterate(result);
      });
    } else {
      sync = true;
      iterate(result);
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var collection = [1, 3, 2, 4];
* var iterator = function(result, num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, result + num);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">reduceRight</span>(collection, 0, iterator, function(err, res) {
*   console.log(res); // 10
*   console.log(order); // [4, 2, 3, 1]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.reflect" id="apidoc.element.neo-async.reflect">
        function <span class="apidocSignatureSpan">neo-async.</span>reflect
        <span class="apidocSignatureSpan">(func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reflect(func) {
  return function( /* args..., callback */ ) {
    var callback;
    switch (arguments.length) {
      case 1:
        callback = arguments[0];
        return func(done);
      case 2:
        callback = arguments[1];
        return func(arguments[0], done);
      default:
        var args = createArray(arguments);
        var lastIndex = args.length - 1;
        callback = args[lastIndex];
        args[lastIndex] = done;
        func.apply(this, args);
    }

    function done(err, res) {
      if (err) {
        return callback(null, {
          error: err
        });
      }
      if (arguments.length &#x3e; 2) {
        res = slice(arguments, 1);
      }
      callback(null, {
        value: res
      });
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.reflectAll" id="apidoc.element.neo-async.reflectAll">
        function <span class="apidocSignatureSpan">neo-async.</span>reflectAll
        <span class="apidocSignatureSpan">(tasks)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reflectAll(tasks) {
  var size, newTasks, keys;
  if (isArray(tasks)) {
    size = tasks.length;
    newTasks = Array(size);
    arrayEachSync(tasks, iterate);
  } else if (tasks &#x26;&#x26; typeof tasks === obj) {
    keys = nativeKeys(tasks);
    size = keys.length;
    newTasks = {};
    baseEachSync(tasks, iterate, keys);
  }
  return newTasks;

  function iterate(func, key) {
    newTasks[key] = reflect(func);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.reject" id="apidoc.element.neo-async.reject">
        function <span class="apidocSignatureSpan">neo-async.</span>reject
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reject = function (collection, iterator, callback) {
  callback = callback || noop;
  var size, keys, result;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    result = Array(size);
    arrayEach(collection, iterator, createCallback);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    result = Array(size);
    symbolEach(collection, iterator, createCallback);
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    result = Array(size);
    baseEach(collection, iterator, createCallback, keys);
  }
  if (!size) {
    return callback(null, []);
  }

  function createCallback(index, value) {
    return function done(err, res) {
      if (index === null) {
        throwError();
      }
      if (err) {
        index = null;
        callback = once(callback);
        callback(err);
        return;
      }
      if (!!res === bool) {
        result[index] = value;
      }
      index = null;
      if (++completed === size) {
        callback(null, compact(result));
      }
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">reject</span>(array, iterator, function(err, res) {
*   console.log(res); // [2];
*   console.log(order); // [1, 2, 3]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.rejectLimit" id="apidoc.element.neo-async.rejectLimit">
        function <span class="apidocSignatureSpan">neo-async.</span>rejectLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rejectLimit = function (collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, value, keys, iter, item, iterate, result;
  var sync = false;
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null, []);
  }
  result = Array(size);
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, createCallback(value, index));
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, index, createCallback(value, index));
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, createCallback(value, started++));
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, started, createCallback(value, started++));
    }
  }

  function objectIterator() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[keys[index]];
      iterator(value, createCallback(value, index));
    }
  }

  function objectIteratorWithKey() {
    index = started++;
    if (index &#x3c; size) {
      key = keys[index];
      value = collection[key];
      iterator(value, key, createCallback(value, index));
    }
  }

  function createCallback(value, index) {
    return function(err, res) {
      if (index === null) {
        throwError();
      }
      if (err) {
        index = null;
        iterate = noop;
        callback = once(callback);
        callback(err);
        return;
      }
      if (!!res === bool) {
        result[index] = value;
      }
      index = null;
      if (++completed === size) {
        callback = onlyOnce(callback);
        callback(null, compact(result));
      } else if (sync) {
        nextTick(iterate);
      } else {
        sync = true;
        iterate();
      }
      sync = false;
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 5, 3, 4, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">rejectLimit</span>(array, 2, iterator, function(err, res) {
*   console.log(res); // [4, 2]
*   console.log(order); // [1, 3, 5, 2, 4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.rejectSeries" id="apidoc.element.neo-async.rejectSeries">
        function <span class="apidocSignatureSpan">neo-async.</span>rejectSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rejectSeries = function (collection, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, value, keys, iter, iterate;
  var sync = false;
  var completed = 0;
  var result = [];

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null, []);
  }
  iterate();

  function arrayIterator() {
    value = collection[completed];
    iterator(value, done);
  }

  function arrayIteratorWithIndex() {
    value = collection[completed];
    iterator(value, completed, done);
  }

  function symbolIterator() {
    value = iter.next().value;
    iterator(value, done);
  }

  function symbolIteratorWithKey() {
    value = iter.next().value;
    iterator(value, completed, done);
  }

  function objectIterator() {
    key = keys[completed];
    value = collection[key];
    iterator(value, done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    value = collection[key];
    iterator(value, key, done);
  }

  function done(err, res) {
    if (err) {
      callback(err);
      return;
    }
    if (!!res === bool) {
      result[result.length] = value;
    }
    if (++completed === size) {
      iterate = throwError;
      callback(null, result);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">rejectSeries</span>(array, iterator, function(err, res) {
*   console.log(res); // [2];
*   console.log(order); // [1, 3, 2]
* });
*
* @example
*
* // object
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.retry" id="apidoc.element.neo-async.retry">
        function <span class="apidocSignatureSpan">neo-async.</span>retry
        <span class="apidocSignatureSpan">(opts, task, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function retry(opts, task, callback) {
  var times, intervalFunc, errorFilter;
  var count = 0;
  if (arguments.length &#x3c; 3 &#x26;&#x26; typeof opts === func) {
    callback = task || noop;
    task = opts;
    opts = null;
    times = DEFAULT_TIMES;
  } else {
    callback = callback || noop;
    switch (typeof opts) {
      case &#x27;object&#x27;:
        if (typeof opts.errorFilter === func) {
          errorFilter = opts.errorFilter;
        }
        var interval = opts.interval;
        switch (typeof interval) {
          case func:
            intervalFunc = interval;
            break;
          case &#x27;string&#x27;:
          case &#x27;number&#x27;:
            interval = +interval;
            intervalFunc = interval ? function() {
              return interval;
            } : function() {
              return DEFAULT_INTERVAL;
            };
            break;
        }
        times = +opts.times || DEFAULT_TIMES;
        break;
      case &#x27;number&#x27;:
        times = opts || DEFAULT_TIMES;
        break;
      case &#x27;string&#x27;:
        times = +opts || DEFAULT_TIMES;
        break;
      default:
        throw new Error(&#x27;Invalid arguments for async.retry&#x27;);
    }
  }
  if (typeof task !== &#x27;function&#x27;) {
    throw new Error(&#x27;Invalid arguments for async.retry&#x27;);
  }

  if (intervalFunc) {
    task(intervalCallback);
  } else {
    task(simpleCallback);
  }

  function simpleIterator() {
    task(simpleCallback);
  }

  function simpleCallback(err, res) {
    if (++count === times || !err || errorFilter &#x26;&#x26; !errorFilter(err)) {
      if (arguments.length &#x3c;= 2) {
        return callback(err, res);
      }
      var args = createArray(arguments);
      return callback.apply(null, args);
    }
    simpleIterator();
  }

  function intervalIterator() {
    task(intervalCallback);
  }

  function intervalCallback(err, res) {
    if (++count === times || !err || errorFilter &#x26;&#x26; !errorFilter(err)) {
      if (arguments.length &#x3c;= 2) {
        return callback(err, res);
      }
      var args = createArray(arguments);
      return callback.apply(null, args);
    }
    setTimeout(intervalIterator, intervalFunc(count));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.retryable" id="apidoc.element.neo-async.retryable">
        function <span class="apidocSignatureSpan">neo-async.</span>retryable
        <span class="apidocSignatureSpan">(opts, task)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function retryable(opts, task) {
  if (!task) {
    task = opts;
    opts = null;
  }
  return done;

  function done() {
    var taskFn;
    var args = createArray(arguments);
    var lastIndex = args.length - 1;
    var callback = args[lastIndex];
    switch (task.length) {
      case 1:
        taskFn = task1;
        break;
      case 2:
        taskFn = task2;
        break;
      case 3:
        taskFn = task3;
        break;
      default:
        taskFn = task4;
    }
    if (opts) {
      retry(opts, taskFn, callback);
    } else {
      retry(taskFn, callback);
    }

    function task1(done) {
      task(done);
    }

    function task2(done) {
      task(args[0], done);
    }

    function task3(done) {
      task(args[0], args[1], done);
    }

    function task4(callback) {
      args[lastIndex] = callback;
      task.apply(null, args);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.safe" id="apidoc.element.neo-async.safe">
        function <span class="apidocSignatureSpan">neo-async.</span>safe
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function safe() {
  createImmediate();
  return exports;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.select" id="apidoc.element.neo-async.select">
        function <span class="apidocSignatureSpan">neo-async.</span>select
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">select = function (collection, iterator, callback) {
  callback = callback || noop;
  var size, keys, result;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    result = Array(size);
    arrayEach(collection, iterator, createCallback);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    result = Array(size);
    symbolEach(collection, iterator, createCallback);
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    result = Array(size);
    baseEach(collection, iterator, createCallback, keys);
  }
  if (!size) {
    return callback(null, []);
  }

  function createCallback(index, value) {
    return function done(err, res) {
      if (index === null) {
        throwError();
      }
      if (err) {
        index = null;
        callback = once(callback);
        callback(err);
        return;
      }
      if (!!res === bool) {
        result[index] = value;
      }
      index = null;
      if (++completed === size) {
        callback(null, compact(result));
      }
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.selectLimit" id="apidoc.element.neo-async.selectLimit">
        function <span class="apidocSignatureSpan">neo-async.</span>selectLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selectLimit = function (collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, value, keys, iter, item, iterate, result;
  var sync = false;
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null, []);
  }
  result = Array(size);
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, createCallback(value, index));
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, index, createCallback(value, index));
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, createCallback(value, started++));
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, started, createCallback(value, started++));
    }
  }

  function objectIterator() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[keys[index]];
      iterator(value, createCallback(value, index));
    }
  }

  function objectIteratorWithKey() {
    index = started++;
    if (index &#x3c; size) {
      key = keys[index];
      value = collection[key];
      iterator(value, key, createCallback(value, index));
    }
  }

  function createCallback(value, index) {
    return function(err, res) {
      if (index === null) {
        throwError();
      }
      if (err) {
        index = null;
        iterate = noop;
        callback = once(callback);
        callback(err);
        return;
      }
      if (!!res === bool) {
        result[index] = value;
      }
      index = null;
      if (++completed === size) {
        callback = onlyOnce(callback);
        callback(null, compact(result));
      } else if (sync) {
        nextTick(iterate);
      } else {
        sync = true;
        iterate();
      }
      sync = false;
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.selectSeries" id="apidoc.element.neo-async.selectSeries">
        function <span class="apidocSignatureSpan">neo-async.</span>selectSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selectSeries = function (collection, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, value, keys, iter, iterate;
  var sync = false;
  var completed = 0;
  var result = [];

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null, []);
  }
  iterate();

  function arrayIterator() {
    value = collection[completed];
    iterator(value, done);
  }

  function arrayIteratorWithIndex() {
    value = collection[completed];
    iterator(value, completed, done);
  }

  function symbolIterator() {
    value = iter.next().value;
    iterator(value, done);
  }

  function symbolIteratorWithKey() {
    value = iter.next().value;
    iterator(value, completed, done);
  }

  function objectIterator() {
    key = keys[completed];
    value = collection[key];
    iterator(value, done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    value = collection[key];
    iterator(value, key, done);
  }

  function done(err, res) {
    if (err) {
      callback(err);
      return;
    }
    if (!!res === bool) {
      result[result.length] = value;
    }
    if (++completed === size) {
      iterate = throwError;
      callback(null, result);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.seq" id="apidoc.element.neo-async.seq">
        function <span class="apidocSignatureSpan">neo-async.</span>seq
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function seq() {
  var fns = createArray(arguments);

  return function() {

    var self = this;
    var args = createArray(arguments);
    var callback = args[args.length - 1];
    if (typeof callback === func) {
      args.pop();
    } else {
      callback = noop;
    }
    reduce(fns, args, iterator, done);

    function iterator(newargs, fn, callback) {
      var func = function(err) {
        var nextargs = slice(arguments, 1);
        callback(err, nextargs);
      };
      newargs.push(func);
      fn.apply(self, newargs);
    }

    function done(err, res) {
      res = isArray(res) ? res : [res];
      res.unshift(err);
      callback.apply(self, res);
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.series" id="apidoc.element.neo-async.series">
        function <span class="apidocSignatureSpan">neo-async.</span>series
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function series(tasks, callback) {
  callback = callback || noop;
  var size, key, keys, result, iterate;
  var sync = false;
  var completed = 0;

  if (isArray(tasks)) {
    size = tasks.length;
    result = Array(size);
    iterate = arrayIterator;
  } else if (tasks &#x26;&#x26; typeof tasks === obj) {
    keys = nativeKeys(tasks);
    size = keys.length;
    result = {};
    iterate = objectIterator;
  } else {
    return callback(null);
  }
  if (!size) {
    return callback(null, result);
  }
  iterate();

  function arrayIterator() {
    key = completed;
    tasks[completed](done);
  }

  function objectIterator() {
    key = keys[completed];
    tasks[key](done);
  }

  function done(err, res) {
    if (err) {
      iterate = throwError;
      callback = onlyOnce(callback);
      callback(err, result);
      return;
    }
    result[key] = arguments.length &#x3c;= 2 ? res : slice(arguments, 1);
    if (++completed === size) {
      iterate = throwError;
      callback(null, result);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*  function(done) {
*    setTimeout(function() {
*      order.push(4);
*      done(null, 4);
*    }, 20);
*  }
* ];
* async.<span class="apidocCodeKeywordSpan">series</span>(tasks, function(err, res) {
*   console.log(res); // [1, 2, 3, 4];
*   console.log(order); // [1, 2, 3, 4]
* });
*
* @example
*
* var order = [];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.setImmediate" id="apidoc.element.neo-async.setImmediate">
        function <span class="apidocSignatureSpan">neo-async.</span>setImmediate
        <span class="apidocSignatureSpan">(callback, arg1, arg2, arg3)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setImmediate = function (callback, arg1, arg2, arg3) {
  if (typeof callback !== &#x27;function&#x27;) {
    throw new TypeError(&#x27;&#x22;callback&#x22; argument must be a function&#x27;);
  }

  var i, args;

  switch (arguments.length) {
    // fast cases
    case 1:
      break;
    case 2:
      args = [arg1];
      break;
    case 3:
      args = [arg1, arg2];
      break;
    default:
      args = [arg1, arg2, arg3];
      for (i = 4; i &#x3c; arguments.length; i++)
        // extend array dynamically, makes .apply run much faster in v6.0.0
        args[i - 1] = arguments[i];
      break;
  }
  return createImmediate(args, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.some" id="apidoc.element.neo-async.some">
        function <span class="apidocSignatureSpan">neo-async.</span>some
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function some(collection, iterator, callback) {
  callback = callback || noop;
  detect(collection, iterator, done);

  function done(err, res) {
    if (err) {
      return callback(err);
    }
    callback(null, !!res);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">some</span>(array, iterator, function(err, res) {
*   console.log(res); // true
*   console.log(order); // [1]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.someLimit" id="apidoc.element.neo-async.someLimit">
        function <span class="apidocSignatureSpan">neo-async.</span>someLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function someLimit(collection, limit, iterator, callback) {
  callback = callback || noop;
  detectLimit(collection, limit, iterator, done);

  function done(err, res) {
    if (err) {
      return callback(err);
    }
    callback(null, !!res);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 5, 3, 4, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">someLimit</span>(array, 2, iterator, function(err, res) {
*   console.log(res); // true
*   console.log(order); // [1]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.someSeries" id="apidoc.element.neo-async.someSeries">
        function <span class="apidocSignatureSpan">neo-async.</span>someSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function someSeries(collection, iterator, callback) {
  callback = callback || noop;
  detectSeries(collection, iterator, done);

  function done(err, res) {
    if (err) {
      return callback(err);
    }
    callback(null, !!res);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">someSeries</span>(array, iterator, function(err, res) {
*   console.log(res); // true
*   console.log(order); // [1]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.sortBy" id="apidoc.element.neo-async.sortBy">
        function <span class="apidocSignatureSpan">neo-async.</span>sortBy
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sortBy(collection, iterator, callback) {
  callback = callback || noop;
  var size, result;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    result = Array(size);
    arrayEach(collection, iterator, createCallback);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    result = Array(size);
    symbolEach(collection, iterator, createCallback);
  } else if (typeof collection === obj) {
    var keys = nativeKeys(collection);
    size = keys.length;
    result = Array(size);
    baseEach(collection, iterator, createCallback, keys);
  }
  if (!size) {
    callback(null, []);
  }

  function createCallback(value) {
    var called = false;
    return function done(err, criteria) {
      if (called) {
        throwError();
      }
      called = true;
      result[completed] = {
        value: value,
        criteria: criteria
      };
      if (err) {
        callback = once(callback);
        callback(err);
      } else if (++completed === size) {
        result.sort(sortIterator);
        callback(null, pluck(result, &#x27;value&#x27;));
      }
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">sortBy</span>(array, iterator, function(err, res) {
*   console.log(res); // [1, 2, 3];
*   console.log(order); // [1, 2, 3]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.sortByLimit" id="apidoc.element.neo-async.sortByLimit">
        function <span class="apidocSignatureSpan">neo-async.</span>sortByLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sortByLimit(collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, value, keys, iter, item, result, iterate;
  var sync = false;
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null, []);
  }
  result = Array(size);
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    if (started &#x3c; size) {
      value = collection[started++];
      iterator(value, createCallback(value));
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, index, createCallback(value));
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, createCallback(value));
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, started++, createCallback(value));
    }
  }

  function objectIterator() {
    if (started &#x3c; size) {
      value = collection[keys[started++]];
      iterator(value, createCallback(value));
    }
  }

  function objectIteratorWithKey() {
    if (started &#x3c; size) {
      key = keys[started++];
      value = collection[key];
      iterator(value, key, createCallback(value));
    }
  }

  function createCallback(value) {
    var called = false;
    return function(err, criteria) {
      if (called) {
        throwError();
      }
      called = true;
      result[completed] = {
        value: value,
        criteria: criteria
      };
      if (err) {
        iterate = noop;
        callback(err);
        callback = noop;
      } else if (++completed === size) {
        result.sort(sortIterator);
        callback(null, pluck(result, &#x27;value&#x27;));
      } else if (sync) {
        nextTick(iterate);
      } else {
        sync = true;
        iterate();
      }
      sync = false;
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 5, 3, 4, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">sortByLimit</span>(array, 2, iterator, function(err, res) {
*   console.log(res); // [1, 2, 3, 4, 5]
*   console.log(order); // [1, 3, 5, 2, 4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.sortBySeries" id="apidoc.element.neo-async.sortBySeries">
        function <span class="apidocSignatureSpan">neo-async.</span>sortBySeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sortBySeries(collection, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, value, keys, iter, result, iterate;
  var sync = false;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null, []);
  }
  result = Array(size);
  iterate();

  function arrayIterator() {
    value = collection[completed];
    iterator(value, done);
  }

  function arrayIteratorWithIndex() {
    value = collection[completed];
    iterator(value, completed, done);
  }

  function symbolIterator() {
    value = iter.next().value;
    iterator(value, done);
  }

  function symbolIteratorWithKey() {
    value = iter.next().value;
    iterator(value, completed, done);
  }

  function objectIterator() {
    value = collection[keys[completed]];
    iterator(value, done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    value = collection[key];
    iterator(value, key, done);
  }

  function done(err, criteria) {
    result[completed] = {
      value: value,
      criteria: criteria
    };
    if (err) {
      callback(err);
    } else if (++completed === size) {
      iterate = throwError;
      result.sort(sortIterator);
      callback(null, pluck(result, &#x27;value&#x27;));
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">sortBySeries</span>(array, iterator, function(err, res) {
*   console.log(res); // [1, 2, 3];
*   console.log(order); // [1, 3, 2]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.timeout" id="apidoc.element.neo-async.timeout">
        function <span class="apidocSignatureSpan">neo-async.</span>timeout
        <span class="apidocSignatureSpan">(func, millisec, info)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function timeout(func, millisec, info) {
  var callback, timer;
  return wrappedFunc;

  function wrappedFunc() {
    timer = setTimeout(timeoutCallback, millisec);
    var args = createArray(arguments);
    var lastIndex = args.length - 1;
    callback = args[lastIndex];
    args[lastIndex] = injectedCallback;
    simpleApply(func, args);
  }

  function timeoutCallback() {
    var name = func.name || &#x27;anonymous&#x27;;
    var err = new Error(&#x27;Callback function &#x22;&#x27; + name + &#x27;&#x22; timed out.&#x27;);
    err.code = &#x27;ETIMEDOUT&#x27;;
    if (info) {
      err.info = info;
    }
    timer = null;
    callback(err);
  }

  function injectedCallback() {
    if (timer !== null) {
      simpleApply(callback, createArray(arguments));
      clearTimeout(timer);
    }
  }

  function simpleApply(func, args) {
    switch(args.length) {
      case 0:
        func();
        break;
      case 1:
        func(args[0]);
        break;
      case 2:
        func(args[0], args[1]);
        break;
      default:
        func.apply(null, args);
        break;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.times" id="apidoc.element.neo-async.times">
        function <span class="apidocSignatureSpan">neo-async.</span>times
        <span class="apidocSignatureSpan">(n, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function times(n, iterator, callback) {
  callback = callback || noop;
  n = +n;
  if (isNaN(n) || n &#x3c; 1) {
    return callback(null, []);
  }
  var result = Array(n);
  timesSync(n, iterate);

  function iterate(num) {
    iterator(num, createCallback(num));
  }

  function createCallback(index) {
    return function(err, res) {
      if (index === null) {
        throwError();
      }
      result[index] = res;
      index = null;
      if (err) {
        callback(err);
        callback = noop;
      } else if (--n === 0) {
        callback(null, result);
      }
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Function} iterator
 * @param {Function} callback
 * @example
 *
 * var iterator = function(n, done) {
 *   done(null, n);
 * };
 * async.<span class="apidocCodeKeywordSpan">times</span>(4, iterator, function(err, res) {
 *   console.log(res); // [0, 1, 2, 3];
 * });
 *
 */
function times(n, iterator, callback) {
  callback = callback || noop;
  n = +n;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.timesLimit" id="apidoc.element.neo-async.timesLimit">
        function <span class="apidocSignatureSpan">neo-async.</span>timesLimit
        <span class="apidocSignatureSpan">(n, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function timesLimit(n, limit, iterator, callback) {
  callback = callback || noop;
  n = +n;
  if (isNaN(n) || n &#x3c; 1 || isNaN(limit) || limit &#x3c; 1) {
    return callback(null, []);
  }
  var result = Array(n);
  var sync = false;
  var started = 0;
  var completed = 0;
  timesSync(limit &#x3e; n ? n : limit, iterate);

  function iterate() {
    var index = started++;
    if (index &#x3c; n) {
      iterator(index, createCallback(index));
    }
  }

  function createCallback(index) {
    return function(err, res) {
      if (index === null) {
        throwError();
      }
      result[index] = res;
      index = null;
      if (err) {
        callback(err);
        callback = noop;
      } else if (++completed &#x3e;= n) {
        callback(null, result);
        callback = throwError;
      } else if (sync) {
        nextTick(iterate);
      } else {
        sync = true;
        iterate();
      }
      sync = false;
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Function} iterator
 * @param {Function} callback
 * @example
 *
 * var iterator = function(n, done) {
 *   done(null, n);
 * };
 * async.<span class="apidocCodeKeywordSpan">timesLimit</span>(4, 2, iterator, function(err, res) {
 *   console.log(res); // [0, 1, 2, 3];
 * });
 *
 */
function timesLimit(n, limit, iterator, callback) {
  callback = callback || noop;
  n = +n;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.timesSeries" id="apidoc.element.neo-async.timesSeries">
        function <span class="apidocSignatureSpan">neo-async.</span>timesSeries
        <span class="apidocSignatureSpan">(n, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function timesSeries(n, iterator, callback) {
  callback = callback || noop;
  n = +n;
  if (isNaN(n) || n &#x3c; 1) {
    return callback(null, []);
  }
  var result = Array(n);
  var sync = false;
  var completed = 0;
  iterate();

  function iterate() {
    iterator(completed, done);
  }

  function done(err, res) {
    result[completed] = res;
    if (err) {
      callback(err);
      callback = throwError;
    } else if (++completed &#x3e;= n) {
      callback(null, result);
      callback = throwError;
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Function} iterator
 * @param {Function} callback
 * @example
 *
 * var iterator = function(n, done) {
 *   done(null, n);
 * };
 * async.<span class="apidocCodeKeywordSpan">timesSeries</span>(4, iterator, function(err, res) {
 *   console.log(res); // [0, 1, 2, 3];
 * });
 *
 */
function timesSeries(n, iterator, callback) {
  callback = callback || noop;
  n = +n;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.transform" id="apidoc.element.neo-async.transform">
        function <span class="apidocSignatureSpan">neo-async.</span>transform
        <span class="apidocSignatureSpan">(collection, accumulator, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function transform(collection, accumulator, iterator, callback) {
  if (arguments.length === 3) {
    callback = iterator;
    iterator = accumulator;
    accumulator = undefined;
  }
  callback = callback || noop;
  var size, keys, result;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    result = accumulator !== undefined ? accumulator : [];
    arrayEach(collection, result, iterator, done);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    result = accumulator !== undefined ? accumulator : {};
    symbolEach(collection, result, iterator, done);
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    result = accumulator !== undefined ? accumulator : {};
    baseEach(collection, result, iterator, done, keys);
  }
  if (!size) {
    callback(null, accumulator !== undefined ? accumulator : result || {});
  }

  function done(err, bool) {
    if (err) {
      callback = once(callback);
      callback(err, isArray(result) ? createArray(result) : objectClone(result));
    } else if (++completed === size) {
      callback(null, result);
    } else if (bool === false) {
      callback = once(callback);
      callback(null, isArray(result) ? createArray(result) : objectClone(result));
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var iterator = function(result, num, done) {
*   setTimeout(function() {
*     order.push(num);
*     result.push(num)
*     done();
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">transform</span>(collection, iterator, function(err, res) {
*   console.log(res); // [1, 2, 3, 4]
*   console.log(order); // [1, 2, 3, 4]
* });
*
* @example
*
* // array with index and accumulator
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.transformLimit" id="apidoc.element.neo-async.transformLimit">
        function <span class="apidocSignatureSpan">neo-async.</span>transformLimit
        <span class="apidocSignatureSpan">(collection, limit, accumulator, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function transformLimit(collection, limit, accumulator, iterator, callback) {
  if (arguments.length === 4) {
    callback = iterator;
    iterator = accumulator;
    accumulator = undefined;
  }
  callback = callback || noop;
  var size, index, key, keys, iter, item, iterate, result;
  var sync = false;
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    result = accumulator !== undefined ? accumulator : [];
    iterate = iterator.length === 4 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    result = accumulator !== undefined ? accumulator : {};
    iterate = iterator.length === 4 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    result = accumulator !== undefined ? accumulator : {};
    iterate = iterator.length === 4 ? objectIteratorWithKey : objectIterator;
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null, accumulator !== undefined ? accumulator : result || {});
  }
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    index = started++;
    if (index &#x3c; size) {
      iterator(result, collection[index], onlyOnce(done));
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      iterator(result, collection[index], index, onlyOnce(done));
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      iterator(result, item.value, onlyOnce(done));
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      iterator(result, item.value, started++, onlyOnce(done));
    }
  }

  function objectIterator() {
    index = started++;
    if (index &#x3c; size) {
      iterator(result, collection[keys[index]], onlyOnce(done));
    }
  }

  function objectIteratorWithKey() {
    index = started++;
    if (index &#x3c; size) {
      key = keys[index];
      iterator(result, collection[key], key, onlyOnce(done));
    }
  }

  function done(err, bool) {
    if (err) {
      iterate = noop;
      callback(err, isArray(result) ? createArray(result) : objectClone(result));
      callback = noop;
    } else if (++completed === size) {
      callback(null, result);
    } else if (bool === false) {
      iterate = noop;
      callback(null, isArray(result) ? createArray(result) : objectClone(result));
      callback = noop;
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var iterator = function(result, num, done) {
*   setTimeout(function() {
*     order.push(num);
*     result.push(num);
*     done();
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">transformLimit</span>(array, 2, iterator, function(err, res) {
*   console.log(res); // [1, 3, 5, 2, 4]
*   console.log(order); // [1, 3, 5, 2, 4]
* });
*
* @example
*
* // array with index and accumulator
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.transformSeries" id="apidoc.element.neo-async.transformSeries">
        function <span class="apidocSignatureSpan">neo-async.</span>transformSeries
        <span class="apidocSignatureSpan">(collection, accumulator, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function transformSeries(collection, accumulator, iterator, callback) {
  if (arguments.length === 3) {
    callback = iterator;
    iterator = accumulator;
    accumulator = undefined;
  }
  callback = onlyOnce(callback || noop);
  var size, key, keys, iter, iterate, result;
  var sync = false;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    result = accumulator !== undefined ? accumulator : [];
    iterate = iterator.length === 4 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    result = accumulator !== undefined ? accumulator : {};
    iterate = iterator.length === 4 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    result = accumulator !== undefined ? accumulator : {};
    iterate = iterator.length === 4 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null, accumulator !== undefined ? accumulator : result || {});
  }
  iterate();

  function arrayIterator() {
    iterator(result, collection[completed], done);
  }

  function arrayIteratorWithIndex() {
    iterator(result, collection[completed], completed, done);
  }

  function symbolIterator() {
    iterator(result, iter.next().value, done);
  }

  function symbolIteratorWithKey() {
    iterator(result, iter.next().value, completed, done);
  }

  function objectIterator() {
    iterator(result, collection[keys[completed]], done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    iterator(result, collection[key], key, done);
  }

  function done(err, bool) {
    if (err) {
      callback(err, result);
    } else if (++completed === size) {
      iterate = throwError;
      callback(null, result);
    } else if (bool === false) {
      iterate = throwError;
      callback(null, result);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var iterator = function(result, num, done) {
*   setTimeout(function() {
*     order.push(num);
*     result.push(num)
*     done();
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">transformSeries</span>(collection, iterator, function(err, res) {
*   console.log(res); // [1, 3, 2, 4]
*   console.log(order); // [1, 3, 2, 4]
* });
*
* @example
*
* // array with index and accumulator
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.unmemoize" id="apidoc.element.neo-async.unmemoize">
        function <span class="apidocSignatureSpan">neo-async.</span>unmemoize
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unmemoize(fn) {
  return function() {
    return (fn.unmemoized || fn).apply(null, arguments);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.until" id="apidoc.element.neo-async.until">
        function <span class="apidocSignatureSpan">neo-async.</span>until
        <span class="apidocSignatureSpan">(test, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function until(test, iterator, callback) {
  callback = callback || noop;
  var sync = false;
  if (!test()) {
    iterate();
  } else {
    callback(null);
  }

  function iterate() {
    if (sync) {
      nextTick(next);
    } else {
      sync = true;
      iterator(done);
    }
    sync = false;
  }

  function next() {
    iterator(done);
  }

  function done(err, arg) {
    if (err) {
      return callback(err);
    }
    if (arguments.length &#x3c;= 2) {
      if (!test(arg)) {
        iterate();
      } else {
        callback(null, arg);
      }
      return;
    }
    arg = slice(arguments, 1);
    if (!test.apply(null, arg)) {
      iterate();
    } else {
      callback.apply(null, [null].concat(arg));
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.waterfall" id="apidoc.element.neo-async.waterfall">
        function <span class="apidocSignatureSpan">neo-async.</span>waterfall
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function waterfall(tasks, callback) {
  callback = callback || noop;
  if (!checkWaterfallTasks(tasks, callback)) {
    return;
  }
  var done, called, sync;
  var completed = 0;
  var size = tasks.length;
  var func = tasks[completed];
  var args = [];
  iterate();

  function iterate() {
    called = false;
    switch (args.length) {
      case 0:
      case 1:
        return func(next);
      case 2:
        return func(args[1], next);
      case 3:
        return func(args[1], args[2], next);
      case 4:
        return func(args[1], args[2], args[3], next);
      case 5:
        return func(args[1], args[2], args[3], args[4], next);
      case 6:
        return func(args[1], args[2], args[3], args[4], args[5], next);
      default:
        args = slice(args, 1);
        args.push(next);
        return func.apply(null, args);
    }
  }

  function next(err, res) {
    if (called) {
      throwError();
    }
    called = true;
    if (err) {
      done = callback;
      callback = throwError;
      done(err);
      return;
    }
    if (++completed === size) {
      done = callback;
      callback = throwError;
      if (arguments.length &#x3c;= 2) {
        done(err, res);
      } else {
        done.apply(null, createArray(arguments));
      }
      return;
    }
    args = arguments;
    func = tasks[completed] || throwError;
    if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *   function(arg1, next) {
 *     setTimeout(function() {
 *       order.push(4);
 *       next(null, 1, 2, 3, 4);
 *     }, 40);
 *   }
 * ];
 * async.<span class="apidocCodeKeywordSpan">waterfall</span>(tasks, function(err, arg1, arg2, arg3, arg4) {
 *   console.log(arg1, arg2, arg3, arg4); // 1 2 3 4
 * });
 *
 */
function waterfall(tasks, callback) {
  callback = callback || noop;
  if (!checkWaterfallTasks(tasks, callback)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.whilst" id="apidoc.element.neo-async.whilst">
        function <span class="apidocSignatureSpan">neo-async.</span>whilst
        <span class="apidocSignatureSpan">(test, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function whilst(test, iterator, callback) {
  callback = callback || noop;
  var sync = false;
  if (test()) {
    iterate();
  } else {
    callback(null);
  }

  function iterate() {
    if (sync) {
      nextTick(next);
    } else {
      sync = true;
      iterator(done);
    }
    sync = false;
  }

  function next() {
    iterator(done);
  }

  function done(err, arg) {
    if (err) {
      return callback(err);
    }
    if (arguments.length &#x3c;= 2) {
      if (test(arg)) {
        iterate();
      } else {
        callback(null, arg);
      }
      return;
    }
    arg = slice(arguments, 1);
    if (test.apply(null, arg)) {
      iterate();
    } else {
      callback.apply(null, [null].concat(arg));
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.wrapSync" id="apidoc.element.neo-async.wrapSync">
        function <span class="apidocSignatureSpan">neo-async.</span>wrapSync
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asyncify(fn) {
  return function( /* args..., callback */ ) {
    var args = createArray(arguments);
    var callback = args.pop();
    var result;
    try {
      result = fn.apply(this, args);
    } catch (e) {
      return callback(e);
    }
    if (result &#x26;&#x26; typeof result === obj &#x26;&#x26; typeof result.then === func) {
      result.then(function(value) {
        callback(null, value);
      }, function(err) {
        callback(err.message ? err : new Error(err));
      });
    } else {
      callback(null, result);
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.neo-async.async" id="apidoc.module.neo-async.async">module neo-async.async</a></h1>


    <h2>
        <a href="#apidoc.element.neo-async.async.all" id="apidoc.element.neo-async.async.all">
        function <span class="apidocSignatureSpan">neo-async.async.</span>all
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function every(collection, iterator, callback) {
  callback = callback || noop;
  deny(collection, iterator, done);

  function done(err, res) {
    if (err) {
      return callback(err);
    }
    callback(null, !res);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.allLimit" id="apidoc.element.neo-async.async.allLimit">
        function <span class="apidocSignatureSpan">neo-async.async.</span>allLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function everyLimit(collection, limit, iterator, callback) {
  callback = callback || noop;
  denyLimit(collection, limit, iterator, done);

  function done(err, res) {
    if (err) {
      return callback(err);
    }
    callback(null, !res);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.allSeries" id="apidoc.element.neo-async.async.allSeries">
        function <span class="apidocSignatureSpan">neo-async.async.</span>allSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function everySeries(collection, iterator, callback) {
  callback = callback || noop;
  denySeries(collection, iterator, done);

  function done(err, res) {
    if (err) {
      return callback(err);
    }
    callback(null, !res);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.angelFall" id="apidoc.element.neo-async.async.angelFall">
        function <span class="apidocSignatureSpan">neo-async.async.</span>angelFall
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function angelFall(tasks, callback) {
  callback = callback || noop;
  if (!checkWaterfallTasks(tasks, callback)) {
    return;
  }
  var completed = 0;
  var sync = false;
  var size = tasks.length;
  var func = tasks[completed];
  var args = [];
  var iterate = function() {
    switch (func.length) {
      case 0:
        try {
          next(null, func());
        } catch (e) {
          next(e);
        }
        return;
      case 1:
        return func(next);
      case 2:
        return func(args[1], next);
      case 3:
        return func(args[1], args[2], next);
      case 4:
        return func(args[1], args[2], args[3], next);
      case 5:
        return func(args[1], args[2], args[3], args[4], next);
      default:
        args = slice(args, 1);
        args[func.length - 1] = next;
        return func.apply(null, args);
    }
  };
  iterate();

  function next(err, res) {
    if (err) {
      iterate = throwError;
      callback = onlyOnce(callback);
      callback(err);
      return;
    }
    if (++completed === size) {
      iterate = throwError;
      var done = callback;
      callback = throwError;
      if (arguments.length === 2) {
        done(err, res);
      } else {
        done.apply(null, createArray(arguments));
      }
      return;
    }
    func = tasks[completed];
    args = arguments;
    if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *   function(arg1, empty1, empty2, empty3, next) {
 *     setTimeout(function() {
 *       order.push(4);
 *       next(null, 1, 2, 3, 4);
 *     }, 40);
 *   }
 * ];
 * async.<span class="apidocCodeKeywordSpan">angelFall</span>(tasks, function(err, arg1, arg2, arg3, arg4) {
 *   console.log(arg1, arg2, arg3, arg4); // 1 2 3 4
 * });
 *
 */
function angelFall(tasks, callback) {
  callback = callback || noop;
  if (!checkWaterfallTasks(tasks, callback)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.angelfall" id="apidoc.element.neo-async.async.angelfall">
        function <span class="apidocSignatureSpan">neo-async.async.</span>angelfall
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function angelFall(tasks, callback) {
  callback = callback || noop;
  if (!checkWaterfallTasks(tasks, callback)) {
    return;
  }
  var completed = 0;
  var sync = false;
  var size = tasks.length;
  var func = tasks[completed];
  var args = [];
  var iterate = function() {
    switch (func.length) {
      case 0:
        try {
          next(null, func());
        } catch (e) {
          next(e);
        }
        return;
      case 1:
        return func(next);
      case 2:
        return func(args[1], next);
      case 3:
        return func(args[1], args[2], next);
      case 4:
        return func(args[1], args[2], args[3], next);
      case 5:
        return func(args[1], args[2], args[3], args[4], next);
      default:
        args = slice(args, 1);
        args[func.length - 1] = next;
        return func.apply(null, args);
    }
  };
  iterate();

  function next(err, res) {
    if (err) {
      iterate = throwError;
      callback = onlyOnce(callback);
      callback(err);
      return;
    }
    if (++completed === size) {
      iterate = throwError;
      var done = callback;
      callback = throwError;
      if (arguments.length === 2) {
        done(err, res);
      } else {
        done.apply(null, createArray(arguments));
      }
      return;
    }
    func = tasks[completed];
    args = arguments;
    if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.any" id="apidoc.element.neo-async.async.any">
        function <span class="apidocSignatureSpan">neo-async.async.</span>any
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function some(collection, iterator, callback) {
  callback = callback || noop;
  detect(collection, iterator, done);

  function done(err, res) {
    if (err) {
      return callback(err);
    }
    callback(null, !!res);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.anyLimit" id="apidoc.element.neo-async.async.anyLimit">
        function <span class="apidocSignatureSpan">neo-async.async.</span>anyLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function someLimit(collection, limit, iterator, callback) {
  callback = callback || noop;
  detectLimit(collection, limit, iterator, done);

  function done(err, res) {
    if (err) {
      return callback(err);
    }
    callback(null, !!res);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.anySeries" id="apidoc.element.neo-async.async.anySeries">
        function <span class="apidocSignatureSpan">neo-async.async.</span>anySeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function someSeries(collection, iterator, callback) {
  callback = callback || noop;
  detectSeries(collection, iterator, done);

  function done(err, res) {
    if (err) {
      return callback(err);
    }
    callback(null, !!res);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.apply" id="apidoc.element.neo-async.async.apply">
        function <span class="apidocSignatureSpan">neo-async.async.</span>apply
        <span class="apidocSignatureSpan">(func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function apply(func) {
  switch (arguments.length) {
    case 0:
    case 1:
      return func;
    case 2:
      return func.bind(null, arguments[1]);
    case 3:
      return func.bind(null, arguments[1], arguments[2]);
    case 4:
      return func.bind(null, arguments[1], arguments[2], arguments[3]);
    case 5:
      return func.bind(null, arguments[1], arguments[2], arguments[3], arguments[4]);
    default:
      var size = arguments.length;
      var index = 0;
      var args = Array(size);
      args[index] = null;
      while (++index &#x3c; size) {
        args[index] = arguments[index];
      }
      return func.bind.apply(func, args);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * @private
 */
function createImmediate(safeMode) {
  var delay = function delay(fn) {
    var args = slice(arguments, 1);
    setTimeout(function() {
      fn.<span class="apidocCodeKeywordSpan">apply</span>(null, args);
    });
  };
  asyncSetImmediate = typeof setImmediate === func ? setImmediate : delay;
  if (typeof process === obj &#x26;&#x26; typeof process.nextTick === func) {
    nextTick = /^v0.10/.test(process.version) ? asyncSetImmediate : process.nextTick;
    asyncNextTick = /^v0/.test(process.version) ? asyncSetImmediate : process.nextTick;
  } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.applyEach" id="apidoc.element.neo-async.async.applyEach">
        function <span class="apidocSignatureSpan">neo-async.async.</span>applyEach
        <span class="apidocSignatureSpan">(fns)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function applyEach(fns) {

  var go = function() {
    var self = this;
    var args = createArray(arguments);
    var callback = args.pop() || noop;
    return func(fns, iterator, callback);

    function iterator(fn, done) {
      fn.apply(self, args.concat([done]));
    }
  };
  if (arguments.length &#x3e; 1) {
    var args = slice(arguments, 1);
    return go.apply(this, args);
  } else {
    return go;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.applyEachSeries" id="apidoc.element.neo-async.async.applyEachSeries">
        function <span class="apidocSignatureSpan">neo-async.async.</span>applyEachSeries
        <span class="apidocSignatureSpan">(fns)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function applyEach(fns) {

  var go = function() {
    var self = this;
    var args = createArray(arguments);
    var callback = args.pop() || noop;
    return func(fns, iterator, callback);

    function iterator(fn, done) {
      fn.apply(self, args.concat([done]));
    }
  };
  if (arguments.length &#x3e; 1) {
    var args = slice(arguments, 1);
    return go.apply(this, args);
  } else {
    return go;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.asyncify" id="apidoc.element.neo-async.async.asyncify">
        function <span class="apidocSignatureSpan">neo-async.async.</span>asyncify
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asyncify(fn) {
  return function( /* args..., callback */ ) {
    var args = createArray(arguments);
    var callback = args.pop();
    var result;
    try {
      result = fn.apply(this, args);
    } catch (e) {
      return callback(e);
    }
    if (result &#x26;&#x26; typeof result === obj &#x26;&#x26; typeof result.then === func) {
      result.then(function(value) {
        callback(null, value);
      }, function(err) {
        callback(err.message ? err : new Error(err));
      });
    } else {
      callback(null, result);
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.auto" id="apidoc.element.neo-async.async.auto">
        function <span class="apidocSignatureSpan">neo-async.async.</span>auto
        <span class="apidocSignatureSpan">(tasks, concurrency, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function auto(tasks, concurrency, callback) {
  if (typeof concurrency === func) {
    callback = concurrency;
    concurrency = null;
  }
  var keys = nativeKeys(tasks);
  var rest = keys.length;
  var results = {};
  if (rest === 0) {
    return callback(null, results);
  }
  var runningTasks = 0;
  var readyTasks = [];
  var listeners = {};
  callback = onlyOnce(callback || noop);
  concurrency = concurrency || rest;

  baseEachSync(tasks, iterator, keys);
  proceedQueue();

  function iterator(task, key) {
    // no dependencies
    var _task, _taskSize;
    if (!isArray(task)) {
      _task = task;
      _taskSize = 0;
      readyTasks.push([_task, _taskSize, done]);
      return;
    }
    var dependencySize = task.length - 1;
    _task = task[dependencySize];
    _taskSize = dependencySize;
    if (dependencySize === 0) {
      readyTasks.push([_task, _taskSize, done]);
      return;
    }
    // dependencies
    var index = -1;
    while (++index &#x3c; dependencySize) {
      var dependencyName = task[index];
      if (notInclude(keys, dependencyName)) {
        var msg = &#x27;async.auto task `&#x27; + dependencyName + &#x27;` has non-existent dependency in &#x27; + task.join(&#x27;, &#x27;);
        throw new Error(msg);
      }
      var taskListeners = listeners[dependencyName];
      if (!taskListeners) {
        taskListeners = listeners[dependencyName] = [];
      }
      taskListeners.push(taskListener);
    }

    function done(err, arg) {
      if (key === null) {
        throwError();
      }
      runningTasks--;
      rest--;
      arg = arguments.length &#x3c;= 2 ? arg : slice(arguments, 1);
      if (err) {
        var safeResults = objectClone(results);
        safeResults[key] = arg;
        key = null;
        var _callback = callback;
        callback = noop;
        _callback(err, safeResults);
        return;
      }
      results[key] = arg;
      taskComplete(key);
      key = null;
    }

    function taskListener() {
      if (--dependencySize === 0) {
        readyTasks.push([_task, _taskSize, done]);
      }
    }
  }

  function proceedQueue() {
    if (readyTasks.length === 0 &#x26;&#x26; runningTasks === 0) {
      if (rest !== 0) {
        throw new Error(&#x27;async.auto task has cyclic dependencies&#x27;);
      }
      return callback(null, results);
    }
    while (readyTasks.length &#x26;&#x26; runningTasks &#x3c; concurrency &#x26;&#x26; callback !== noop) {
      runningTasks++;
      var array = readyTasks.shift();
      if (array[1] === 0) {
        array[0](array[2]);
      } else {
        array[0](results, array[2]);
      }
    }
  }

  function taskComplete(key) {
    var taskListeners = listeners[key] || [];
    arrayEachSync(taskListeners, function(task) {
      task();
    });
    proceedQueue();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.autoInject" id="apidoc.element.neo-async.async.autoInject">
        function <span class="apidocSignatureSpan">neo-async.async.</span>autoInject
        <span class="apidocSignatureSpan">(tasks, concurrency, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function autoInject(tasks, concurrency, callback) {
  var newTasks = {};
  baseEachSync(tasks, iterator, nativeKeys(tasks));
  auto(newTasks, concurrency, callback);

  function iterator(task, key) {
    var params;
    var taskLength = task.length;

    if (isArray(task)) {
      if (taskLength === 0) {
        throw new Error(&#x27;autoInject task functions require explicit parameters.&#x27;);
      }
      params = createArray(task);
      taskLength = params.length - 1;
      task = params[taskLength];
      if (taskLength === 0) {
        newTasks[key] = task;
        return;
      }
    } else if (taskLength === 1) {
      newTasks[key] = task;
      return;
    } else {
      params = parseParams(task);
      if (taskLength === 0 &#x26;&#x26; params.length === 0) {
        throw new Error(&#x27;autoInject task functions require explicit parameters.&#x27;);
      }
      taskLength = params.length - 1;
    }
    params[taskLength] = newTask;
    newTasks[key] = params;

    function newTask(results, done) {
      switch (taskLength) {
        case 1:
          task(results[params[0]], done);
          break;
        case 2:
          task(results[params[0]], results[params[1]], done);
          break;
        case 3:
          task(results[params[0]], results[params[1]], results[params[2]], done);
          break;
        default:
          var i = -1;
          while(++i &#x3c; taskLength) {
            params[i] = results[params[i]];
          }
          params[i] = done;
          task.apply(null, params);
          break;
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.cargo" id="apidoc.element.neo-async.async.cargo">
        function <span class="apidocSignatureSpan">neo-async.async.</span>cargo
        <span class="apidocSignatureSpan">(worker, payload)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cargo(worker, payload) {
  return baseQueue(false, worker, 1, payload);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.compose" id="apidoc.element.neo-async.async.compose">
        function <span class="apidocSignatureSpan">neo-async.async.</span>compose
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compose() {
  return seq.apply(null, reverse(arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.concat" id="apidoc.element.neo-async.async.concat">
        function <span class="apidocSignatureSpan">neo-async.async.</span>concat
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function concat(collection, iterator, callback) {
  callback = callback || noop;
  var size;
  var completed = 0;
  var result = [];

  if (isArray(collection)) {
    size = collection.length;
    arrayEach(collection, iterator, done);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    symbolEach(collection, iterator, done);
  } else if (typeof collection === obj) {
    var keys = nativeKeys(collection);
    size = keys.length;
    baseEach(collection, iterator, done, keys);
  }
  if (!size) {
    callback(null, result);
  }

  function done(err, array) {
    if (array) {
      Array.prototype.push.apply(result, isArray(array) ? array : [array]);
    }
    if (err) {
      callback = once(callback);
      callback(err, createArray(result));
    } else if (++completed === size) {
      callback(null, result);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, [num]);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">concat</span>(array, iterator, function(err, res) {
*   console.log(res); // [1, 2, 3];
*   console.log(order); // [1, 2, 3]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.concatLimit" id="apidoc.element.neo-async.async.concatLimit">
        function <span class="apidocSignatureSpan">neo-async.async.</span>concatLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function concatLimit(collection, limit, iterator, callback) {
  callback = callback || noop;
  var result = [];
  var size, index, key, iter, item, iterate;
  var sync = false;
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    var keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null, result);
  }
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    if (started &#x3c; size) {
      iterator(collection[started++], onlyOnce(done));
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      iterator(collection[index], index, onlyOnce(done));
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      iterator(item.value, onlyOnce(done));
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      iterator(item.value, started++, onlyOnce(done));
    }
  }

  function objectIterator() {
    if (started &#x3c; size) {
      iterator(collection[keys[started++]], onlyOnce(done));
    }
  }

  function objectIteratorWithKey() {
    if (started &#x3c; size) {
      key = keys[started++];
      iterator(collection[key], key, onlyOnce(done));
    }
  }

  function done(err, array) {
    if (array) {
      Array.prototype.push.apply(result, isArray(array) ? array : [array]);
    }
    if (err) {
      iterate = noop;
      callback = once(callback);
      callback(err, result);
    } else if (++completed === size) {
      iterate = throwError;
      callback = onlyOnce(callback);
      callback(null, result);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 5, 3, 4, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, [num]);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">concatLimit</span>(array, 2, iterator, function(err, res) {
*   console.log(res); // [1, 3, 5, 2, 4]
*   console.log(order); // [1, 3, 5, 2, 4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.concatSeries" id="apidoc.element.neo-async.async.concatSeries">
        function <span class="apidocSignatureSpan">neo-async.async.</span>concatSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function concatSeries(collection, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, keys, iter, values, iterate;
  var sync = false;
  var result = [];
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null, result);
  }
  iterate();

  function arrayIterator() {
    iterator(collection[completed], done);
  }

  function arrayIteratorWithIndex() {
    iterator(collection[completed], completed, done);
  }

  function symbolIterator() {
    iterator(iter.next().value, done);
  }

  function symbolIteratorWithKey() {
    values = iter.next().value;
    iterator(values, completed, done);
  }

  function objectIterator() {
    iterator(collection[keys[completed]], done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    iterator(collection[key], key, done);
  }

  function done(err, array) {
    if (array) {
      Array.prototype.push.apply(result, isArray(array) ? array : [array]);
    }
    if (err) {
      callback(err, result);
    } else if (++completed === size) {
      iterate = throwError;
      callback(null, result);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, [num]);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">concatSeries</span>(array, iterator, function(err, res) {
*   console.log(res); // [1, 3, 2];
*   console.log(order); // [1, 3, 2]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.constant" id="apidoc.element.neo-async.async.constant">
        function <span class="apidocSignatureSpan">neo-async.async.</span>constant
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function constant() {
  var args = [null].concat(createArray(arguments));
  return function(callback) {
    callback = arguments[arguments.length - 1];
    callback.apply(this, args);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.createLogger" id="apidoc.element.neo-async.async.createLogger">
        function <span class="apidocSignatureSpan">neo-async.async.</span>createLogger
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createLogger(name) {
  return function(fn) {
    var args = slice(arguments, 1);
    args.push(done);
    fn.apply(null, args);
  };

  function done(err) {
    if (typeof console === obj) {
      if (err) {
        if (console.error) {
          console.error(err);
        }
        return;
      }
      if (console[name]) {
        var args = slice(arguments, 1);
        arrayEachSync(args, function(arg) {
          console[name](arg);
        });
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.detect" id="apidoc.element.neo-async.async.detect">
        function <span class="apidocSignatureSpan">neo-async.async.</span>detect
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (collection, iterator, callback) {
  callback = callback || noop;
  var size, keys;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    arrayEach(collection, iterator, createCallback);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    symbolEach(collection, iterator, createCallback);
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    baseEach(collection, iterator, createCallback, keys);
  }
  if (!size) {
    callback(null);
  }

  function createCallback(value) {
    var called = false;
    return function done(err, res) {
      if (called) {
        throwError();
      }
      called = true;
      if (err) {
        callback = once(callback);
        callback(err);
      } else if (!!res === bool) {
        callback = once(callback);
        callback(null, value);
      } else if (++completed === size) {
        callback(null);
      }
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">detect</span>(array, iterator, function(err, res) {
*   console.log(res); // 1
*   console.log(order); // [1]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.detectLimit" id="apidoc.element.neo-async.async.detectLimit">
        function <span class="apidocSignatureSpan">neo-async.async.</span>detectLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detectLimit = function (collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, value, keys, iter, item, iterate;
  var sync = false;
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null);
  }
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, createCallback(value));
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, index, createCallback(value));
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, createCallback(value));
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, started++, createCallback(value));
    }
  }

  function objectIterator() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[keys[index]];
      iterator(value, createCallback(value));
    }
  }

  function objectIteratorWithKey() {
    if (started &#x3c; size) {
      key = keys[started++];
      value = collection[key];
      iterator(value, key, createCallback(value));
    }
  }

  function createCallback(value) {
    var called = false;
    return function(err, res) {
      if (called) {
        throwError();
      }
      called = true;
      if (err) {
        iterate = noop;
        callback = once(callback);
        callback(err);
      } else if (!!res === bool) {
        iterate = noop;
        callback = once(callback);
        callback(null, value);
      } else if (++completed === size) {
        callback(null);
      } else if (sync) {
        nextTick(iterate);
      } else {
        sync = true;
        iterate();
      }
      sync = false;
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 5, 3, 4, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">detectLimit</span>(array, 2, iterator, function(err, res) {
*   console.log(res); // 1
*   console.log(order); // [1]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.detectSeries" id="apidoc.element.neo-async.async.detectSeries">
        function <span class="apidocSignatureSpan">neo-async.async.</span>detectSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detectSeries = function (collection, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, value, keys, iter, iterate;
  var sync = false;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null);
  }
  iterate();

  function arrayIterator() {
    value = collection[completed];
    iterator(value, done);
  }

  function arrayIteratorWithIndex() {
    value = collection[completed];
    iterator(value, completed, done);
  }

  function symbolIterator() {
    value = iter.next().value;
    iterator(value, done);
  }

  function symbolIteratorWithKey() {
    value = iter.next().value;
    iterator(value, completed, done);
  }

  function objectIterator() {
    value = collection[keys[completed]];
    iterator(value, done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    value = collection[key];
    iterator(value, key, done);
  }

  function done(err, res) {
    if (err) {
      callback(err);
    } else if (!!res === bool) {
      iterate = throwError;
      callback(null, value);
    } else if (++completed === size) {
      iterate = throwError;
      callback(null);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">detectSeries</span>(array, iterator, function(err, res) {
*   console.log(res); // 1
*   console.log(order); // [1]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.dir" id="apidoc.element.neo-async.async.dir">
        function <span class="apidocSignatureSpan">neo-async.async.</span>dir
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dir = function (fn) {
  var args = slice(arguments, 1);
  args.push(done);
  fn.apply(null, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.doDuring" id="apidoc.element.neo-async.async.doDuring">
        function <span class="apidocSignatureSpan">neo-async.async.</span>doDuring
        <span class="apidocSignatureSpan">(iterator, test, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doDuring(iterator, test, callback) {
  callback = callback || noop;
  iterate(null, true);

  function iterate(err, truth) {
    if (err) {
      return callback(err);
    }
    if (truth) {
      iterator(done);
    } else {
      callback(null);
    }
  }

  function done(err, res) {
    if (err) {
      return callback(err);
    }
    switch (arguments.length) {
      case 0:
      case 1:
        test(iterate);
        break;
      case 2:
        test(res, iterate);
        break;
      default:
        var args = slice(arguments, 1);
        args.push(iterate);
        test.apply(null, args);
        break;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.doUntil" id="apidoc.element.neo-async.async.doUntil">
        function <span class="apidocSignatureSpan">neo-async.async.</span>doUntil
        <span class="apidocSignatureSpan">(iterator, test, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doUntil(iterator, test, callback) {
  callback = callback || noop;
  var sync = false;
  next();

  function iterate() {
    if (sync) {
      nextTick(next);
    } else {
      sync = true;
      iterator(done);
    }
    sync = false;
  }

  function next() {
    iterator(done);
  }

  function done(err, arg) {
    if (err) {
      return callback(err);
    }
    if (arguments.length &#x3c;= 2) {
      if (!test(arg)) {
        iterate();
      } else {
        callback(null, arg);
      }
      return;
    }
    arg = slice(arguments, 1);
    if (!test.apply(null, arg)) {
      iterate();
    } else {
      callback.apply(null, [null].concat(arg));
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.doWhilst" id="apidoc.element.neo-async.async.doWhilst">
        function <span class="apidocSignatureSpan">neo-async.async.</span>doWhilst
        <span class="apidocSignatureSpan">(iterator, test, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doWhilst(iterator, test, callback) {
  callback = callback || noop;
  var sync = false;
  next();

  function iterate() {
    if (sync) {
      nextTick(next);
    } else {
      sync = true;
      iterator(done);
    }
    sync = false;
  }

  function next() {
    iterator(done);
  }

  function done(err, arg) {
    if (err) {
      return callback(err);
    }
    if (arguments.length &#x3c;= 2) {
      if (test(arg)) {
        iterate();
      } else {
        callback(null, arg);
      }
      return;
    }
    arg = slice(arguments, 1);
    if (test.apply(null, arg)) {
      iterate();
    } else {
      callback.apply(null, [null].concat(arg));
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.during" id="apidoc.element.neo-async.async.during">
        function <span class="apidocSignatureSpan">neo-async.async.</span>during
        <span class="apidocSignatureSpan">(test, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function during(test, iterator, callback) {
  callback = callback || noop;
  _test();

  function _test() {
    test(iterate);
  }

  function iterate(err, truth) {
    if (err) {
      return callback(err);
    }
    if (truth) {
      iterator(done);
    } else {
      callback(null);
    }
  }

  function done(err) {
    if (err) {
      return callback(err);
    }
    _test();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.each" id="apidoc.element.neo-async.async.each">
        function <span class="apidocSignatureSpan">neo-async.async.</span>each
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function each(collection, iterator, callback) {
  callback = callback || noop;
  var size, keys;
  var completed = 0;
  if (isArray(collection)) {
    size = collection.length;
    arrayEach(collection, iterator, done);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    symbolEach(collection, iterator, done);
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    baseEach(collection, iterator, done, keys);
  }
  if (!size) {
    callback(null);
  }

  function done(err, bool) {
    if (err) {
      callback = once(callback);
      callback(err);
    } else if (++completed === size) {
      callback(null);
    } else if (bool === false) {
      callback = once(callback);
      callback(null);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done();
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">each</span>(array, iterator, function(err, res) {
*   console.log(res); // undefined
*   console.log(order); // [1, 2, 3]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.eachLimit" id="apidoc.element.neo-async.async.eachLimit">
        function <span class="apidocSignatureSpan">neo-async.async.</span>eachLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachLimit(collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, keys, iter, item, iterate;
  var sync = false;
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  } else {
    return callback(null);
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null);
  }
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    if (started &#x3c; size) {
      iterator(collection[started++], done);
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      iterator(collection[index], index, done);
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      iterator(item.value, done);
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      iterator(item.value, started++, done);
    }
  }

  function objectIterator() {
    if (started &#x3c; size) {
      iterator(collection[keys[started++]], done);
    }
  }

  function objectIteratorWithKey() {
    index = started++;
    if (index &#x3c; size) {
      key = keys[index];
      iterator(collection[key], key, done);
    }
  }

  function done(err, bool) {
    if (err) {
      iterate = noop;
      callback = once(callback);
      callback(err);
    } else if (++completed === size) {
      iterate = throwError;
      callback = onlyOnce(callback);
      callback(null);
    } else if (bool === false) {
      iterate = noop;
      callback = once(callback);
      callback(null);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 5, 3, 4, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done();
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">eachLimit</span>(array, 2, iterator, function(err, res) {
*   console.log(res); // undefined
*   console.log(order); // [1, 3, 5, 2, 4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.eachOf" id="apidoc.element.neo-async.async.eachOf">
        function <span class="apidocSignatureSpan">neo-async.async.</span>eachOf
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function each(collection, iterator, callback) {
  callback = callback || noop;
  var size, keys;
  var completed = 0;
  if (isArray(collection)) {
    size = collection.length;
    arrayEach(collection, iterator, done);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    symbolEach(collection, iterator, done);
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    baseEach(collection, iterator, done, keys);
  }
  if (!size) {
    callback(null);
  }

  function done(err, bool) {
    if (err) {
      callback = once(callback);
      callback(err);
    } else if (++completed === size) {
      callback(null);
    } else if (bool === false) {
      callback = once(callback);
      callback(null);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.eachOfLimit" id="apidoc.element.neo-async.async.eachOfLimit">
        function <span class="apidocSignatureSpan">neo-async.async.</span>eachOfLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachLimit(collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, keys, iter, item, iterate;
  var sync = false;
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  } else {
    return callback(null);
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null);
  }
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    if (started &#x3c; size) {
      iterator(collection[started++], done);
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      iterator(collection[index], index, done);
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      iterator(item.value, done);
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      iterator(item.value, started++, done);
    }
  }

  function objectIterator() {
    if (started &#x3c; size) {
      iterator(collection[keys[started++]], done);
    }
  }

  function objectIteratorWithKey() {
    index = started++;
    if (index &#x3c; size) {
      key = keys[index];
      iterator(collection[key], key, done);
    }
  }

  function done(err, bool) {
    if (err) {
      iterate = noop;
      callback = once(callback);
      callback(err);
    } else if (++completed === size) {
      iterate = throwError;
      callback = onlyOnce(callback);
      callback(null);
    } else if (bool === false) {
      iterate = noop;
      callback = once(callback);
      callback(null);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.eachOfSeries" id="apidoc.element.neo-async.async.eachOfSeries">
        function <span class="apidocSignatureSpan">neo-async.async.</span>eachOfSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachSeries(collection, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, keys, iter, value, iterate;
  var sync = false;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null);
  }
  iterate();

  function arrayIterator() {
    iterator(collection[completed], done);
  }

  function arrayIteratorWithIndex() {
    iterator(collection[completed], completed, done);
  }

  function symbolIterator() {
    iterator(iter.next().value, done);
  }

  function symbolIteratorWithKey() {
    value = iter.next().value;
    iterator(value, completed, done);
  }

  function objectIterator() {
    iterator(collection[keys[completed]], done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    iterator(collection[key], key, done);
  }

  function done(err, bool) {
    if (err) {
      callback(err);
    } else if (++completed === size) {
      iterate = throwError;
      callback(null);
    } else if (bool === false) {
      iterate = throwError;
      callback(null);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.eachSeries" id="apidoc.element.neo-async.async.eachSeries">
        function <span class="apidocSignatureSpan">neo-async.async.</span>eachSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachSeries(collection, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, keys, iter, value, iterate;
  var sync = false;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null);
  }
  iterate();

  function arrayIterator() {
    iterator(collection[completed], done);
  }

  function arrayIteratorWithIndex() {
    iterator(collection[completed], completed, done);
  }

  function symbolIterator() {
    iterator(iter.next().value, done);
  }

  function symbolIteratorWithKey() {
    value = iter.next().value;
    iterator(value, completed, done);
  }

  function objectIterator() {
    iterator(collection[keys[completed]], done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    iterator(collection[key], key, done);
  }

  function done(err, bool) {
    if (err) {
      callback(err);
    } else if (++completed === size) {
      iterate = throwError;
      callback(null);
    } else if (bool === false) {
      iterate = throwError;
      callback(null);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done();
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">eachSeries</span>(array, iterator, function(err, res) {
*   console.log(res); // undefined
*   console.log(order); // [1, 3, 2]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.ensureAsync" id="apidoc.element.neo-async.async.ensureAsync">
        function <span class="apidocSignatureSpan">neo-async.async.</span>ensureAsync
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ensureAsync(fn) {
  return function( /* ...args, callback */ ) {
    var args = createArray(arguments);
    var lastIndex = args.length - 1;
    var callback = args[lastIndex];
    var sync = true;
    args[lastIndex] = done;
    fn.apply(this, args);
    sync = false;

    function done() {
      var innerArgs = createArray(arguments);
      if (sync) {
        nextTick(function() {
          callback.apply(null, innerArgs);
        });
      } else {
        callback.apply(null, innerArgs);
      }
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.every" id="apidoc.element.neo-async.async.every">
        function <span class="apidocSignatureSpan">neo-async.async.</span>every
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function every(collection, iterator, callback) {
  callback = callback || noop;
  deny(collection, iterator, done);

  function done(err, res) {
    if (err) {
      return callback(err);
    }
    callback(null, !res);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">every</span>(array, iterator, function(err, res) {
*   console.log(res); // false
*   console.log(order); // [1, 2]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.everyLimit" id="apidoc.element.neo-async.async.everyLimit">
        function <span class="apidocSignatureSpan">neo-async.async.</span>everyLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function everyLimit(collection, limit, iterator, callback) {
  callback = callback || noop;
  denyLimit(collection, limit, iterator, done);

  function done(err, res) {
    if (err) {
      return callback(err);
    }
    callback(null, !res);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 5, 3, 4, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">everyLimit</span>(array, 2, iterator, function(err, res) {
*   console.log(res); // false
*   console.log(order); // [1, 3, 5, 2]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.everySeries" id="apidoc.element.neo-async.async.everySeries">
        function <span class="apidocSignatureSpan">neo-async.async.</span>everySeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function everySeries(collection, iterator, callback) {
  callback = callback || noop;
  denySeries(collection, iterator, done);

  function done(err, res) {
    if (err) {
      return callback(err);
    }
    callback(null, !res);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">everySeries</span>(array, iterator, function(err, res) {
*   console.log(res); // false
*   console.log(order); // [1, 3, 2]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.fast" id="apidoc.element.neo-async.async.fast">
        function <span class="apidocSignatureSpan">neo-async.async.</span>fast
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fast() {
  createImmediate(false);
  return exports;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.filter" id="apidoc.element.neo-async.async.filter">
        function <span class="apidocSignatureSpan">neo-async.async.</span>filter
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filter = function (collection, iterator, callback) {
  callback = callback || noop;
  var size, keys, result;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    result = Array(size);
    arrayEach(collection, iterator, createCallback);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    result = Array(size);
    symbolEach(collection, iterator, createCallback);
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    result = Array(size);
    baseEach(collection, iterator, createCallback, keys);
  }
  if (!size) {
    return callback(null, []);
  }

  function createCallback(index, value) {
    return function done(err, res) {
      if (index === null) {
        throwError();
      }
      if (err) {
        index = null;
        callback = once(callback);
        callback(err);
        return;
      }
      if (!!res === bool) {
        result[index] = value;
      }
      index = null;
      if (++completed === size) {
        callback(null, compact(result));
      }
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">filter</span>(array, iterator, function(err, res) {
*   console.log(res); // [1, 3];
*   console.log(order); // [1, 2, 3]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.filterLimit" id="apidoc.element.neo-async.async.filterLimit">
        function <span class="apidocSignatureSpan">neo-async.async.</span>filterLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filterLimit = function (collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, value, keys, iter, item, iterate, result;
  var sync = false;
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null, []);
  }
  result = Array(size);
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, createCallback(value, index));
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, index, createCallback(value, index));
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, createCallback(value, started++));
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, started, createCallback(value, started++));
    }
  }

  function objectIterator() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[keys[index]];
      iterator(value, createCallback(value, index));
    }
  }

  function objectIteratorWithKey() {
    index = started++;
    if (index &#x3c; size) {
      key = keys[index];
      value = collection[key];
      iterator(value, key, createCallback(value, index));
    }
  }

  function createCallback(value, index) {
    return function(err, res) {
      if (index === null) {
        throwError();
      }
      if (err) {
        index = null;
        iterate = noop;
        callback = once(callback);
        callback(err);
        return;
      }
      if (!!res === bool) {
        result[index] = value;
      }
      index = null;
      if (++completed === size) {
        callback = onlyOnce(callback);
        callback(null, compact(result));
      } else if (sync) {
        nextTick(iterate);
      } else {
        sync = true;
        iterate();
      }
      sync = false;
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 5, 3, 4, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">filterLimit</span>(array, 2, iterator, function(err, res) {
*   console.log(res); // [1, 5, 3]
*   console.log(order); // [1, 3, 5, 2, 4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.filterSeries" id="apidoc.element.neo-async.async.filterSeries">
        function <span class="apidocSignatureSpan">neo-async.async.</span>filterSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filterSeries = function (collection, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, value, keys, iter, iterate;
  var sync = false;
  var completed = 0;
  var result = [];

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null, []);
  }
  iterate();

  function arrayIterator() {
    value = collection[completed];
    iterator(value, done);
  }

  function arrayIteratorWithIndex() {
    value = collection[completed];
    iterator(value, completed, done);
  }

  function symbolIterator() {
    value = iter.next().value;
    iterator(value, done);
  }

  function symbolIteratorWithKey() {
    value = iter.next().value;
    iterator(value, completed, done);
  }

  function objectIterator() {
    key = keys[completed];
    value = collection[key];
    iterator(value, done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    value = collection[key];
    iterator(value, key, done);
  }

  function done(err, res) {
    if (err) {
      callback(err);
      return;
    }
    if (!!res === bool) {
      result[result.length] = value;
    }
    if (++completed === size) {
      iterate = throwError;
      callback(null, result);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">filterSeries</span>(array, iterator, function(err, res) {
*   console.log(res); // [1, 3];
*   console.log(order); // [1, 3, 2]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.find" id="apidoc.element.neo-async.async.find">
        function <span class="apidocSignatureSpan">neo-async.async.</span>find
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">find = function (collection, iterator, callback) {
  callback = callback || noop;
  var size, keys;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    arrayEach(collection, iterator, createCallback);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    symbolEach(collection, iterator, createCallback);
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    baseEach(collection, iterator, createCallback, keys);
  }
  if (!size) {
    callback(null);
  }

  function createCallback(value) {
    var called = false;
    return function done(err, res) {
      if (called) {
        throwError();
      }
      called = true;
      if (err) {
        callback = once(callback);
        callback(err);
      } else if (!!res === bool) {
        callback = once(callback);
        callback(null, value);
      } else if (++completed === size) {
        callback(null);
      }
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.findLimit" id="apidoc.element.neo-async.async.findLimit">
        function <span class="apidocSignatureSpan">neo-async.async.</span>findLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findLimit = function (collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, value, keys, iter, item, iterate;
  var sync = false;
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null);
  }
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, createCallback(value));
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, index, createCallback(value));
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, createCallback(value));
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, started++, createCallback(value));
    }
  }

  function objectIterator() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[keys[index]];
      iterator(value, createCallback(value));
    }
  }

  function objectIteratorWithKey() {
    if (started &#x3c; size) {
      key = keys[started++];
      value = collection[key];
      iterator(value, key, createCallback(value));
    }
  }

  function createCallback(value) {
    var called = false;
    return function(err, res) {
      if (called) {
        throwError();
      }
      called = true;
      if (err) {
        iterate = noop;
        callback = once(callback);
        callback(err);
      } else if (!!res === bool) {
        iterate = noop;
        callback = once(callback);
        callback(null, value);
      } else if (++completed === size) {
        callback(null);
      } else if (sync) {
        nextTick(iterate);
      } else {
        sync = true;
        iterate();
      }
      sync = false;
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.findSeries" id="apidoc.element.neo-async.async.findSeries">
        function <span class="apidocSignatureSpan">neo-async.async.</span>findSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findSeries = function (collection, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, value, keys, iter, iterate;
  var sync = false;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null);
  }
  iterate();

  function arrayIterator() {
    value = collection[completed];
    iterator(value, done);
  }

  function arrayIteratorWithIndex() {
    value = collection[completed];
    iterator(value, completed, done);
  }

  function symbolIterator() {
    value = iter.next().value;
    iterator(value, done);
  }

  function symbolIteratorWithKey() {
    value = iter.next().value;
    iterator(value, completed, done);
  }

  function objectIterator() {
    value = collection[keys[completed]];
    iterator(value, done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    value = collection[key];
    iterator(value, key, done);
  }

  function done(err, res) {
    if (err) {
      callback(err);
    } else if (!!res === bool) {
      iterate = throwError;
      callback(null, value);
    } else if (++completed === size) {
      iterate = throwError;
      callback(null);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.foldl" id="apidoc.element.neo-async.async.foldl">
        function <span class="apidocSignatureSpan">neo-async.async.</span>foldl
        <span class="apidocSignatureSpan">(collection, result, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduce(collection, result, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, keys, iter, iterate;
  var sync = false;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 4 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 4 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 4 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null, result);
  }
  iterate(result);

  function arrayIterator(result) {
    iterator(result, collection[completed], done);
  }

  function arrayIteratorWithIndex(result) {
    iterator(result, collection[completed], completed, done);
  }

  function symbolIterator() {
    iterator(result, iter.next().value, done);
  }

  function symbolIteratorWithKey() {
    iterator(result, iter.next().value, completed, done);
  }

  function objectIterator(result) {
    iterator(result, collection[keys[completed]], done);
  }

  function objectIteratorWithKey(result) {
    key = keys[completed];
    iterator(result, collection[key], key, done);
  }

  function done(err, result) {
    if (err) {
      callback(err, result);
    } else if (++completed === size) {
      iterator = throwError;
      callback(null, result);
    } else if (sync) {
      nextTick(function() {
        iterate(result);
      });
    } else {
      sync = true;
      iterate(result);
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.foldr" id="apidoc.element.neo-async.async.foldr">
        function <span class="apidocSignatureSpan">neo-async.async.</span>foldr
        <span class="apidocSignatureSpan">(collection, result, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduceRight(collection, result, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var resIndex, index, key, keys, iter, item, col, iterate;
  var sync = false;

  if (isArray(collection)) {
    resIndex = collection.length;
    iterate = iterator.length === 4 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    resIndex = collection.size;
    col = Array(resIndex);
    iter = collection[iteratorSymbol]();
    index = -1;
    while ((item = iter.next()).done === false) {
      col[++index] = item.value;
    }
    collection = col;
    iterate = iterator.length === 4 ? arrayIteratorWithIndex : arrayIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    resIndex = keys.length;
    iterate = iterator.length === 4 ? objectIteratorWithKey : objectIterator;
  }
  if (!resIndex) {
    return callback(null, result);
  }
  iterate(result);

  function arrayIterator(result) {
    iterator(result, collection[--resIndex], done);
  }

  function arrayIteratorWithIndex(result) {
    iterator(result, collection[--resIndex], resIndex, done);
  }

  function objectIterator(result) {
    iterator(result, collection[keys[--resIndex]], done);
  }

  function objectIteratorWithKey(result) {
    key = keys[--resIndex];
    iterator(result, collection[key], key, done);
  }

  function done(err, result) {
    if (err) {
      callback(err, result);
    } else if (resIndex === 0) {
      iterate = throwError;
      callback(null, result);
    } else if (sync) {
      nextTick(function() {
        iterate(result);
      });
    } else {
      sync = true;
      iterate(result);
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.forEach" id="apidoc.element.neo-async.async.forEach">
        function <span class="apidocSignatureSpan">neo-async.async.</span>forEach
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function each(collection, iterator, callback) {
  callback = callback || noop;
  var size, keys;
  var completed = 0;
  if (isArray(collection)) {
    size = collection.length;
    arrayEach(collection, iterator, done);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    symbolEach(collection, iterator, done);
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    baseEach(collection, iterator, done, keys);
  }
  if (!size) {
    callback(null);
  }

  function done(err, bool) {
    if (err) {
      callback = once(callback);
      callback(err);
    } else if (++completed === size) {
      callback(null);
    } else if (bool === false) {
      callback = once(callback);
      callback(null);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.forEachLimit" id="apidoc.element.neo-async.async.forEachLimit">
        function <span class="apidocSignatureSpan">neo-async.async.</span>forEachLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachLimit(collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, keys, iter, item, iterate;
  var sync = false;
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  } else {
    return callback(null);
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null);
  }
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    if (started &#x3c; size) {
      iterator(collection[started++], done);
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      iterator(collection[index], index, done);
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      iterator(item.value, done);
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      iterator(item.value, started++, done);
    }
  }

  function objectIterator() {
    if (started &#x3c; size) {
      iterator(collection[keys[started++]], done);
    }
  }

  function objectIteratorWithKey() {
    index = started++;
    if (index &#x3c; size) {
      key = keys[index];
      iterator(collection[key], key, done);
    }
  }

  function done(err, bool) {
    if (err) {
      iterate = noop;
      callback = once(callback);
      callback(err);
    } else if (++completed === size) {
      iterate = throwError;
      callback = onlyOnce(callback);
      callback(null);
    } else if (bool === false) {
      iterate = noop;
      callback = once(callback);
      callback(null);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.forEachOf" id="apidoc.element.neo-async.async.forEachOf">
        function <span class="apidocSignatureSpan">neo-async.async.</span>forEachOf
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function each(collection, iterator, callback) {
  callback = callback || noop;
  var size, keys;
  var completed = 0;
  if (isArray(collection)) {
    size = collection.length;
    arrayEach(collection, iterator, done);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    symbolEach(collection, iterator, done);
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    baseEach(collection, iterator, done, keys);
  }
  if (!size) {
    callback(null);
  }

  function done(err, bool) {
    if (err) {
      callback = once(callback);
      callback(err);
    } else if (++completed === size) {
      callback(null);
    } else if (bool === false) {
      callback = once(callback);
      callback(null);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.forEachOfLimit" id="apidoc.element.neo-async.async.forEachOfLimit">
        function <span class="apidocSignatureSpan">neo-async.async.</span>forEachOfLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachLimit(collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, keys, iter, item, iterate;
  var sync = false;
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  } else {
    return callback(null);
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null);
  }
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    if (started &#x3c; size) {
      iterator(collection[started++], done);
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      iterator(collection[index], index, done);
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      iterator(item.value, done);
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      iterator(item.value, started++, done);
    }
  }

  function objectIterator() {
    if (started &#x3c; size) {
      iterator(collection[keys[started++]], done);
    }
  }

  function objectIteratorWithKey() {
    index = started++;
    if (index &#x3c; size) {
      key = keys[index];
      iterator(collection[key], key, done);
    }
  }

  function done(err, bool) {
    if (err) {
      iterate = noop;
      callback = once(callback);
      callback(err);
    } else if (++completed === size) {
      iterate = throwError;
      callback = onlyOnce(callback);
      callback(null);
    } else if (bool === false) {
      iterate = noop;
      callback = once(callback);
      callback(null);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.forEachOfSeries" id="apidoc.element.neo-async.async.forEachOfSeries">
        function <span class="apidocSignatureSpan">neo-async.async.</span>forEachOfSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachSeries(collection, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, keys, iter, value, iterate;
  var sync = false;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null);
  }
  iterate();

  function arrayIterator() {
    iterator(collection[completed], done);
  }

  function arrayIteratorWithIndex() {
    iterator(collection[completed], completed, done);
  }

  function symbolIterator() {
    iterator(iter.next().value, done);
  }

  function symbolIteratorWithKey() {
    value = iter.next().value;
    iterator(value, completed, done);
  }

  function objectIterator() {
    iterator(collection[keys[completed]], done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    iterator(collection[key], key, done);
  }

  function done(err, bool) {
    if (err) {
      callback(err);
    } else if (++completed === size) {
      iterate = throwError;
      callback(null);
    } else if (bool === false) {
      iterate = throwError;
      callback(null);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.forEachSeries" id="apidoc.element.neo-async.async.forEachSeries">
        function <span class="apidocSignatureSpan">neo-async.async.</span>forEachSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachSeries(collection, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, keys, iter, value, iterate;
  var sync = false;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null);
  }
  iterate();

  function arrayIterator() {
    iterator(collection[completed], done);
  }

  function arrayIteratorWithIndex() {
    iterator(collection[completed], completed, done);
  }

  function symbolIterator() {
    iterator(iter.next().value, done);
  }

  function symbolIteratorWithKey() {
    value = iter.next().value;
    iterator(value, completed, done);
  }

  function objectIterator() {
    iterator(collection[keys[completed]], done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    iterator(collection[key], key, done);
  }

  function done(err, bool) {
    if (err) {
      callback(err);
    } else if (++completed === size) {
      iterate = throwError;
      callback(null);
    } else if (bool === false) {
      iterate = throwError;
      callback(null);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.forever" id="apidoc.element.neo-async.async.forever">
        function <span class="apidocSignatureSpan">neo-async.async.</span>forever
        <span class="apidocSignatureSpan">(iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forever(iterator, callback) {
  var sync = false;
  iterate();

  function iterate() {
    iterator(next);
  }

  function next(err) {
    if (err) {
      if (callback) {
        return callback(err);
      }
      throw err;
    }
    if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.groupBy" id="apidoc.element.neo-async.async.groupBy">
        function <span class="apidocSignatureSpan">neo-async.async.</span>groupBy
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function groupBy(collection, iterator, callback) {
  callback = callback || noop;
  var size;
  var completed = 0;
  var result = {};

  if (isArray(collection)) {
    size = collection.length;
    arrayEach(collection, iterator, createCallback);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    symbolEach(collection, iterator, createCallback);
  } else if (typeof collection === obj) {
    var keys = nativeKeys(collection);
    size = keys.length;
    baseEach(collection, iterator, createCallback, keys);
  }
  if (!size) {
    callback(null, {});
  }

  function createCallback(value) {
    var called = false;
    return function done(err, key) {
      if (called) {
        throwError();
      }
      called = true;
      if (err) {
        callback = once(callback);
        callback(err, objectClone(result));
        return;
      }
      var array = result[key];
      if (!array) {
        array = result[key] = [value];
      } else {
        array.push(value);
      }
      if (++completed === size) {
        callback(null, result);
      }
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [4.2, 6.4, 6.1];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, Math.floor(num));
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">groupBy</span>(array, iterator, function(err, res) {
*   console.log(res); // { &#x27;4&#x27;: [4.2], &#x27;6&#x27;: [6.1, 6.4] }
*   console.log(order); // [4.2, 6.1, 6.4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.groupByLimit" id="apidoc.element.neo-async.async.groupByLimit">
        function <span class="apidocSignatureSpan">neo-async.async.</span>groupByLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function groupByLimit(collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, value, keys, iter, item, iterate;
  var sync = false;
  var started = 0;
  var completed = 0;
  var result = {};

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null, result);
  }
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    if (started &#x3c; size) {
      value = collection[started++];
      iterator(value, createCallback(value));
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, index, createCallback(value));
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, createCallback(value));
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, started++, createCallback(value));
    }
  }

  function objectIterator() {
    if (started &#x3c; size) {
      value = collection[keys[started++]];
      iterator(value, createCallback(value));
    }
  }

  function objectIteratorWithKey() {
    if (started &#x3c; size) {
      key = keys[started++];
      value = collection[key];
      iterator(value, key, createCallback(value));
    }
  }

  function createCallback(value) {
    var called = false;
    return function(err, key) {
      if (called) {
        throwError();
      }
      called = true;
      if (err) {
        iterate = noop;
        callback = once(callback);
        callback(err, objectClone(result));
        return;
      }
      var array = result[key];
      if (!array) {
        result[key] = [value];
      } else {
        array.push(value);
      }
      if (++completed === size) {
        callback(null, result);
      } else if (sync) {
        nextTick(iterate);
      } else {
        sync = true;
        iterate();
      }
      sync = false;
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1.1, 5.9, 3.2, 3.9, 2.1];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, Math.floor(num));
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">groupByLimit</span>(array, 2, iterator, function(err, res) {
*   console.log(res); // { &#x27;1&#x27;: [1.1], &#x27;3&#x27;: [3.2, 3.9], &#x27;5&#x27;: [5.9], &#x27;2&#x27;: [2.1] }
*   console.log(order); // [1.1, 3.2, 5.9, 2.1, 3.9]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.groupBySeries" id="apidoc.element.neo-async.async.groupBySeries">
        function <span class="apidocSignatureSpan">neo-async.async.</span>groupBySeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function groupBySeries(collection, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, value, keys, iter, iterate;
  var sync = false;
  var completed = 0;
  var result = {};

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null, result);
  }
  iterate();

  function arrayIterator() {
    value = collection[completed];
    iterator(value, done);
  }

  function arrayIteratorWithIndex() {
    value = collection[completed];
    iterator(value, completed, done);
  }

  function symbolIterator() {
    value = iter.next().value;
    iterator(value, done);
  }

  function symbolIteratorWithKey() {
    value = iter.next().value;
    iterator(value, completed, done);
  }

  function objectIterator() {
    value = collection[keys[completed]];
    iterator(value, done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    value = collection[key];
    iterator(value, key, done);
  }

  function done(err, key) {
    if (err) {
      iterate = throwError;
      callback = onlyOnce(callback);
      callback(err, objectClone(result));
      return;
    }
    var array = result[key];
    if (!array) {
      array = result[key] = [value];
    } else {
      array.push(value);
    }
    if (++completed === size) {
      iterate = throwError;
      callback(null, result);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [4.2, 6.4, 6.1];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, Math.floor(num));
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">groupBySeries</span>(array, iterator, function(err, res) {
*   console.log(res); // { &#x27;4&#x27;: [4.2], &#x27;6&#x27;: [6.4, 6.1] }
*   console.log(order); // [4.2, 6.4, 6.1]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.inject" id="apidoc.element.neo-async.async.inject">
        function <span class="apidocSignatureSpan">neo-async.async.</span>inject
        <span class="apidocSignatureSpan">(collection, result, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduce(collection, result, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, keys, iter, iterate;
  var sync = false;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 4 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 4 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 4 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null, result);
  }
  iterate(result);

  function arrayIterator(result) {
    iterator(result, collection[completed], done);
  }

  function arrayIteratorWithIndex(result) {
    iterator(result, collection[completed], completed, done);
  }

  function symbolIterator() {
    iterator(result, iter.next().value, done);
  }

  function symbolIteratorWithKey() {
    iterator(result, iter.next().value, completed, done);
  }

  function objectIterator(result) {
    iterator(result, collection[keys[completed]], done);
  }

  function objectIteratorWithKey(result) {
    key = keys[completed];
    iterator(result, collection[key], key, done);
  }

  function done(err, result) {
    if (err) {
      callback(err, result);
    } else if (++completed === size) {
      iterator = throwError;
      callback(null, result);
    } else if (sync) {
      nextTick(function() {
        iterate(result);
      });
    } else {
      sync = true;
      iterate(result);
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.iterator" id="apidoc.element.neo-async.async.iterator">
        function <span class="apidocSignatureSpan">neo-async.async.</span>iterator
        <span class="apidocSignatureSpan">(tasks)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function iterator(tasks) {
  var size = 0;
  var keys = [];
  if (isArray(tasks)) {
    size = tasks.length;
  } else {
    keys = nativeKeys(tasks);
    size = keys.length;
  }
  return makeCallback(0);

  function makeCallback(index) {
    var fn = function() {
      if (size) {
        var key = keys[index] || index;
        tasks[key].apply(null, createArray(arguments));
      }
      return fn.next();
    };
    fn.next = function() {
      return (index &#x3c; size - 1) ? makeCallback(index + 1) : null;
    };
    return fn;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.log" id="apidoc.element.neo-async.async.log">
        function <span class="apidocSignatureSpan">neo-async.async.</span>log
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">log = function (fn) {
  var args = slice(arguments, 1);
  args.push(done);
  fn.apply(null, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done();
*   }, num * 10);
* };
* async.each(array, iterator, function(err, res) {
*   console.<span class="apidocCodeKeywordSpan">log</span>(res); // undefined
*   console.log(order); // [1, 2, 3]
* });
*
* @example
*
* // array with index
* var order = [];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.map" id="apidoc.element.neo-async.async.map">
        function <span class="apidocSignatureSpan">neo-async.async.</span>map
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (collection, iterator, callback) {
  callback = callback || noop;
  var size, keys, result;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    result = init(size);
    arrayEach(collection, iterator, createCallback);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    result = init(size);
    symbolEach(collection, iterator, createCallback);
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    result = init(size);
    baseEach(collection, iterator, createCallback, keys);
  }
  if (!size) {
    callback(null, init());
  }

  function createCallback(key) {
    return function done(err, res) {
      if (key === null) {
        throwError();
      }
      if (err) {
        key = null;
        callback = once(callback);
        callback(err, clone(result));
        return;
      }
      result[key] = res;
      key = null;
      if (++completed === size) {
        callback(null, result);
      }
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">map</span>(array, iterator, function(err, res) {
*   console.log(res); // [1, 3, 2];
*   console.log(order); // [1, 2, 3]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.mapLimit" id="apidoc.element.neo-async.async.mapLimit">
        function <span class="apidocSignatureSpan">neo-async.async.</span>mapLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mapLimit(collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, keys, iter, item, result, iterate;
  var sync = false;
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null, []);
  }
  result = Array(size);
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    index = started++;
    if (index &#x3c; size) {
      iterator(collection[index], createCallback(index));
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      iterator(collection[index], index, createCallback(index));
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      iterator(item.value, createCallback(started++));
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      iterator(item.value, started, createCallback(started++));
    }
  }

  function objectIterator() {
    index = started++;
    if (index &#x3c; size) {
      iterator(collection[keys[index]], createCallback(index));
    }
  }

  function objectIteratorWithKey() {
    index = started++;
    if (index &#x3c; size) {
      key = keys[index];
      iterator(collection[key], key, createCallback(index));
    }
  }

  function createCallback(index) {
    return function(err, res) {
      if (index === null) {
        throwError();
      }
      if (err) {
        index = null;
        iterate = noop;
        callback = once(callback);
        callback(err, createArray(result));
        return;
      }
      result[index] = res;
      index = null;
      if (++completed === size) {
        iterate = throwError;
        callback(null, result);
        callback = throwError;
      } else if (sync) {
        nextTick(iterate);
      } else {
        sync = true;
        iterate();
      }
      sync = false;
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 5, 3, 4, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">mapLimit</span>(array, 2, iterator, function(err, res) {
*   console.log(res); // [1, 5, 3, 4, 2]
*   console.log(order); // [1, 3, 5, 2, 4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.mapSeries" id="apidoc.element.neo-async.async.mapSeries">
        function <span class="apidocSignatureSpan">neo-async.async.</span>mapSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mapSeries(collection, iterator, callback) {
  callback = callback || noop;
  var size, key, keys, iter, value, result, iterate;
  var sync = false;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null, []);
  }
  result = Array(size);
  iterate();

  function arrayIterator() {
    iterator(collection[completed], done);
  }

  function arrayIteratorWithIndex() {
    iterator(collection[completed], completed, done);
  }

  function symbolIterator() {
    iterator(iter.next().value, done);
  }

  function symbolIteratorWithKey() {
    value = iter.next().value;
    iterator(value, completed, done);
  }

  function objectIterator() {
    iterator(collection[keys[completed]], done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    iterator(collection[key], key, done);
  }

  function done(err, res) {
    if (err) {
      iterate = throwError;
      callback = onlyOnce(callback);
      callback(err, createArray(result));
      return;
    }
    result[completed] = res;
    if (++completed === size) {
      iterate = throwError;
      callback(null, result);
      callback = throwError;
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">mapSeries</span>(array, iterator, function(err, res) {
*   console.log(res); // [1, 3, 2];
*   console.log(order); // [1, 3, 2]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.mapValues" id="apidoc.element.neo-async.async.mapValues">
        function <span class="apidocSignatureSpan">neo-async.async.</span>mapValues
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapValues = function (collection, iterator, callback) {
  callback = callback || noop;
  var size, keys, result;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    result = init(size);
    arrayEach(collection, iterator, createCallback);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    result = init(size);
    symbolEach(collection, iterator, createCallback);
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    result = init(size);
    baseEach(collection, iterator, createCallback, keys);
  }
  if (!size) {
    callback(null, init());
  }

  function createCallback(key) {
    return function done(err, res) {
      if (key === null) {
        throwError();
      }
      if (err) {
        key = null;
        callback = once(callback);
        callback(err, clone(result));
        return;
      }
      result[key] = res;
      key = null;
      if (++completed === size) {
        callback(null, result);
      }
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">mapValues</span>(array, iterator, function(err, res) {
*   console.log(res); // { &#x27;0&#x27;: 1, &#x27;1&#x27;: 3, &#x27;2&#x27;: 2 }
*   console.log(order); // [1, 2, 3]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.mapValuesLimit" id="apidoc.element.neo-async.async.mapValuesLimit">
        function <span class="apidocSignatureSpan">neo-async.async.</span>mapValuesLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mapValuesLimit(collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, keys, iter, item, iterate;
  var sync = false;
  var result = {};
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null, result);
  }
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    index = started++;
    if (index &#x3c; size) {
      iterator(collection[index], createCallback(index));
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      iterator(collection[index], index, createCallback(index));
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      iterator(item.value, createCallback(started++));
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      iterator(item.value, started, createCallback(started++));
    }
  }

  function objectIterator() {
    index = started++;
    if (index &#x3c; size) {
      key = keys[index];
      iterator(collection[key], createCallback(key));
    }
  }

  function objectIteratorWithKey() {
    index = started++;
    if (index &#x3c; size) {
      key = keys[index];
      iterator(collection[key], key, createCallback(key));
    }
  }

  function createCallback(key) {
    return function(err, res) {
      if (key === null) {
        throwError();
      }
      if (err) {
        key = null;
        iterate = noop;
        callback = once(callback);
        callback(err, objectClone(result));
        return;
      }
      result[key] = res;
      key = null;
      if (++completed === size) {
        callback(null, result);
      } else if (sync) {
        nextTick(iterate);
      } else {
        sync = true;
        iterate();
      }
      sync = false;
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 5, 3, 4, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">mapValuesLimit</span>(array, 2, iterator, function(err, res) {
*   console.log(res); // { &#x27;0&#x27;: 1, &#x27;1&#x27;: 5, &#x27;2&#x27;: 3, &#x27;3&#x27;: 4, &#x27;4&#x27;: 2 }
*   console.log(order); // [1, 3, 5, 2, 4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.mapValuesSeries" id="apidoc.element.neo-async.async.mapValuesSeries">
        function <span class="apidocSignatureSpan">neo-async.async.</span>mapValuesSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mapValuesSeries(collection, iterator, callback) {
  callback = callback || noop;
  var size, key, keys, iter, value, iterate;
  var sync = false;
  var result = {};
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null, result);
  }
  iterate();

  function arrayIterator() {
    key = completed;
    iterator(collection[completed], done);
  }

  function arrayIteratorWithIndex() {
    key = completed;
    iterator(collection[completed], completed, done);
  }

  function symbolIterator() {
    key = completed;
    value = iter.next().value;
    iterator(value, done);
  }

  function symbolIteratorWithKey() {
    key = completed;
    value = iter.next().value;
    iterator(value, completed, done);
  }

  function objectIterator() {
    key = keys[completed];
    iterator(collection[key], done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    iterator(collection[key], key, done);
  }

  function done(err, res) {
    if (err) {
      iterate = throwError;
      callback = onlyOnce(callback);
      callback(err, objectClone(result));
      return;
    }
    result[key] = res;
    if (++completed === size) {
      iterate = throwError;
      callback(null, result);
      callback = throwError;
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">mapValuesSeries</span>(array, iterator, function(err, res) {
*   console.log(res); // { &#x27;0&#x27;: 1, &#x27;1&#x27;: 3, &#x27;2&#x27;: 2 }
*   console.log(order); // [1, 3, 2]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.memoize" id="apidoc.element.neo-async.async.memoize">
        function <span class="apidocSignatureSpan">neo-async.async.</span>memoize
        <span class="apidocSignatureSpan">(fn, hasher)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function memoize(fn, hasher) {
  hasher = hasher || function(hash) {
    return hash;
  };

  var memo = {};
  var queues = {};
  var memoized = function() {
    var args = createArray(arguments);
    var callback = args.pop();
    var key = hasher.apply(null, args);
    if (has(memo, key)) {
      nextTick(function() {
        callback.apply(null, memo[key]);
      });
      return;
    }
    if (has(queues, key)) {
      return queues[key].push(callback);
    }

    queues[key] = [callback];
    args.push(done);
    fn.apply(null, args);

    function done() {
      var args = createArray(arguments);
      memo[key] = args;
      var q = queues[key];
      delete queues[key];

      var i = -1;
      var size = q.length;
      while (++i &#x3c; size) {
        q[i].apply(null, args);
      }
    }
  };
  memoized.memo = memo;
  memoized.unmemoized = fn;
  return memoized;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.nextTick" id="apidoc.element.neo-async.async.nextTick">
        function <span class="apidocSignatureSpan">neo-async.async.</span>nextTick
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nextTick(callback) {
  if (typeof callback !== &#x27;function&#x27;)
    throw new TypeError(&#x27;callback is not a function&#x27;);
  // on the way out, don&#x27;t bother. it won&#x27;t get fired anyway.
  if (process._exiting)
    return;

  var args;
  if (arguments.length &#x3e; 1) {
    args = new Array(arguments.length - 1);
    for (var i = 1; i &#x3c; arguments.length; i++)
      args[i - 1] = arguments[i];
  }

  nextTickQueue.push({
    callback,
    domain: process.domain || null,
    args
  });
  tickInfo[kLength]++;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.omit" id="apidoc.element.neo-async.async.omit">
        function <span class="apidocSignatureSpan">neo-async.async.</span>omit
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">omit = function (collection, iterator, callback) {
  callback = callback || noop;
  var size, keys;
  var completed = 0;
  var result = {};

  if (isArray(collection)) {
    size = collection.length;
    arrayEach(collection, iterator, createCallback);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    symbolEach(collection, iterator, createCallback);
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    baseEach(collection, iterator, createCallback, keys);
  }
  if (!size) {
    return callback(null, {});
  }

  function createCallback(key, value) {
    return function done(err, res) {
      if (key === null) {
        throwError();
      }
      if (err) {
        key = null;
        callback = once(callback);
        callback(err, objectClone(result));
        return;
      }
      if (!!res === bool) {
        result[key] = value;
      }
      key = null;
      if (++completed === size) {
        callback(null, result);
      }
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2, 4];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">omit</span>(array, iterator, function(err, res) {
*   console.log(res); // { &#x27;2&#x27;: 2, &#x27;3&#x27;: 4 }
*   console.log(order); // [1, 2, 3, 4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.omitLimit" id="apidoc.element.neo-async.async.omitLimit">
        function <span class="apidocSignatureSpan">neo-async.async.</span>omitLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">omitLimit = function (collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, value, keys, iter, item, iterate;
  var sync = false;
  var result = {};
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null, {});
  }
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, createCallback(value, index));
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, index, createCallback(value, index));
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, createCallback(value, started++));
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, started, createCallback(value, started++));
    }
  }

  function objectIterator() {
    if (started &#x3c; size) {
      key = keys[started++];
      value = collection[key];
      iterator(value, createCallback(value, key));
    }
  }

  function objectIteratorWithKey() {
    if (started &#x3c; size) {
      key = keys[started++];
      value = collection[key];
      iterator(value, key, createCallback(value, key));
    }
  }

  function createCallback(value, key) {
    return function(err, res) {
      if (key === null) {
        throwError();
      }
      if (err) {
        key = null;
        iterate = noop;
        callback = once(callback);
        callback(err, objectClone(result));
        return;
      }
      if (!!res === bool) {
        result[key] = value;
      }
      key = null;
      if (++completed === size) {
        iterate = throwError;
        callback = onlyOnce(callback);
        callback(null, result);
      } else if (sync) {
        nextTick(iterate);
      } else {
        sync = true;
        iterate();
      }
      sync = false;
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 5, 3, 4, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">omitLimit</span>(array, 2, iterator, function(err, res) {
*   console.log(res); // { &#x27;3&#x27;: 4, &#x27;4&#x27;: 2 }
*   console.log(order); // [1, 3, 5, 2, 4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.omitSeries" id="apidoc.element.neo-async.async.omitSeries">
        function <span class="apidocSignatureSpan">neo-async.async.</span>omitSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">omitSeries = function (collection, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, value, keys, iter, iterate;
  var sync = false;
  var result = {};
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null, {});
  }
  iterate();

  function arrayIterator() {
    key = completed;
    value = collection[completed];
    iterator(value, done);
  }

  function arrayIteratorWithIndex() {
    key = completed;
    value = collection[completed];
    iterator(value, completed, done);
  }

  function symbolIterator() {
    key = completed;
    value = iter.next().value;
    iterator(value, done);
  }

  function symbolIteratorWithKey() {
    key = completed;
    value = iter.next().value;
    iterator(value, key, done);
  }

  function objectIterator() {
    key = keys[completed];
    value = collection[key];
    iterator(value, done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    value = collection[key];
    iterator(value, key, done);
  }

  function done(err, res) {
    if (err) {
      callback(err, result);
      return;
    }
    if (!!res === bool) {
      result[key] = value;
    }
    if (++completed === size) {
      iterate = throwError;
      callback(null, result);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2, 4];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">omitSeries</span>(array, iterator, function(err, res) {
*   console.log(res); // { &#x27;2&#x27;: 2, &#x27;3&#x27;: 4 }
*   console.log(order); // [1, 3, 2, 4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.parallel" id="apidoc.element.neo-async.async.parallel">
        function <span class="apidocSignatureSpan">neo-async.async.</span>parallel
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parallel(tasks, callback) {
  callback = callback || noop;
  var size, keys, result;
  var completed = 0;

  if (isArray(tasks)) {
    size = tasks.length;
    result = Array(size);
    arrayEach(tasks, createCallback);
  } else if (tasks &#x26;&#x26; typeof tasks === obj) {
    keys = nativeKeys(tasks);
    size = keys.length;
    result = {};
    baseEach(tasks, createCallback, keys);
  }
  if (!size) {
    callback(null, result);
  }

  function createCallback(key) {
    return function(err, res) {
      if (key === null) {
        throwError();
      }
      if (err) {
        key = null;
        callback = once(callback);
        callback(err, result);
        return;
      }
      result[key] = arguments.length &#x3c;= 2 ? res : slice(arguments, 1);
      key = null;
      if (++completed === size) {
        callback(null, result);
      }
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*  function(done) {
*    setTimeout(function() {
*      order.push(4);
*      done(null, 4);
*    }, 20);
*  }
* ];
* async.<span class="apidocCodeKeywordSpan">parallel</span>(tasks, function(err, res) {
*   console.log(res); // [1, 2, 3, 4];
*   console.log(order); // [1, 4, 2, 3]
* });
*
* @example
*
* var order = [];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.parallelLimit" id="apidoc.element.neo-async.async.parallelLimit">
        function <span class="apidocSignatureSpan">neo-async.async.</span>parallelLimit
        <span class="apidocSignatureSpan">(tasks, limit, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parallelLimit(tasks, limit, callback) {
  callback = callback || noop;
  var size, index, key, keys, result, iterate;
  var sync = false;
  var started = 0;
  var completed = 0;

  if (isArray(tasks)) {
    size = tasks.length;
    result = Array(size);
    iterate = arrayIterator;
  } else if (tasks &#x26;&#x26; typeof tasks === obj) {
    keys = nativeKeys(tasks);
    size = keys.length;
    result = {};
    iterate = objectIterator;
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null, result);
  }
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    index = started++;
    if (index &#x3c; size) {
      tasks[index](createCallback(index));
    }
  }

  function objectIterator() {
    if (started &#x3c; size) {
      key = keys[started++];
      tasks[key](createCallback(key));
    }
  }

  function createCallback(key) {
    return function(err, res) {
      if (key === null) {
        throwError();
      }
      if (err) {
        key = null;
        iterate = noop;
        callback = once(callback);
        callback(err, result);
        return;
      }
      result[key] = arguments.length &#x3c;= 2 ? res : slice(arguments, 1);
      key = null;
      if (++completed === size) {
        callback(null, result);
      } else if (sync) {
        nextTick(iterate);
      } else {
        sync = true;
        iterate();
      }
      sync = false;
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*  function(done) {
*    setTimeout(function() {
*      order.push(4);
*      done(null, 4);
*    }, 40);
*  }
* ];
* async.<span class="apidocCodeKeywordSpan">parallelLimit</span>(tasks, 2, function(err, res) {
*   console.log(res); // [1, 2, 3, 4];
*   console.log(order); // [1, 3, 2, 4]
* });
*
* @example
*
* var order = [];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.pick" id="apidoc.element.neo-async.async.pick">
        function <span class="apidocSignatureSpan">neo-async.async.</span>pick
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pick = function (collection, iterator, callback) {
  callback = callback || noop;
  var size, keys;
  var completed = 0;
  var result = {};

  if (isArray(collection)) {
    size = collection.length;
    arrayEach(collection, iterator, createCallback);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    symbolEach(collection, iterator, createCallback);
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    baseEach(collection, iterator, createCallback, keys);
  }
  if (!size) {
    return callback(null, {});
  }

  function createCallback(key, value) {
    return function done(err, res) {
      if (key === null) {
        throwError();
      }
      if (err) {
        key = null;
        callback = once(callback);
        callback(err, objectClone(result));
        return;
      }
      if (!!res === bool) {
        result[key] = value;
      }
      key = null;
      if (++completed === size) {
        callback(null, result);
      }
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2, 4];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">pick</span>(array, iterator, function(err, res) {
*   console.log(res); // { &#x27;0&#x27;: 1, &#x27;1&#x27;: 3 }
*   console.log(order); // [1, 2, 3, 4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.pickLimit" id="apidoc.element.neo-async.async.pickLimit">
        function <span class="apidocSignatureSpan">neo-async.async.</span>pickLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pickLimit = function (collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, value, keys, iter, item, iterate;
  var sync = false;
  var result = {};
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null, {});
  }
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, createCallback(value, index));
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, index, createCallback(value, index));
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, createCallback(value, started++));
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, started, createCallback(value, started++));
    }
  }

  function objectIterator() {
    if (started &#x3c; size) {
      key = keys[started++];
      value = collection[key];
      iterator(value, createCallback(value, key));
    }
  }

  function objectIteratorWithKey() {
    if (started &#x3c; size) {
      key = keys[started++];
      value = collection[key];
      iterator(value, key, createCallback(value, key));
    }
  }

  function createCallback(value, key) {
    return function(err, res) {
      if (key === null) {
        throwError();
      }
      if (err) {
        key = null;
        iterate = noop;
        callback = once(callback);
        callback(err, objectClone(result));
        return;
      }
      if (!!res === bool) {
        result[key] = value;
      }
      key = null;
      if (++completed === size) {
        iterate = throwError;
        callback = onlyOnce(callback);
        callback(null, result);
      } else if (sync) {
        nextTick(iterate);
      } else {
        sync = true;
        iterate();
      }
      sync = false;
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 5, 3, 4, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">pickLimit</span>(array, 2, iterator, function(err, res) {
*   console.log(res); // { &#x27;0&#x27;: 1, &#x27;1&#x27;: 5, &#x27;2&#x27;: 3 }
*   console.log(order); // [1, 3, 5, 2, 4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.pickSeries" id="apidoc.element.neo-async.async.pickSeries">
        function <span class="apidocSignatureSpan">neo-async.async.</span>pickSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pickSeries = function (collection, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, value, keys, iter, iterate;
  var sync = false;
  var result = {};
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null, {});
  }
  iterate();

  function arrayIterator() {
    key = completed;
    value = collection[completed];
    iterator(value, done);
  }

  function arrayIteratorWithIndex() {
    key = completed;
    value = collection[completed];
    iterator(value, completed, done);
  }

  function symbolIterator() {
    key = completed;
    value = iter.next().value;
    iterator(value, done);
  }

  function symbolIteratorWithKey() {
    key = completed;
    value = iter.next().value;
    iterator(value, key, done);
  }

  function objectIterator() {
    key = keys[completed];
    value = collection[key];
    iterator(value, done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    value = collection[key];
    iterator(value, key, done);
  }

  function done(err, res) {
    if (err) {
      callback(err, result);
      return;
    }
    if (!!res === bool) {
      result[key] = value;
    }
    if (++completed === size) {
      iterate = throwError;
      callback(null, result);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2, 4];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">pickSeries</span>(array, iterator, function(err, res) {
*   console.log(res); // { &#x27;0&#x27;: 1, &#x27;1&#x27;: 3 }
*   console.log(order); // [1, 3, 2, 4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.priorityQueue" id="apidoc.element.neo-async.async.priorityQueue">
        function <span class="apidocSignatureSpan">neo-async.async.</span>priorityQueue
        <span class="apidocSignatureSpan">(worker, concurrency)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function priorityQueue(worker, concurrency) {
  var q = baseQueue(true, worker, concurrency);
  q.push = push;
  delete q.unshift;
  return q;

  function push(tasks, priority, callback) {
    q.started = true;
    priority = priority || 0;
    var _tasks = isArray(tasks) ? tasks : [tasks];
    var taskSize = _tasks.length;

    if (tasks === undefined || taskSize === 0) {
      if (q.idle()) {
        nextTick(q.drain);
      }
      return;
    }

    callback = typeof callback === func ? callback : noop;
    var nextNode = q._tasks.head;
    while (nextNode &#x26;&#x26; priority &#x3e;= nextNode.priority) {
      nextNode = nextNode.next;
    }
    while (taskSize--) {
      var item = {
        data: _tasks[taskSize],
        priority: priority,
        callback: callback
      };
      if (nextNode) {
        q._tasks.insertBefore(nextNode, item);
      } else {
        q._tasks.push(item);
      }
      nextTick(q.process);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.queue" id="apidoc.element.neo-async.async.queue">
        function <span class="apidocSignatureSpan">neo-async.async.</span>queue
        <span class="apidocSignatureSpan">(worker, concurrency)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function queue(worker, concurrency) {
  return baseQueue(true, worker, concurrency);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.race" id="apidoc.element.neo-async.async.race">
        function <span class="apidocSignatureSpan">neo-async.async.</span>race
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function race(tasks, callback) {
  callback = once(callback || noop);
  var size, keys;
  var index = -1;
  if (isArray(tasks)) {
    size = tasks.length;
    while (++index &#x3c; size) {
      tasks[index](callback);
    }
  } else if (tasks &#x26;&#x26; typeof tasks === obj) {
    keys = nativeKeys(tasks);
    size = keys.length;
    while (++index &#x3c; size) {
      tasks[keys[index]](callback);
    }
  } else {
    return callback(new TypeError(&#x27;First argument to race must be a collection of functions&#x27;));
  }
  if (!size) {
    callback(null);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*   function(done) {
*     setTimeout(function() {
*       called++;
*       done(null, &#x27;3&#x27;);
*     }, 10);
*   }
* ];
* async.<span class="apidocCodeKeywordSpan">race</span>(tasks, function(err, res) {
*   console.log(res); // &#x27;3&#x27;
*   console.log(called); // 1
*   setTimeout(function() {
*     console.log(called); // 3
*   }, 50);
* });
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.reduce" id="apidoc.element.neo-async.async.reduce">
        function <span class="apidocSignatureSpan">neo-async.async.</span>reduce
        <span class="apidocSignatureSpan">(collection, result, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduce(collection, result, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, keys, iter, iterate;
  var sync = false;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 4 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 4 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 4 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null, result);
  }
  iterate(result);

  function arrayIterator(result) {
    iterator(result, collection[completed], done);
  }

  function arrayIteratorWithIndex(result) {
    iterator(result, collection[completed], completed, done);
  }

  function symbolIterator() {
    iterator(result, iter.next().value, done);
  }

  function symbolIteratorWithKey() {
    iterator(result, iter.next().value, completed, done);
  }

  function objectIterator(result) {
    iterator(result, collection[keys[completed]], done);
  }

  function objectIteratorWithKey(result) {
    key = keys[completed];
    iterator(result, collection[key], key, done);
  }

  function done(err, result) {
    if (err) {
      callback(err, result);
    } else if (++completed === size) {
      iterator = throwError;
      callback(null, result);
    } else if (sync) {
      nextTick(function() {
        iterate(result);
      });
    } else {
      sync = true;
      iterate(result);
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var collection = [1, 3, 2, 4];
* var iterator = function(result, num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, result + num);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">reduce</span>(collection, 0, iterator, function(err, res) {
*   console.log(res); // 10
*   console.log(order); // [1, 3, 2, 4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.reduceRight" id="apidoc.element.neo-async.async.reduceRight">
        function <span class="apidocSignatureSpan">neo-async.async.</span>reduceRight
        <span class="apidocSignatureSpan">(collection, result, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduceRight(collection, result, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var resIndex, index, key, keys, iter, item, col, iterate;
  var sync = false;

  if (isArray(collection)) {
    resIndex = collection.length;
    iterate = iterator.length === 4 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    resIndex = collection.size;
    col = Array(resIndex);
    iter = collection[iteratorSymbol]();
    index = -1;
    while ((item = iter.next()).done === false) {
      col[++index] = item.value;
    }
    collection = col;
    iterate = iterator.length === 4 ? arrayIteratorWithIndex : arrayIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    resIndex = keys.length;
    iterate = iterator.length === 4 ? objectIteratorWithKey : objectIterator;
  }
  if (!resIndex) {
    return callback(null, result);
  }
  iterate(result);

  function arrayIterator(result) {
    iterator(result, collection[--resIndex], done);
  }

  function arrayIteratorWithIndex(result) {
    iterator(result, collection[--resIndex], resIndex, done);
  }

  function objectIterator(result) {
    iterator(result, collection[keys[--resIndex]], done);
  }

  function objectIteratorWithKey(result) {
    key = keys[--resIndex];
    iterator(result, collection[key], key, done);
  }

  function done(err, result) {
    if (err) {
      callback(err, result);
    } else if (resIndex === 0) {
      iterate = throwError;
      callback(null, result);
    } else if (sync) {
      nextTick(function() {
        iterate(result);
      });
    } else {
      sync = true;
      iterate(result);
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var collection = [1, 3, 2, 4];
* var iterator = function(result, num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, result + num);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">reduceRight</span>(collection, 0, iterator, function(err, res) {
*   console.log(res); // 10
*   console.log(order); // [4, 2, 3, 1]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.reflect" id="apidoc.element.neo-async.async.reflect">
        function <span class="apidocSignatureSpan">neo-async.async.</span>reflect
        <span class="apidocSignatureSpan">(func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reflect(func) {
  return function( /* args..., callback */ ) {
    var callback;
    switch (arguments.length) {
      case 1:
        callback = arguments[0];
        return func(done);
      case 2:
        callback = arguments[1];
        return func(arguments[0], done);
      default:
        var args = createArray(arguments);
        var lastIndex = args.length - 1;
        callback = args[lastIndex];
        args[lastIndex] = done;
        func.apply(this, args);
    }

    function done(err, res) {
      if (err) {
        return callback(null, {
          error: err
        });
      }
      if (arguments.length &#x3e; 2) {
        res = slice(arguments, 1);
      }
      callback(null, {
        value: res
      });
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.reflectAll" id="apidoc.element.neo-async.async.reflectAll">
        function <span class="apidocSignatureSpan">neo-async.async.</span>reflectAll
        <span class="apidocSignatureSpan">(tasks)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reflectAll(tasks) {
  var size, newTasks, keys;
  if (isArray(tasks)) {
    size = tasks.length;
    newTasks = Array(size);
    arrayEachSync(tasks, iterate);
  } else if (tasks &#x26;&#x26; typeof tasks === obj) {
    keys = nativeKeys(tasks);
    size = keys.length;
    newTasks = {};
    baseEachSync(tasks, iterate, keys);
  }
  return newTasks;

  function iterate(func, key) {
    newTasks[key] = reflect(func);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.reject" id="apidoc.element.neo-async.async.reject">
        function <span class="apidocSignatureSpan">neo-async.async.</span>reject
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reject = function (collection, iterator, callback) {
  callback = callback || noop;
  var size, keys, result;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    result = Array(size);
    arrayEach(collection, iterator, createCallback);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    result = Array(size);
    symbolEach(collection, iterator, createCallback);
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    result = Array(size);
    baseEach(collection, iterator, createCallback, keys);
  }
  if (!size) {
    return callback(null, []);
  }

  function createCallback(index, value) {
    return function done(err, res) {
      if (index === null) {
        throwError();
      }
      if (err) {
        index = null;
        callback = once(callback);
        callback(err);
        return;
      }
      if (!!res === bool) {
        result[index] = value;
      }
      index = null;
      if (++completed === size) {
        callback(null, compact(result));
      }
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">reject</span>(array, iterator, function(err, res) {
*   console.log(res); // [2];
*   console.log(order); // [1, 2, 3]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.rejectLimit" id="apidoc.element.neo-async.async.rejectLimit">
        function <span class="apidocSignatureSpan">neo-async.async.</span>rejectLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rejectLimit = function (collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, value, keys, iter, item, iterate, result;
  var sync = false;
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null, []);
  }
  result = Array(size);
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, createCallback(value, index));
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, index, createCallback(value, index));
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, createCallback(value, started++));
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, started, createCallback(value, started++));
    }
  }

  function objectIterator() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[keys[index]];
      iterator(value, createCallback(value, index));
    }
  }

  function objectIteratorWithKey() {
    index = started++;
    if (index &#x3c; size) {
      key = keys[index];
      value = collection[key];
      iterator(value, key, createCallback(value, index));
    }
  }

  function createCallback(value, index) {
    return function(err, res) {
      if (index === null) {
        throwError();
      }
      if (err) {
        index = null;
        iterate = noop;
        callback = once(callback);
        callback(err);
        return;
      }
      if (!!res === bool) {
        result[index] = value;
      }
      index = null;
      if (++completed === size) {
        callback = onlyOnce(callback);
        callback(null, compact(result));
      } else if (sync) {
        nextTick(iterate);
      } else {
        sync = true;
        iterate();
      }
      sync = false;
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 5, 3, 4, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">rejectLimit</span>(array, 2, iterator, function(err, res) {
*   console.log(res); // [4, 2]
*   console.log(order); // [1, 3, 5, 2, 4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.rejectSeries" id="apidoc.element.neo-async.async.rejectSeries">
        function <span class="apidocSignatureSpan">neo-async.async.</span>rejectSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rejectSeries = function (collection, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, value, keys, iter, iterate;
  var sync = false;
  var completed = 0;
  var result = [];

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null, []);
  }
  iterate();

  function arrayIterator() {
    value = collection[completed];
    iterator(value, done);
  }

  function arrayIteratorWithIndex() {
    value = collection[completed];
    iterator(value, completed, done);
  }

  function symbolIterator() {
    value = iter.next().value;
    iterator(value, done);
  }

  function symbolIteratorWithKey() {
    value = iter.next().value;
    iterator(value, completed, done);
  }

  function objectIterator() {
    key = keys[completed];
    value = collection[key];
    iterator(value, done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    value = collection[key];
    iterator(value, key, done);
  }

  function done(err, res) {
    if (err) {
      callback(err);
      return;
    }
    if (!!res === bool) {
      result[result.length] = value;
    }
    if (++completed === size) {
      iterate = throwError;
      callback(null, result);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">rejectSeries</span>(array, iterator, function(err, res) {
*   console.log(res); // [2];
*   console.log(order); // [1, 3, 2]
* });
*
* @example
*
* // object
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.retry" id="apidoc.element.neo-async.async.retry">
        function <span class="apidocSignatureSpan">neo-async.async.</span>retry
        <span class="apidocSignatureSpan">(opts, task, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function retry(opts, task, callback) {
  var times, intervalFunc, errorFilter;
  var count = 0;
  if (arguments.length &#x3c; 3 &#x26;&#x26; typeof opts === func) {
    callback = task || noop;
    task = opts;
    opts = null;
    times = DEFAULT_TIMES;
  } else {
    callback = callback || noop;
    switch (typeof opts) {
      case &#x27;object&#x27;:
        if (typeof opts.errorFilter === func) {
          errorFilter = opts.errorFilter;
        }
        var interval = opts.interval;
        switch (typeof interval) {
          case func:
            intervalFunc = interval;
            break;
          case &#x27;string&#x27;:
          case &#x27;number&#x27;:
            interval = +interval;
            intervalFunc = interval ? function() {
              return interval;
            } : function() {
              return DEFAULT_INTERVAL;
            };
            break;
        }
        times = +opts.times || DEFAULT_TIMES;
        break;
      case &#x27;number&#x27;:
        times = opts || DEFAULT_TIMES;
        break;
      case &#x27;string&#x27;:
        times = +opts || DEFAULT_TIMES;
        break;
      default:
        throw new Error(&#x27;Invalid arguments for async.retry&#x27;);
    }
  }
  if (typeof task !== &#x27;function&#x27;) {
    throw new Error(&#x27;Invalid arguments for async.retry&#x27;);
  }

  if (intervalFunc) {
    task(intervalCallback);
  } else {
    task(simpleCallback);
  }

  function simpleIterator() {
    task(simpleCallback);
  }

  function simpleCallback(err, res) {
    if (++count === times || !err || errorFilter &#x26;&#x26; !errorFilter(err)) {
      if (arguments.length &#x3c;= 2) {
        return callback(err, res);
      }
      var args = createArray(arguments);
      return callback.apply(null, args);
    }
    simpleIterator();
  }

  function intervalIterator() {
    task(intervalCallback);
  }

  function intervalCallback(err, res) {
    if (++count === times || !err || errorFilter &#x26;&#x26; !errorFilter(err)) {
      if (arguments.length &#x3c;= 2) {
        return callback(err, res);
      }
      var args = createArray(arguments);
      return callback.apply(null, args);
    }
    setTimeout(intervalIterator, intervalFunc(count));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.retryable" id="apidoc.element.neo-async.async.retryable">
        function <span class="apidocSignatureSpan">neo-async.async.</span>retryable
        <span class="apidocSignatureSpan">(opts, task)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function retryable(opts, task) {
  if (!task) {
    task = opts;
    opts = null;
  }
  return done;

  function done() {
    var taskFn;
    var args = createArray(arguments);
    var lastIndex = args.length - 1;
    var callback = args[lastIndex];
    switch (task.length) {
      case 1:
        taskFn = task1;
        break;
      case 2:
        taskFn = task2;
        break;
      case 3:
        taskFn = task3;
        break;
      default:
        taskFn = task4;
    }
    if (opts) {
      retry(opts, taskFn, callback);
    } else {
      retry(taskFn, callback);
    }

    function task1(done) {
      task(done);
    }

    function task2(done) {
      task(args[0], done);
    }

    function task3(done) {
      task(args[0], args[1], done);
    }

    function task4(callback) {
      args[lastIndex] = callback;
      task.apply(null, args);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.safe" id="apidoc.element.neo-async.async.safe">
        function <span class="apidocSignatureSpan">neo-async.async.</span>safe
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function safe() {
  createImmediate();
  return exports;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.select" id="apidoc.element.neo-async.async.select">
        function <span class="apidocSignatureSpan">neo-async.async.</span>select
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">select = function (collection, iterator, callback) {
  callback = callback || noop;
  var size, keys, result;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    result = Array(size);
    arrayEach(collection, iterator, createCallback);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    result = Array(size);
    symbolEach(collection, iterator, createCallback);
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    result = Array(size);
    baseEach(collection, iterator, createCallback, keys);
  }
  if (!size) {
    return callback(null, []);
  }

  function createCallback(index, value) {
    return function done(err, res) {
      if (index === null) {
        throwError();
      }
      if (err) {
        index = null;
        callback = once(callback);
        callback(err);
        return;
      }
      if (!!res === bool) {
        result[index] = value;
      }
      index = null;
      if (++completed === size) {
        callback(null, compact(result));
      }
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.selectLimit" id="apidoc.element.neo-async.async.selectLimit">
        function <span class="apidocSignatureSpan">neo-async.async.</span>selectLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selectLimit = function (collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, value, keys, iter, item, iterate, result;
  var sync = false;
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null, []);
  }
  result = Array(size);
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, createCallback(value, index));
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, index, createCallback(value, index));
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, createCallback(value, started++));
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, started, createCallback(value, started++));
    }
  }

  function objectIterator() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[keys[index]];
      iterator(value, createCallback(value, index));
    }
  }

  function objectIteratorWithKey() {
    index = started++;
    if (index &#x3c; size) {
      key = keys[index];
      value = collection[key];
      iterator(value, key, createCallback(value, index));
    }
  }

  function createCallback(value, index) {
    return function(err, res) {
      if (index === null) {
        throwError();
      }
      if (err) {
        index = null;
        iterate = noop;
        callback = once(callback);
        callback(err);
        return;
      }
      if (!!res === bool) {
        result[index] = value;
      }
      index = null;
      if (++completed === size) {
        callback = onlyOnce(callback);
        callback(null, compact(result));
      } else if (sync) {
        nextTick(iterate);
      } else {
        sync = true;
        iterate();
      }
      sync = false;
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.selectSeries" id="apidoc.element.neo-async.async.selectSeries">
        function <span class="apidocSignatureSpan">neo-async.async.</span>selectSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selectSeries = function (collection, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, value, keys, iter, iterate;
  var sync = false;
  var completed = 0;
  var result = [];

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null, []);
  }
  iterate();

  function arrayIterator() {
    value = collection[completed];
    iterator(value, done);
  }

  function arrayIteratorWithIndex() {
    value = collection[completed];
    iterator(value, completed, done);
  }

  function symbolIterator() {
    value = iter.next().value;
    iterator(value, done);
  }

  function symbolIteratorWithKey() {
    value = iter.next().value;
    iterator(value, completed, done);
  }

  function objectIterator() {
    key = keys[completed];
    value = collection[key];
    iterator(value, done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    value = collection[key];
    iterator(value, key, done);
  }

  function done(err, res) {
    if (err) {
      callback(err);
      return;
    }
    if (!!res === bool) {
      result[result.length] = value;
    }
    if (++completed === size) {
      iterate = throwError;
      callback(null, result);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.seq" id="apidoc.element.neo-async.async.seq">
        function <span class="apidocSignatureSpan">neo-async.async.</span>seq
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function seq() {
  var fns = createArray(arguments);

  return function() {

    var self = this;
    var args = createArray(arguments);
    var callback = args[args.length - 1];
    if (typeof callback === func) {
      args.pop();
    } else {
      callback = noop;
    }
    reduce(fns, args, iterator, done);

    function iterator(newargs, fn, callback) {
      var func = function(err) {
        var nextargs = slice(arguments, 1);
        callback(err, nextargs);
      };
      newargs.push(func);
      fn.apply(self, newargs);
    }

    function done(err, res) {
      res = isArray(res) ? res : [res];
      res.unshift(err);
      callback.apply(self, res);
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.series" id="apidoc.element.neo-async.async.series">
        function <span class="apidocSignatureSpan">neo-async.async.</span>series
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function series(tasks, callback) {
  callback = callback || noop;
  var size, key, keys, result, iterate;
  var sync = false;
  var completed = 0;

  if (isArray(tasks)) {
    size = tasks.length;
    result = Array(size);
    iterate = arrayIterator;
  } else if (tasks &#x26;&#x26; typeof tasks === obj) {
    keys = nativeKeys(tasks);
    size = keys.length;
    result = {};
    iterate = objectIterator;
  } else {
    return callback(null);
  }
  if (!size) {
    return callback(null, result);
  }
  iterate();

  function arrayIterator() {
    key = completed;
    tasks[completed](done);
  }

  function objectIterator() {
    key = keys[completed];
    tasks[key](done);
  }

  function done(err, res) {
    if (err) {
      iterate = throwError;
      callback = onlyOnce(callback);
      callback(err, result);
      return;
    }
    result[key] = arguments.length &#x3c;= 2 ? res : slice(arguments, 1);
    if (++completed === size) {
      iterate = throwError;
      callback(null, result);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*  function(done) {
*    setTimeout(function() {
*      order.push(4);
*      done(null, 4);
*    }, 20);
*  }
* ];
* async.<span class="apidocCodeKeywordSpan">series</span>(tasks, function(err, res) {
*   console.log(res); // [1, 2, 3, 4];
*   console.log(order); // [1, 2, 3, 4]
* });
*
* @example
*
* var order = [];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.setImmediate" id="apidoc.element.neo-async.async.setImmediate">
        function <span class="apidocSignatureSpan">neo-async.async.</span>setImmediate
        <span class="apidocSignatureSpan">(callback, arg1, arg2, arg3)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setImmediate = function (callback, arg1, arg2, arg3) {
  if (typeof callback !== &#x27;function&#x27;) {
    throw new TypeError(&#x27;&#x22;callback&#x22; argument must be a function&#x27;);
  }

  var i, args;

  switch (arguments.length) {
    // fast cases
    case 1:
      break;
    case 2:
      args = [arg1];
      break;
    case 3:
      args = [arg1, arg2];
      break;
    default:
      args = [arg1, arg2, arg3];
      for (i = 4; i &#x3c; arguments.length; i++)
        // extend array dynamically, makes .apply run much faster in v6.0.0
        args[i - 1] = arguments[i];
      break;
  }
  return createImmediate(args, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.some" id="apidoc.element.neo-async.async.some">
        function <span class="apidocSignatureSpan">neo-async.async.</span>some
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function some(collection, iterator, callback) {
  callback = callback || noop;
  detect(collection, iterator, done);

  function done(err, res) {
    if (err) {
      return callback(err);
    }
    callback(null, !!res);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">some</span>(array, iterator, function(err, res) {
*   console.log(res); // true
*   console.log(order); // [1]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.someLimit" id="apidoc.element.neo-async.async.someLimit">
        function <span class="apidocSignatureSpan">neo-async.async.</span>someLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function someLimit(collection, limit, iterator, callback) {
  callback = callback || noop;
  detectLimit(collection, limit, iterator, done);

  function done(err, res) {
    if (err) {
      return callback(err);
    }
    callback(null, !!res);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 5, 3, 4, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">someLimit</span>(array, 2, iterator, function(err, res) {
*   console.log(res); // true
*   console.log(order); // [1]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.someSeries" id="apidoc.element.neo-async.async.someSeries">
        function <span class="apidocSignatureSpan">neo-async.async.</span>someSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function someSeries(collection, iterator, callback) {
  callback = callback || noop;
  detectSeries(collection, iterator, done);

  function done(err, res) {
    if (err) {
      return callback(err);
    }
    callback(null, !!res);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">someSeries</span>(array, iterator, function(err, res) {
*   console.log(res); // true
*   console.log(order); // [1]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.sortBy" id="apidoc.element.neo-async.async.sortBy">
        function <span class="apidocSignatureSpan">neo-async.async.</span>sortBy
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sortBy(collection, iterator, callback) {
  callback = callback || noop;
  var size, result;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    result = Array(size);
    arrayEach(collection, iterator, createCallback);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    result = Array(size);
    symbolEach(collection, iterator, createCallback);
  } else if (typeof collection === obj) {
    var keys = nativeKeys(collection);
    size = keys.length;
    result = Array(size);
    baseEach(collection, iterator, createCallback, keys);
  }
  if (!size) {
    callback(null, []);
  }

  function createCallback(value) {
    var called = false;
    return function done(err, criteria) {
      if (called) {
        throwError();
      }
      called = true;
      result[completed] = {
        value: value,
        criteria: criteria
      };
      if (err) {
        callback = once(callback);
        callback(err);
      } else if (++completed === size) {
        result.sort(sortIterator);
        callback(null, pluck(result, &#x27;value&#x27;));
      }
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">sortBy</span>(array, iterator, function(err, res) {
*   console.log(res); // [1, 2, 3];
*   console.log(order); // [1, 2, 3]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.sortByLimit" id="apidoc.element.neo-async.async.sortByLimit">
        function <span class="apidocSignatureSpan">neo-async.async.</span>sortByLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sortByLimit(collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, value, keys, iter, item, result, iterate;
  var sync = false;
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null, []);
  }
  result = Array(size);
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    if (started &#x3c; size) {
      value = collection[started++];
      iterator(value, createCallback(value));
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, index, createCallback(value));
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, createCallback(value));
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, started++, createCallback(value));
    }
  }

  function objectIterator() {
    if (started &#x3c; size) {
      value = collection[keys[started++]];
      iterator(value, createCallback(value));
    }
  }

  function objectIteratorWithKey() {
    if (started &#x3c; size) {
      key = keys[started++];
      value = collection[key];
      iterator(value, key, createCallback(value));
    }
  }

  function createCallback(value) {
    var called = false;
    return function(err, criteria) {
      if (called) {
        throwError();
      }
      called = true;
      result[completed] = {
        value: value,
        criteria: criteria
      };
      if (err) {
        iterate = noop;
        callback(err);
        callback = noop;
      } else if (++completed === size) {
        result.sort(sortIterator);
        callback(null, pluck(result, &#x27;value&#x27;));
      } else if (sync) {
        nextTick(iterate);
      } else {
        sync = true;
        iterate();
      }
      sync = false;
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 5, 3, 4, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">sortByLimit</span>(array, 2, iterator, function(err, res) {
*   console.log(res); // [1, 2, 3, 4, 5]
*   console.log(order); // [1, 3, 5, 2, 4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.sortBySeries" id="apidoc.element.neo-async.async.sortBySeries">
        function <span class="apidocSignatureSpan">neo-async.async.</span>sortBySeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sortBySeries(collection, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, value, keys, iter, result, iterate;
  var sync = false;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null, []);
  }
  result = Array(size);
  iterate();

  function arrayIterator() {
    value = collection[completed];
    iterator(value, done);
  }

  function arrayIteratorWithIndex() {
    value = collection[completed];
    iterator(value, completed, done);
  }

  function symbolIterator() {
    value = iter.next().value;
    iterator(value, done);
  }

  function symbolIteratorWithKey() {
    value = iter.next().value;
    iterator(value, completed, done);
  }

  function objectIterator() {
    value = collection[keys[completed]];
    iterator(value, done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    value = collection[key];
    iterator(value, key, done);
  }

  function done(err, criteria) {
    result[completed] = {
      value: value,
      criteria: criteria
    };
    if (err) {
      callback(err);
    } else if (++completed === size) {
      iterate = throwError;
      result.sort(sortIterator);
      callback(null, pluck(result, &#x27;value&#x27;));
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">sortBySeries</span>(array, iterator, function(err, res) {
*   console.log(res); // [1, 2, 3];
*   console.log(order); // [1, 3, 2]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.timeout" id="apidoc.element.neo-async.async.timeout">
        function <span class="apidocSignatureSpan">neo-async.async.</span>timeout
        <span class="apidocSignatureSpan">(func, millisec, info)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function timeout(func, millisec, info) {
  var callback, timer;
  return wrappedFunc;

  function wrappedFunc() {
    timer = setTimeout(timeoutCallback, millisec);
    var args = createArray(arguments);
    var lastIndex = args.length - 1;
    callback = args[lastIndex];
    args[lastIndex] = injectedCallback;
    simpleApply(func, args);
  }

  function timeoutCallback() {
    var name = func.name || &#x27;anonymous&#x27;;
    var err = new Error(&#x27;Callback function &#x22;&#x27; + name + &#x27;&#x22; timed out.&#x27;);
    err.code = &#x27;ETIMEDOUT&#x27;;
    if (info) {
      err.info = info;
    }
    timer = null;
    callback(err);
  }

  function injectedCallback() {
    if (timer !== null) {
      simpleApply(callback, createArray(arguments));
      clearTimeout(timer);
    }
  }

  function simpleApply(func, args) {
    switch(args.length) {
      case 0:
        func();
        break;
      case 1:
        func(args[0]);
        break;
      case 2:
        func(args[0], args[1]);
        break;
      default:
        func.apply(null, args);
        break;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.times" id="apidoc.element.neo-async.async.times">
        function <span class="apidocSignatureSpan">neo-async.async.</span>times
        <span class="apidocSignatureSpan">(n, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function times(n, iterator, callback) {
  callback = callback || noop;
  n = +n;
  if (isNaN(n) || n &#x3c; 1) {
    return callback(null, []);
  }
  var result = Array(n);
  timesSync(n, iterate);

  function iterate(num) {
    iterator(num, createCallback(num));
  }

  function createCallback(index) {
    return function(err, res) {
      if (index === null) {
        throwError();
      }
      result[index] = res;
      index = null;
      if (err) {
        callback(err);
        callback = noop;
      } else if (--n === 0) {
        callback(null, result);
      }
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Function} iterator
 * @param {Function} callback
 * @example
 *
 * var iterator = function(n, done) {
 *   done(null, n);
 * };
 * async.<span class="apidocCodeKeywordSpan">times</span>(4, iterator, function(err, res) {
 *   console.log(res); // [0, 1, 2, 3];
 * });
 *
 */
function times(n, iterator, callback) {
  callback = callback || noop;
  n = +n;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.timesLimit" id="apidoc.element.neo-async.async.timesLimit">
        function <span class="apidocSignatureSpan">neo-async.async.</span>timesLimit
        <span class="apidocSignatureSpan">(n, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function timesLimit(n, limit, iterator, callback) {
  callback = callback || noop;
  n = +n;
  if (isNaN(n) || n &#x3c; 1 || isNaN(limit) || limit &#x3c; 1) {
    return callback(null, []);
  }
  var result = Array(n);
  var sync = false;
  var started = 0;
  var completed = 0;
  timesSync(limit &#x3e; n ? n : limit, iterate);

  function iterate() {
    var index = started++;
    if (index &#x3c; n) {
      iterator(index, createCallback(index));
    }
  }

  function createCallback(index) {
    return function(err, res) {
      if (index === null) {
        throwError();
      }
      result[index] = res;
      index = null;
      if (err) {
        callback(err);
        callback = noop;
      } else if (++completed &#x3e;= n) {
        callback(null, result);
        callback = throwError;
      } else if (sync) {
        nextTick(iterate);
      } else {
        sync = true;
        iterate();
      }
      sync = false;
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Function} iterator
 * @param {Function} callback
 * @example
 *
 * var iterator = function(n, done) {
 *   done(null, n);
 * };
 * async.<span class="apidocCodeKeywordSpan">timesLimit</span>(4, 2, iterator, function(err, res) {
 *   console.log(res); // [0, 1, 2, 3];
 * });
 *
 */
function timesLimit(n, limit, iterator, callback) {
  callback = callback || noop;
  n = +n;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.timesSeries" id="apidoc.element.neo-async.async.timesSeries">
        function <span class="apidocSignatureSpan">neo-async.async.</span>timesSeries
        <span class="apidocSignatureSpan">(n, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function timesSeries(n, iterator, callback) {
  callback = callback || noop;
  n = +n;
  if (isNaN(n) || n &#x3c; 1) {
    return callback(null, []);
  }
  var result = Array(n);
  var sync = false;
  var completed = 0;
  iterate();

  function iterate() {
    iterator(completed, done);
  }

  function done(err, res) {
    result[completed] = res;
    if (err) {
      callback(err);
      callback = throwError;
    } else if (++completed &#x3e;= n) {
      callback(null, result);
      callback = throwError;
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Function} iterator
 * @param {Function} callback
 * @example
 *
 * var iterator = function(n, done) {
 *   done(null, n);
 * };
 * async.<span class="apidocCodeKeywordSpan">timesSeries</span>(4, iterator, function(err, res) {
 *   console.log(res); // [0, 1, 2, 3];
 * });
 *
 */
function timesSeries(n, iterator, callback) {
  callback = callback || noop;
  n = +n;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.transform" id="apidoc.element.neo-async.async.transform">
        function <span class="apidocSignatureSpan">neo-async.async.</span>transform
        <span class="apidocSignatureSpan">(collection, accumulator, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function transform(collection, accumulator, iterator, callback) {
  if (arguments.length === 3) {
    callback = iterator;
    iterator = accumulator;
    accumulator = undefined;
  }
  callback = callback || noop;
  var size, keys, result;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    result = accumulator !== undefined ? accumulator : [];
    arrayEach(collection, result, iterator, done);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    result = accumulator !== undefined ? accumulator : {};
    symbolEach(collection, result, iterator, done);
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    result = accumulator !== undefined ? accumulator : {};
    baseEach(collection, result, iterator, done, keys);
  }
  if (!size) {
    callback(null, accumulator !== undefined ? accumulator : result || {});
  }

  function done(err, bool) {
    if (err) {
      callback = once(callback);
      callback(err, isArray(result) ? createArray(result) : objectClone(result));
    } else if (++completed === size) {
      callback(null, result);
    } else if (bool === false) {
      callback = once(callback);
      callback(null, isArray(result) ? createArray(result) : objectClone(result));
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var iterator = function(result, num, done) {
*   setTimeout(function() {
*     order.push(num);
*     result.push(num)
*     done();
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">transform</span>(collection, iterator, function(err, res) {
*   console.log(res); // [1, 2, 3, 4]
*   console.log(order); // [1, 2, 3, 4]
* });
*
* @example
*
* // array with index and accumulator
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.transformLimit" id="apidoc.element.neo-async.async.transformLimit">
        function <span class="apidocSignatureSpan">neo-async.async.</span>transformLimit
        <span class="apidocSignatureSpan">(collection, limit, accumulator, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function transformLimit(collection, limit, accumulator, iterator, callback) {
  if (arguments.length === 4) {
    callback = iterator;
    iterator = accumulator;
    accumulator = undefined;
  }
  callback = callback || noop;
  var size, index, key, keys, iter, item, iterate, result;
  var sync = false;
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    result = accumulator !== undefined ? accumulator : [];
    iterate = iterator.length === 4 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    result = accumulator !== undefined ? accumulator : {};
    iterate = iterator.length === 4 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    result = accumulator !== undefined ? accumulator : {};
    iterate = iterator.length === 4 ? objectIteratorWithKey : objectIterator;
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null, accumulator !== undefined ? accumulator : result || {});
  }
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    index = started++;
    if (index &#x3c; size) {
      iterator(result, collection[index], onlyOnce(done));
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      iterator(result, collection[index], index, onlyOnce(done));
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      iterator(result, item.value, onlyOnce(done));
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      iterator(result, item.value, started++, onlyOnce(done));
    }
  }

  function objectIterator() {
    index = started++;
    if (index &#x3c; size) {
      iterator(result, collection[keys[index]], onlyOnce(done));
    }
  }

  function objectIteratorWithKey() {
    index = started++;
    if (index &#x3c; size) {
      key = keys[index];
      iterator(result, collection[key], key, onlyOnce(done));
    }
  }

  function done(err, bool) {
    if (err) {
      iterate = noop;
      callback(err, isArray(result) ? createArray(result) : objectClone(result));
      callback = noop;
    } else if (++completed === size) {
      callback(null, result);
    } else if (bool === false) {
      iterate = noop;
      callback(null, isArray(result) ? createArray(result) : objectClone(result));
      callback = noop;
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var iterator = function(result, num, done) {
*   setTimeout(function() {
*     order.push(num);
*     result.push(num);
*     done();
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">transformLimit</span>(array, 2, iterator, function(err, res) {
*   console.log(res); // [1, 3, 5, 2, 4]
*   console.log(order); // [1, 3, 5, 2, 4]
* });
*
* @example
*
* // array with index and accumulator
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.transformSeries" id="apidoc.element.neo-async.async.transformSeries">
        function <span class="apidocSignatureSpan">neo-async.async.</span>transformSeries
        <span class="apidocSignatureSpan">(collection, accumulator, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function transformSeries(collection, accumulator, iterator, callback) {
  if (arguments.length === 3) {
    callback = iterator;
    iterator = accumulator;
    accumulator = undefined;
  }
  callback = onlyOnce(callback || noop);
  var size, key, keys, iter, iterate, result;
  var sync = false;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    result = accumulator !== undefined ? accumulator : [];
    iterate = iterator.length === 4 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    result = accumulator !== undefined ? accumulator : {};
    iterate = iterator.length === 4 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    result = accumulator !== undefined ? accumulator : {};
    iterate = iterator.length === 4 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null, accumulator !== undefined ? accumulator : result || {});
  }
  iterate();

  function arrayIterator() {
    iterator(result, collection[completed], done);
  }

  function arrayIteratorWithIndex() {
    iterator(result, collection[completed], completed, done);
  }

  function symbolIterator() {
    iterator(result, iter.next().value, done);
  }

  function symbolIteratorWithKey() {
    iterator(result, iter.next().value, completed, done);
  }

  function objectIterator() {
    iterator(result, collection[keys[completed]], done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    iterator(result, collection[key], key, done);
  }

  function done(err, bool) {
    if (err) {
      callback(err, result);
    } else if (++completed === size) {
      iterate = throwError;
      callback(null, result);
    } else if (bool === false) {
      iterate = throwError;
      callback(null, result);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var iterator = function(result, num, done) {
*   setTimeout(function() {
*     order.push(num);
*     result.push(num)
*     done();
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">transformSeries</span>(collection, iterator, function(err, res) {
*   console.log(res); // [1, 3, 2, 4]
*   console.log(order); // [1, 3, 2, 4]
* });
*
* @example
*
* // array with index and accumulator
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.unmemoize" id="apidoc.element.neo-async.async.unmemoize">
        function <span class="apidocSignatureSpan">neo-async.async.</span>unmemoize
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unmemoize(fn) {
  return function() {
    return (fn.unmemoized || fn).apply(null, arguments);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.until" id="apidoc.element.neo-async.async.until">
        function <span class="apidocSignatureSpan">neo-async.async.</span>until
        <span class="apidocSignatureSpan">(test, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function until(test, iterator, callback) {
  callback = callback || noop;
  var sync = false;
  if (!test()) {
    iterate();
  } else {
    callback(null);
  }

  function iterate() {
    if (sync) {
      nextTick(next);
    } else {
      sync = true;
      iterator(done);
    }
    sync = false;
  }

  function next() {
    iterator(done);
  }

  function done(err, arg) {
    if (err) {
      return callback(err);
    }
    if (arguments.length &#x3c;= 2) {
      if (!test(arg)) {
        iterate();
      } else {
        callback(null, arg);
      }
      return;
    }
    arg = slice(arguments, 1);
    if (!test.apply(null, arg)) {
      iterate();
    } else {
      callback.apply(null, [null].concat(arg));
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.waterfall" id="apidoc.element.neo-async.async.waterfall">
        function <span class="apidocSignatureSpan">neo-async.async.</span>waterfall
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function waterfall(tasks, callback) {
  callback = callback || noop;
  if (!checkWaterfallTasks(tasks, callback)) {
    return;
  }
  var done, called, sync;
  var completed = 0;
  var size = tasks.length;
  var func = tasks[completed];
  var args = [];
  iterate();

  function iterate() {
    called = false;
    switch (args.length) {
      case 0:
      case 1:
        return func(next);
      case 2:
        return func(args[1], next);
      case 3:
        return func(args[1], args[2], next);
      case 4:
        return func(args[1], args[2], args[3], next);
      case 5:
        return func(args[1], args[2], args[3], args[4], next);
      case 6:
        return func(args[1], args[2], args[3], args[4], args[5], next);
      default:
        args = slice(args, 1);
        args.push(next);
        return func.apply(null, args);
    }
  }

  function next(err, res) {
    if (called) {
      throwError();
    }
    called = true;
    if (err) {
      done = callback;
      callback = throwError;
      done(err);
      return;
    }
    if (++completed === size) {
      done = callback;
      callback = throwError;
      if (arguments.length &#x3c;= 2) {
        done(err, res);
      } else {
        done.apply(null, createArray(arguments));
      }
      return;
    }
    args = arguments;
    func = tasks[completed] || throwError;
    if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *   function(arg1, next) {
 *     setTimeout(function() {
 *       order.push(4);
 *       next(null, 1, 2, 3, 4);
 *     }, 40);
 *   }
 * ];
 * async.<span class="apidocCodeKeywordSpan">waterfall</span>(tasks, function(err, arg1, arg2, arg3, arg4) {
 *   console.log(arg1, arg2, arg3, arg4); // 1 2 3 4
 * });
 *
 */
function waterfall(tasks, callback) {
  callback = callback || noop;
  if (!checkWaterfallTasks(tasks, callback)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.whilst" id="apidoc.element.neo-async.async.whilst">
        function <span class="apidocSignatureSpan">neo-async.async.</span>whilst
        <span class="apidocSignatureSpan">(test, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function whilst(test, iterator, callback) {
  callback = callback || noop;
  var sync = false;
  if (test()) {
    iterate();
  } else {
    callback(null);
  }

  function iterate() {
    if (sync) {
      nextTick(next);
    } else {
      sync = true;
      iterator(done);
    }
    sync = false;
  }

  function next() {
    iterator(done);
  }

  function done(err, arg) {
    if (err) {
      return callback(err);
    }
    if (arguments.length &#x3c;= 2) {
      if (test(arg)) {
        iterate();
      } else {
        callback(null, arg);
      }
      return;
    }
    arg = slice(arguments, 1);
    if (test.apply(null, arg)) {
      iterate();
    } else {
      callback.apply(null, [null].concat(arg));
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.async.wrapSync" id="apidoc.element.neo-async.async.wrapSync">
        function <span class="apidocSignatureSpan">neo-async.async.</span>wrapSync
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asyncify(fn) {
  return function( /* args..., callback */ ) {
    var args = createArray(arguments);
    var callback = args.pop();
    var result;
    try {
      result = fn.apply(this, args);
    } catch (e) {
      return callback(e);
    }
    if (result &#x26;&#x26; typeof result === obj &#x26;&#x26; typeof result.then === func) {
      result.then(function(value) {
        callback(null, value);
      }, function(err) {
        callback(err.message ? err : new Error(err));
      });
    } else {
      callback(null, result);
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.neo-async.default" id="apidoc.module.neo-async.default">module neo-async.default</a></h1>


    <h2>
        <a href="#apidoc.element.neo-async.default.all" id="apidoc.element.neo-async.default.all">
        function <span class="apidocSignatureSpan">neo-async.default.</span>all
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function every(collection, iterator, callback) {
  callback = callback || noop;
  deny(collection, iterator, done);

  function done(err, res) {
    if (err) {
      return callback(err);
    }
    callback(null, !res);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.allLimit" id="apidoc.element.neo-async.default.allLimit">
        function <span class="apidocSignatureSpan">neo-async.default.</span>allLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function everyLimit(collection, limit, iterator, callback) {
  callback = callback || noop;
  denyLimit(collection, limit, iterator, done);

  function done(err, res) {
    if (err) {
      return callback(err);
    }
    callback(null, !res);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.allSeries" id="apidoc.element.neo-async.default.allSeries">
        function <span class="apidocSignatureSpan">neo-async.default.</span>allSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function everySeries(collection, iterator, callback) {
  callback = callback || noop;
  denySeries(collection, iterator, done);

  function done(err, res) {
    if (err) {
      return callback(err);
    }
    callback(null, !res);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.angelFall" id="apidoc.element.neo-async.default.angelFall">
        function <span class="apidocSignatureSpan">neo-async.default.</span>angelFall
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function angelFall(tasks, callback) {
  callback = callback || noop;
  if (!checkWaterfallTasks(tasks, callback)) {
    return;
  }
  var completed = 0;
  var sync = false;
  var size = tasks.length;
  var func = tasks[completed];
  var args = [];
  var iterate = function() {
    switch (func.length) {
      case 0:
        try {
          next(null, func());
        } catch (e) {
          next(e);
        }
        return;
      case 1:
        return func(next);
      case 2:
        return func(args[1], next);
      case 3:
        return func(args[1], args[2], next);
      case 4:
        return func(args[1], args[2], args[3], next);
      case 5:
        return func(args[1], args[2], args[3], args[4], next);
      default:
        args = slice(args, 1);
        args[func.length - 1] = next;
        return func.apply(null, args);
    }
  };
  iterate();

  function next(err, res) {
    if (err) {
      iterate = throwError;
      callback = onlyOnce(callback);
      callback(err);
      return;
    }
    if (++completed === size) {
      iterate = throwError;
      var done = callback;
      callback = throwError;
      if (arguments.length === 2) {
        done(err, res);
      } else {
        done.apply(null, createArray(arguments));
      }
      return;
    }
    func = tasks[completed];
    args = arguments;
    if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *   function(arg1, empty1, empty2, empty3, next) {
 *     setTimeout(function() {
 *       order.push(4);
 *       next(null, 1, 2, 3, 4);
 *     }, 40);
 *   }
 * ];
 * async.<span class="apidocCodeKeywordSpan">angelFall</span>(tasks, function(err, arg1, arg2, arg3, arg4) {
 *   console.log(arg1, arg2, arg3, arg4); // 1 2 3 4
 * });
 *
 */
function angelFall(tasks, callback) {
  callback = callback || noop;
  if (!checkWaterfallTasks(tasks, callback)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.angelfall" id="apidoc.element.neo-async.default.angelfall">
        function <span class="apidocSignatureSpan">neo-async.default.</span>angelfall
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function angelFall(tasks, callback) {
  callback = callback || noop;
  if (!checkWaterfallTasks(tasks, callback)) {
    return;
  }
  var completed = 0;
  var sync = false;
  var size = tasks.length;
  var func = tasks[completed];
  var args = [];
  var iterate = function() {
    switch (func.length) {
      case 0:
        try {
          next(null, func());
        } catch (e) {
          next(e);
        }
        return;
      case 1:
        return func(next);
      case 2:
        return func(args[1], next);
      case 3:
        return func(args[1], args[2], next);
      case 4:
        return func(args[1], args[2], args[3], next);
      case 5:
        return func(args[1], args[2], args[3], args[4], next);
      default:
        args = slice(args, 1);
        args[func.length - 1] = next;
        return func.apply(null, args);
    }
  };
  iterate();

  function next(err, res) {
    if (err) {
      iterate = throwError;
      callback = onlyOnce(callback);
      callback(err);
      return;
    }
    if (++completed === size) {
      iterate = throwError;
      var done = callback;
      callback = throwError;
      if (arguments.length === 2) {
        done(err, res);
      } else {
        done.apply(null, createArray(arguments));
      }
      return;
    }
    func = tasks[completed];
    args = arguments;
    if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.any" id="apidoc.element.neo-async.default.any">
        function <span class="apidocSignatureSpan">neo-async.default.</span>any
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function some(collection, iterator, callback) {
  callback = callback || noop;
  detect(collection, iterator, done);

  function done(err, res) {
    if (err) {
      return callback(err);
    }
    callback(null, !!res);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.anyLimit" id="apidoc.element.neo-async.default.anyLimit">
        function <span class="apidocSignatureSpan">neo-async.default.</span>anyLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function someLimit(collection, limit, iterator, callback) {
  callback = callback || noop;
  detectLimit(collection, limit, iterator, done);

  function done(err, res) {
    if (err) {
      return callback(err);
    }
    callback(null, !!res);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.anySeries" id="apidoc.element.neo-async.default.anySeries">
        function <span class="apidocSignatureSpan">neo-async.default.</span>anySeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function someSeries(collection, iterator, callback) {
  callback = callback || noop;
  detectSeries(collection, iterator, done);

  function done(err, res) {
    if (err) {
      return callback(err);
    }
    callback(null, !!res);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.apply" id="apidoc.element.neo-async.default.apply">
        function <span class="apidocSignatureSpan">neo-async.default.</span>apply
        <span class="apidocSignatureSpan">(func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function apply(func) {
  switch (arguments.length) {
    case 0:
    case 1:
      return func;
    case 2:
      return func.bind(null, arguments[1]);
    case 3:
      return func.bind(null, arguments[1], arguments[2]);
    case 4:
      return func.bind(null, arguments[1], arguments[2], arguments[3]);
    case 5:
      return func.bind(null, arguments[1], arguments[2], arguments[3], arguments[4]);
    default:
      var size = arguments.length;
      var index = 0;
      var args = Array(size);
      args[index] = null;
      while (++index &#x3c; size) {
        args[index] = arguments[index];
      }
      return func.bind.apply(func, args);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * @private
 */
function createImmediate(safeMode) {
  var delay = function delay(fn) {
    var args = slice(arguments, 1);
    setTimeout(function() {
      fn.<span class="apidocCodeKeywordSpan">apply</span>(null, args);
    });
  };
  asyncSetImmediate = typeof setImmediate === func ? setImmediate : delay;
  if (typeof process === obj &#x26;&#x26; typeof process.nextTick === func) {
    nextTick = /^v0.10/.test(process.version) ? asyncSetImmediate : process.nextTick;
    asyncNextTick = /^v0/.test(process.version) ? asyncSetImmediate : process.nextTick;
  } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.applyEach" id="apidoc.element.neo-async.default.applyEach">
        function <span class="apidocSignatureSpan">neo-async.default.</span>applyEach
        <span class="apidocSignatureSpan">(fns)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function applyEach(fns) {

  var go = function() {
    var self = this;
    var args = createArray(arguments);
    var callback = args.pop() || noop;
    return func(fns, iterator, callback);

    function iterator(fn, done) {
      fn.apply(self, args.concat([done]));
    }
  };
  if (arguments.length &#x3e; 1) {
    var args = slice(arguments, 1);
    return go.apply(this, args);
  } else {
    return go;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.applyEachSeries" id="apidoc.element.neo-async.default.applyEachSeries">
        function <span class="apidocSignatureSpan">neo-async.default.</span>applyEachSeries
        <span class="apidocSignatureSpan">(fns)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function applyEach(fns) {

  var go = function() {
    var self = this;
    var args = createArray(arguments);
    var callback = args.pop() || noop;
    return func(fns, iterator, callback);

    function iterator(fn, done) {
      fn.apply(self, args.concat([done]));
    }
  };
  if (arguments.length &#x3e; 1) {
    var args = slice(arguments, 1);
    return go.apply(this, args);
  } else {
    return go;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.asyncify" id="apidoc.element.neo-async.default.asyncify">
        function <span class="apidocSignatureSpan">neo-async.default.</span>asyncify
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asyncify(fn) {
  return function( /* args..., callback */ ) {
    var args = createArray(arguments);
    var callback = args.pop();
    var result;
    try {
      result = fn.apply(this, args);
    } catch (e) {
      return callback(e);
    }
    if (result &#x26;&#x26; typeof result === obj &#x26;&#x26; typeof result.then === func) {
      result.then(function(value) {
        callback(null, value);
      }, function(err) {
        callback(err.message ? err : new Error(err));
      });
    } else {
      callback(null, result);
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.auto" id="apidoc.element.neo-async.default.auto">
        function <span class="apidocSignatureSpan">neo-async.default.</span>auto
        <span class="apidocSignatureSpan">(tasks, concurrency, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function auto(tasks, concurrency, callback) {
  if (typeof concurrency === func) {
    callback = concurrency;
    concurrency = null;
  }
  var keys = nativeKeys(tasks);
  var rest = keys.length;
  var results = {};
  if (rest === 0) {
    return callback(null, results);
  }
  var runningTasks = 0;
  var readyTasks = [];
  var listeners = {};
  callback = onlyOnce(callback || noop);
  concurrency = concurrency || rest;

  baseEachSync(tasks, iterator, keys);
  proceedQueue();

  function iterator(task, key) {
    // no dependencies
    var _task, _taskSize;
    if (!isArray(task)) {
      _task = task;
      _taskSize = 0;
      readyTasks.push([_task, _taskSize, done]);
      return;
    }
    var dependencySize = task.length - 1;
    _task = task[dependencySize];
    _taskSize = dependencySize;
    if (dependencySize === 0) {
      readyTasks.push([_task, _taskSize, done]);
      return;
    }
    // dependencies
    var index = -1;
    while (++index &#x3c; dependencySize) {
      var dependencyName = task[index];
      if (notInclude(keys, dependencyName)) {
        var msg = &#x27;async.auto task `&#x27; + dependencyName + &#x27;` has non-existent dependency in &#x27; + task.join(&#x27;, &#x27;);
        throw new Error(msg);
      }
      var taskListeners = listeners[dependencyName];
      if (!taskListeners) {
        taskListeners = listeners[dependencyName] = [];
      }
      taskListeners.push(taskListener);
    }

    function done(err, arg) {
      if (key === null) {
        throwError();
      }
      runningTasks--;
      rest--;
      arg = arguments.length &#x3c;= 2 ? arg : slice(arguments, 1);
      if (err) {
        var safeResults = objectClone(results);
        safeResults[key] = arg;
        key = null;
        var _callback = callback;
        callback = noop;
        _callback(err, safeResults);
        return;
      }
      results[key] = arg;
      taskComplete(key);
      key = null;
    }

    function taskListener() {
      if (--dependencySize === 0) {
        readyTasks.push([_task, _taskSize, done]);
      }
    }
  }

  function proceedQueue() {
    if (readyTasks.length === 0 &#x26;&#x26; runningTasks === 0) {
      if (rest !== 0) {
        throw new Error(&#x27;async.auto task has cyclic dependencies&#x27;);
      }
      return callback(null, results);
    }
    while (readyTasks.length &#x26;&#x26; runningTasks &#x3c; concurrency &#x26;&#x26; callback !== noop) {
      runningTasks++;
      var array = readyTasks.shift();
      if (array[1] === 0) {
        array[0](array[2]);
      } else {
        array[0](results, array[2]);
      }
    }
  }

  function taskComplete(key) {
    var taskListeners = listeners[key] || [];
    arrayEachSync(taskListeners, function(task) {
      task();
    });
    proceedQueue();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.autoInject" id="apidoc.element.neo-async.default.autoInject">
        function <span class="apidocSignatureSpan">neo-async.default.</span>autoInject
        <span class="apidocSignatureSpan">(tasks, concurrency, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function autoInject(tasks, concurrency, callback) {
  var newTasks = {};
  baseEachSync(tasks, iterator, nativeKeys(tasks));
  auto(newTasks, concurrency, callback);

  function iterator(task, key) {
    var params;
    var taskLength = task.length;

    if (isArray(task)) {
      if (taskLength === 0) {
        throw new Error(&#x27;autoInject task functions require explicit parameters.&#x27;);
      }
      params = createArray(task);
      taskLength = params.length - 1;
      task = params[taskLength];
      if (taskLength === 0) {
        newTasks[key] = task;
        return;
      }
    } else if (taskLength === 1) {
      newTasks[key] = task;
      return;
    } else {
      params = parseParams(task);
      if (taskLength === 0 &#x26;&#x26; params.length === 0) {
        throw new Error(&#x27;autoInject task functions require explicit parameters.&#x27;);
      }
      taskLength = params.length - 1;
    }
    params[taskLength] = newTask;
    newTasks[key] = params;

    function newTask(results, done) {
      switch (taskLength) {
        case 1:
          task(results[params[0]], done);
          break;
        case 2:
          task(results[params[0]], results[params[1]], done);
          break;
        case 3:
          task(results[params[0]], results[params[1]], results[params[2]], done);
          break;
        default:
          var i = -1;
          while(++i &#x3c; taskLength) {
            params[i] = results[params[i]];
          }
          params[i] = done;
          task.apply(null, params);
          break;
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.cargo" id="apidoc.element.neo-async.default.cargo">
        function <span class="apidocSignatureSpan">neo-async.default.</span>cargo
        <span class="apidocSignatureSpan">(worker, payload)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cargo(worker, payload) {
  return baseQueue(false, worker, 1, payload);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.compose" id="apidoc.element.neo-async.default.compose">
        function <span class="apidocSignatureSpan">neo-async.default.</span>compose
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compose() {
  return seq.apply(null, reverse(arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.concat" id="apidoc.element.neo-async.default.concat">
        function <span class="apidocSignatureSpan">neo-async.default.</span>concat
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function concat(collection, iterator, callback) {
  callback = callback || noop;
  var size;
  var completed = 0;
  var result = [];

  if (isArray(collection)) {
    size = collection.length;
    arrayEach(collection, iterator, done);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    symbolEach(collection, iterator, done);
  } else if (typeof collection === obj) {
    var keys = nativeKeys(collection);
    size = keys.length;
    baseEach(collection, iterator, done, keys);
  }
  if (!size) {
    callback(null, result);
  }

  function done(err, array) {
    if (array) {
      Array.prototype.push.apply(result, isArray(array) ? array : [array]);
    }
    if (err) {
      callback = once(callback);
      callback(err, createArray(result));
    } else if (++completed === size) {
      callback(null, result);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, [num]);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">concat</span>(array, iterator, function(err, res) {
*   console.log(res); // [1, 2, 3];
*   console.log(order); // [1, 2, 3]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.concatLimit" id="apidoc.element.neo-async.default.concatLimit">
        function <span class="apidocSignatureSpan">neo-async.default.</span>concatLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function concatLimit(collection, limit, iterator, callback) {
  callback = callback || noop;
  var result = [];
  var size, index, key, iter, item, iterate;
  var sync = false;
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    var keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null, result);
  }
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    if (started &#x3c; size) {
      iterator(collection[started++], onlyOnce(done));
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      iterator(collection[index], index, onlyOnce(done));
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      iterator(item.value, onlyOnce(done));
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      iterator(item.value, started++, onlyOnce(done));
    }
  }

  function objectIterator() {
    if (started &#x3c; size) {
      iterator(collection[keys[started++]], onlyOnce(done));
    }
  }

  function objectIteratorWithKey() {
    if (started &#x3c; size) {
      key = keys[started++];
      iterator(collection[key], key, onlyOnce(done));
    }
  }

  function done(err, array) {
    if (array) {
      Array.prototype.push.apply(result, isArray(array) ? array : [array]);
    }
    if (err) {
      iterate = noop;
      callback = once(callback);
      callback(err, result);
    } else if (++completed === size) {
      iterate = throwError;
      callback = onlyOnce(callback);
      callback(null, result);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 5, 3, 4, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, [num]);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">concatLimit</span>(array, 2, iterator, function(err, res) {
*   console.log(res); // [1, 3, 5, 2, 4]
*   console.log(order); // [1, 3, 5, 2, 4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.concatSeries" id="apidoc.element.neo-async.default.concatSeries">
        function <span class="apidocSignatureSpan">neo-async.default.</span>concatSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function concatSeries(collection, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, keys, iter, values, iterate;
  var sync = false;
  var result = [];
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null, result);
  }
  iterate();

  function arrayIterator() {
    iterator(collection[completed], done);
  }

  function arrayIteratorWithIndex() {
    iterator(collection[completed], completed, done);
  }

  function symbolIterator() {
    iterator(iter.next().value, done);
  }

  function symbolIteratorWithKey() {
    values = iter.next().value;
    iterator(values, completed, done);
  }

  function objectIterator() {
    iterator(collection[keys[completed]], done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    iterator(collection[key], key, done);
  }

  function done(err, array) {
    if (array) {
      Array.prototype.push.apply(result, isArray(array) ? array : [array]);
    }
    if (err) {
      callback(err, result);
    } else if (++completed === size) {
      iterate = throwError;
      callback(null, result);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, [num]);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">concatSeries</span>(array, iterator, function(err, res) {
*   console.log(res); // [1, 3, 2];
*   console.log(order); // [1, 3, 2]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.constant" id="apidoc.element.neo-async.default.constant">
        function <span class="apidocSignatureSpan">neo-async.default.</span>constant
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function constant() {
  var args = [null].concat(createArray(arguments));
  return function(callback) {
    callback = arguments[arguments.length - 1];
    callback.apply(this, args);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.createLogger" id="apidoc.element.neo-async.default.createLogger">
        function <span class="apidocSignatureSpan">neo-async.default.</span>createLogger
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createLogger(name) {
  return function(fn) {
    var args = slice(arguments, 1);
    args.push(done);
    fn.apply(null, args);
  };

  function done(err) {
    if (typeof console === obj) {
      if (err) {
        if (console.error) {
          console.error(err);
        }
        return;
      }
      if (console[name]) {
        var args = slice(arguments, 1);
        arrayEachSync(args, function(arg) {
          console[name](arg);
        });
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.detect" id="apidoc.element.neo-async.default.detect">
        function <span class="apidocSignatureSpan">neo-async.default.</span>detect
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (collection, iterator, callback) {
  callback = callback || noop;
  var size, keys;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    arrayEach(collection, iterator, createCallback);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    symbolEach(collection, iterator, createCallback);
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    baseEach(collection, iterator, createCallback, keys);
  }
  if (!size) {
    callback(null);
  }

  function createCallback(value) {
    var called = false;
    return function done(err, res) {
      if (called) {
        throwError();
      }
      called = true;
      if (err) {
        callback = once(callback);
        callback(err);
      } else if (!!res === bool) {
        callback = once(callback);
        callback(null, value);
      } else if (++completed === size) {
        callback(null);
      }
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">detect</span>(array, iterator, function(err, res) {
*   console.log(res); // 1
*   console.log(order); // [1]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.detectLimit" id="apidoc.element.neo-async.default.detectLimit">
        function <span class="apidocSignatureSpan">neo-async.default.</span>detectLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detectLimit = function (collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, value, keys, iter, item, iterate;
  var sync = false;
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null);
  }
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, createCallback(value));
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, index, createCallback(value));
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, createCallback(value));
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, started++, createCallback(value));
    }
  }

  function objectIterator() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[keys[index]];
      iterator(value, createCallback(value));
    }
  }

  function objectIteratorWithKey() {
    if (started &#x3c; size) {
      key = keys[started++];
      value = collection[key];
      iterator(value, key, createCallback(value));
    }
  }

  function createCallback(value) {
    var called = false;
    return function(err, res) {
      if (called) {
        throwError();
      }
      called = true;
      if (err) {
        iterate = noop;
        callback = once(callback);
        callback(err);
      } else if (!!res === bool) {
        iterate = noop;
        callback = once(callback);
        callback(null, value);
      } else if (++completed === size) {
        callback(null);
      } else if (sync) {
        nextTick(iterate);
      } else {
        sync = true;
        iterate();
      }
      sync = false;
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 5, 3, 4, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">detectLimit</span>(array, 2, iterator, function(err, res) {
*   console.log(res); // 1
*   console.log(order); // [1]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.detectSeries" id="apidoc.element.neo-async.default.detectSeries">
        function <span class="apidocSignatureSpan">neo-async.default.</span>detectSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detectSeries = function (collection, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, value, keys, iter, iterate;
  var sync = false;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null);
  }
  iterate();

  function arrayIterator() {
    value = collection[completed];
    iterator(value, done);
  }

  function arrayIteratorWithIndex() {
    value = collection[completed];
    iterator(value, completed, done);
  }

  function symbolIterator() {
    value = iter.next().value;
    iterator(value, done);
  }

  function symbolIteratorWithKey() {
    value = iter.next().value;
    iterator(value, completed, done);
  }

  function objectIterator() {
    value = collection[keys[completed]];
    iterator(value, done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    value = collection[key];
    iterator(value, key, done);
  }

  function done(err, res) {
    if (err) {
      callback(err);
    } else if (!!res === bool) {
      iterate = throwError;
      callback(null, value);
    } else if (++completed === size) {
      iterate = throwError;
      callback(null);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">detectSeries</span>(array, iterator, function(err, res) {
*   console.log(res); // 1
*   console.log(order); // [1]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.dir" id="apidoc.element.neo-async.default.dir">
        function <span class="apidocSignatureSpan">neo-async.default.</span>dir
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dir = function (fn) {
  var args = slice(arguments, 1);
  args.push(done);
  fn.apply(null, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.doDuring" id="apidoc.element.neo-async.default.doDuring">
        function <span class="apidocSignatureSpan">neo-async.default.</span>doDuring
        <span class="apidocSignatureSpan">(iterator, test, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doDuring(iterator, test, callback) {
  callback = callback || noop;
  iterate(null, true);

  function iterate(err, truth) {
    if (err) {
      return callback(err);
    }
    if (truth) {
      iterator(done);
    } else {
      callback(null);
    }
  }

  function done(err, res) {
    if (err) {
      return callback(err);
    }
    switch (arguments.length) {
      case 0:
      case 1:
        test(iterate);
        break;
      case 2:
        test(res, iterate);
        break;
      default:
        var args = slice(arguments, 1);
        args.push(iterate);
        test.apply(null, args);
        break;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.doUntil" id="apidoc.element.neo-async.default.doUntil">
        function <span class="apidocSignatureSpan">neo-async.default.</span>doUntil
        <span class="apidocSignatureSpan">(iterator, test, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doUntil(iterator, test, callback) {
  callback = callback || noop;
  var sync = false;
  next();

  function iterate() {
    if (sync) {
      nextTick(next);
    } else {
      sync = true;
      iterator(done);
    }
    sync = false;
  }

  function next() {
    iterator(done);
  }

  function done(err, arg) {
    if (err) {
      return callback(err);
    }
    if (arguments.length &#x3c;= 2) {
      if (!test(arg)) {
        iterate();
      } else {
        callback(null, arg);
      }
      return;
    }
    arg = slice(arguments, 1);
    if (!test.apply(null, arg)) {
      iterate();
    } else {
      callback.apply(null, [null].concat(arg));
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.doWhilst" id="apidoc.element.neo-async.default.doWhilst">
        function <span class="apidocSignatureSpan">neo-async.default.</span>doWhilst
        <span class="apidocSignatureSpan">(iterator, test, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doWhilst(iterator, test, callback) {
  callback = callback || noop;
  var sync = false;
  next();

  function iterate() {
    if (sync) {
      nextTick(next);
    } else {
      sync = true;
      iterator(done);
    }
    sync = false;
  }

  function next() {
    iterator(done);
  }

  function done(err, arg) {
    if (err) {
      return callback(err);
    }
    if (arguments.length &#x3c;= 2) {
      if (test(arg)) {
        iterate();
      } else {
        callback(null, arg);
      }
      return;
    }
    arg = slice(arguments, 1);
    if (test.apply(null, arg)) {
      iterate();
    } else {
      callback.apply(null, [null].concat(arg));
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.during" id="apidoc.element.neo-async.default.during">
        function <span class="apidocSignatureSpan">neo-async.default.</span>during
        <span class="apidocSignatureSpan">(test, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function during(test, iterator, callback) {
  callback = callback || noop;
  _test();

  function _test() {
    test(iterate);
  }

  function iterate(err, truth) {
    if (err) {
      return callback(err);
    }
    if (truth) {
      iterator(done);
    } else {
      callback(null);
    }
  }

  function done(err) {
    if (err) {
      return callback(err);
    }
    _test();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.each" id="apidoc.element.neo-async.default.each">
        function <span class="apidocSignatureSpan">neo-async.default.</span>each
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function each(collection, iterator, callback) {
  callback = callback || noop;
  var size, keys;
  var completed = 0;
  if (isArray(collection)) {
    size = collection.length;
    arrayEach(collection, iterator, done);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    symbolEach(collection, iterator, done);
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    baseEach(collection, iterator, done, keys);
  }
  if (!size) {
    callback(null);
  }

  function done(err, bool) {
    if (err) {
      callback = once(callback);
      callback(err);
    } else if (++completed === size) {
      callback(null);
    } else if (bool === false) {
      callback = once(callback);
      callback(null);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done();
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">each</span>(array, iterator, function(err, res) {
*   console.log(res); // undefined
*   console.log(order); // [1, 2, 3]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.eachLimit" id="apidoc.element.neo-async.default.eachLimit">
        function <span class="apidocSignatureSpan">neo-async.default.</span>eachLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachLimit(collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, keys, iter, item, iterate;
  var sync = false;
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  } else {
    return callback(null);
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null);
  }
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    if (started &#x3c; size) {
      iterator(collection[started++], done);
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      iterator(collection[index], index, done);
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      iterator(item.value, done);
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      iterator(item.value, started++, done);
    }
  }

  function objectIterator() {
    if (started &#x3c; size) {
      iterator(collection[keys[started++]], done);
    }
  }

  function objectIteratorWithKey() {
    index = started++;
    if (index &#x3c; size) {
      key = keys[index];
      iterator(collection[key], key, done);
    }
  }

  function done(err, bool) {
    if (err) {
      iterate = noop;
      callback = once(callback);
      callback(err);
    } else if (++completed === size) {
      iterate = throwError;
      callback = onlyOnce(callback);
      callback(null);
    } else if (bool === false) {
      iterate = noop;
      callback = once(callback);
      callback(null);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 5, 3, 4, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done();
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">eachLimit</span>(array, 2, iterator, function(err, res) {
*   console.log(res); // undefined
*   console.log(order); // [1, 3, 5, 2, 4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.eachOf" id="apidoc.element.neo-async.default.eachOf">
        function <span class="apidocSignatureSpan">neo-async.default.</span>eachOf
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function each(collection, iterator, callback) {
  callback = callback || noop;
  var size, keys;
  var completed = 0;
  if (isArray(collection)) {
    size = collection.length;
    arrayEach(collection, iterator, done);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    symbolEach(collection, iterator, done);
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    baseEach(collection, iterator, done, keys);
  }
  if (!size) {
    callback(null);
  }

  function done(err, bool) {
    if (err) {
      callback = once(callback);
      callback(err);
    } else if (++completed === size) {
      callback(null);
    } else if (bool === false) {
      callback = once(callback);
      callback(null);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.eachOfLimit" id="apidoc.element.neo-async.default.eachOfLimit">
        function <span class="apidocSignatureSpan">neo-async.default.</span>eachOfLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachLimit(collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, keys, iter, item, iterate;
  var sync = false;
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  } else {
    return callback(null);
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null);
  }
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    if (started &#x3c; size) {
      iterator(collection[started++], done);
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      iterator(collection[index], index, done);
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      iterator(item.value, done);
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      iterator(item.value, started++, done);
    }
  }

  function objectIterator() {
    if (started &#x3c; size) {
      iterator(collection[keys[started++]], done);
    }
  }

  function objectIteratorWithKey() {
    index = started++;
    if (index &#x3c; size) {
      key = keys[index];
      iterator(collection[key], key, done);
    }
  }

  function done(err, bool) {
    if (err) {
      iterate = noop;
      callback = once(callback);
      callback(err);
    } else if (++completed === size) {
      iterate = throwError;
      callback = onlyOnce(callback);
      callback(null);
    } else if (bool === false) {
      iterate = noop;
      callback = once(callback);
      callback(null);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.eachOfSeries" id="apidoc.element.neo-async.default.eachOfSeries">
        function <span class="apidocSignatureSpan">neo-async.default.</span>eachOfSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachSeries(collection, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, keys, iter, value, iterate;
  var sync = false;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null);
  }
  iterate();

  function arrayIterator() {
    iterator(collection[completed], done);
  }

  function arrayIteratorWithIndex() {
    iterator(collection[completed], completed, done);
  }

  function symbolIterator() {
    iterator(iter.next().value, done);
  }

  function symbolIteratorWithKey() {
    value = iter.next().value;
    iterator(value, completed, done);
  }

  function objectIterator() {
    iterator(collection[keys[completed]], done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    iterator(collection[key], key, done);
  }

  function done(err, bool) {
    if (err) {
      callback(err);
    } else if (++completed === size) {
      iterate = throwError;
      callback(null);
    } else if (bool === false) {
      iterate = throwError;
      callback(null);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.eachSeries" id="apidoc.element.neo-async.default.eachSeries">
        function <span class="apidocSignatureSpan">neo-async.default.</span>eachSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachSeries(collection, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, keys, iter, value, iterate;
  var sync = false;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null);
  }
  iterate();

  function arrayIterator() {
    iterator(collection[completed], done);
  }

  function arrayIteratorWithIndex() {
    iterator(collection[completed], completed, done);
  }

  function symbolIterator() {
    iterator(iter.next().value, done);
  }

  function symbolIteratorWithKey() {
    value = iter.next().value;
    iterator(value, completed, done);
  }

  function objectIterator() {
    iterator(collection[keys[completed]], done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    iterator(collection[key], key, done);
  }

  function done(err, bool) {
    if (err) {
      callback(err);
    } else if (++completed === size) {
      iterate = throwError;
      callback(null);
    } else if (bool === false) {
      iterate = throwError;
      callback(null);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done();
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">eachSeries</span>(array, iterator, function(err, res) {
*   console.log(res); // undefined
*   console.log(order); // [1, 3, 2]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.ensureAsync" id="apidoc.element.neo-async.default.ensureAsync">
        function <span class="apidocSignatureSpan">neo-async.default.</span>ensureAsync
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ensureAsync(fn) {
  return function( /* ...args, callback */ ) {
    var args = createArray(arguments);
    var lastIndex = args.length - 1;
    var callback = args[lastIndex];
    var sync = true;
    args[lastIndex] = done;
    fn.apply(this, args);
    sync = false;

    function done() {
      var innerArgs = createArray(arguments);
      if (sync) {
        nextTick(function() {
          callback.apply(null, innerArgs);
        });
      } else {
        callback.apply(null, innerArgs);
      }
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.every" id="apidoc.element.neo-async.default.every">
        function <span class="apidocSignatureSpan">neo-async.default.</span>every
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function every(collection, iterator, callback) {
  callback = callback || noop;
  deny(collection, iterator, done);

  function done(err, res) {
    if (err) {
      return callback(err);
    }
    callback(null, !res);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">every</span>(array, iterator, function(err, res) {
*   console.log(res); // false
*   console.log(order); // [1, 2]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.everyLimit" id="apidoc.element.neo-async.default.everyLimit">
        function <span class="apidocSignatureSpan">neo-async.default.</span>everyLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function everyLimit(collection, limit, iterator, callback) {
  callback = callback || noop;
  denyLimit(collection, limit, iterator, done);

  function done(err, res) {
    if (err) {
      return callback(err);
    }
    callback(null, !res);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 5, 3, 4, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">everyLimit</span>(array, 2, iterator, function(err, res) {
*   console.log(res); // false
*   console.log(order); // [1, 3, 5, 2]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.everySeries" id="apidoc.element.neo-async.default.everySeries">
        function <span class="apidocSignatureSpan">neo-async.default.</span>everySeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function everySeries(collection, iterator, callback) {
  callback = callback || noop;
  denySeries(collection, iterator, done);

  function done(err, res) {
    if (err) {
      return callback(err);
    }
    callback(null, !res);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">everySeries</span>(array, iterator, function(err, res) {
*   console.log(res); // false
*   console.log(order); // [1, 3, 2]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.fast" id="apidoc.element.neo-async.default.fast">
        function <span class="apidocSignatureSpan">neo-async.default.</span>fast
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fast() {
  createImmediate(false);
  return exports;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.filter" id="apidoc.element.neo-async.default.filter">
        function <span class="apidocSignatureSpan">neo-async.default.</span>filter
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filter = function (collection, iterator, callback) {
  callback = callback || noop;
  var size, keys, result;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    result = Array(size);
    arrayEach(collection, iterator, createCallback);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    result = Array(size);
    symbolEach(collection, iterator, createCallback);
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    result = Array(size);
    baseEach(collection, iterator, createCallback, keys);
  }
  if (!size) {
    return callback(null, []);
  }

  function createCallback(index, value) {
    return function done(err, res) {
      if (index === null) {
        throwError();
      }
      if (err) {
        index = null;
        callback = once(callback);
        callback(err);
        return;
      }
      if (!!res === bool) {
        result[index] = value;
      }
      index = null;
      if (++completed === size) {
        callback(null, compact(result));
      }
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">filter</span>(array, iterator, function(err, res) {
*   console.log(res); // [1, 3];
*   console.log(order); // [1, 2, 3]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.filterLimit" id="apidoc.element.neo-async.default.filterLimit">
        function <span class="apidocSignatureSpan">neo-async.default.</span>filterLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filterLimit = function (collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, value, keys, iter, item, iterate, result;
  var sync = false;
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null, []);
  }
  result = Array(size);
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, createCallback(value, index));
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, index, createCallback(value, index));
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, createCallback(value, started++));
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, started, createCallback(value, started++));
    }
  }

  function objectIterator() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[keys[index]];
      iterator(value, createCallback(value, index));
    }
  }

  function objectIteratorWithKey() {
    index = started++;
    if (index &#x3c; size) {
      key = keys[index];
      value = collection[key];
      iterator(value, key, createCallback(value, index));
    }
  }

  function createCallback(value, index) {
    return function(err, res) {
      if (index === null) {
        throwError();
      }
      if (err) {
        index = null;
        iterate = noop;
        callback = once(callback);
        callback(err);
        return;
      }
      if (!!res === bool) {
        result[index] = value;
      }
      index = null;
      if (++completed === size) {
        callback = onlyOnce(callback);
        callback(null, compact(result));
      } else if (sync) {
        nextTick(iterate);
      } else {
        sync = true;
        iterate();
      }
      sync = false;
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 5, 3, 4, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">filterLimit</span>(array, 2, iterator, function(err, res) {
*   console.log(res); // [1, 5, 3]
*   console.log(order); // [1, 3, 5, 2, 4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.filterSeries" id="apidoc.element.neo-async.default.filterSeries">
        function <span class="apidocSignatureSpan">neo-async.default.</span>filterSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filterSeries = function (collection, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, value, keys, iter, iterate;
  var sync = false;
  var completed = 0;
  var result = [];

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null, []);
  }
  iterate();

  function arrayIterator() {
    value = collection[completed];
    iterator(value, done);
  }

  function arrayIteratorWithIndex() {
    value = collection[completed];
    iterator(value, completed, done);
  }

  function symbolIterator() {
    value = iter.next().value;
    iterator(value, done);
  }

  function symbolIteratorWithKey() {
    value = iter.next().value;
    iterator(value, completed, done);
  }

  function objectIterator() {
    key = keys[completed];
    value = collection[key];
    iterator(value, done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    value = collection[key];
    iterator(value, key, done);
  }

  function done(err, res) {
    if (err) {
      callback(err);
      return;
    }
    if (!!res === bool) {
      result[result.length] = value;
    }
    if (++completed === size) {
      iterate = throwError;
      callback(null, result);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">filterSeries</span>(array, iterator, function(err, res) {
*   console.log(res); // [1, 3];
*   console.log(order); // [1, 3, 2]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.find" id="apidoc.element.neo-async.default.find">
        function <span class="apidocSignatureSpan">neo-async.default.</span>find
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">find = function (collection, iterator, callback) {
  callback = callback || noop;
  var size, keys;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    arrayEach(collection, iterator, createCallback);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    symbolEach(collection, iterator, createCallback);
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    baseEach(collection, iterator, createCallback, keys);
  }
  if (!size) {
    callback(null);
  }

  function createCallback(value) {
    var called = false;
    return function done(err, res) {
      if (called) {
        throwError();
      }
      called = true;
      if (err) {
        callback = once(callback);
        callback(err);
      } else if (!!res === bool) {
        callback = once(callback);
        callback(null, value);
      } else if (++completed === size) {
        callback(null);
      }
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.findLimit" id="apidoc.element.neo-async.default.findLimit">
        function <span class="apidocSignatureSpan">neo-async.default.</span>findLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findLimit = function (collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, value, keys, iter, item, iterate;
  var sync = false;
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null);
  }
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, createCallback(value));
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, index, createCallback(value));
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, createCallback(value));
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, started++, createCallback(value));
    }
  }

  function objectIterator() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[keys[index]];
      iterator(value, createCallback(value));
    }
  }

  function objectIteratorWithKey() {
    if (started &#x3c; size) {
      key = keys[started++];
      value = collection[key];
      iterator(value, key, createCallback(value));
    }
  }

  function createCallback(value) {
    var called = false;
    return function(err, res) {
      if (called) {
        throwError();
      }
      called = true;
      if (err) {
        iterate = noop;
        callback = once(callback);
        callback(err);
      } else if (!!res === bool) {
        iterate = noop;
        callback = once(callback);
        callback(null, value);
      } else if (++completed === size) {
        callback(null);
      } else if (sync) {
        nextTick(iterate);
      } else {
        sync = true;
        iterate();
      }
      sync = false;
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.findSeries" id="apidoc.element.neo-async.default.findSeries">
        function <span class="apidocSignatureSpan">neo-async.default.</span>findSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findSeries = function (collection, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, value, keys, iter, iterate;
  var sync = false;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null);
  }
  iterate();

  function arrayIterator() {
    value = collection[completed];
    iterator(value, done);
  }

  function arrayIteratorWithIndex() {
    value = collection[completed];
    iterator(value, completed, done);
  }

  function symbolIterator() {
    value = iter.next().value;
    iterator(value, done);
  }

  function symbolIteratorWithKey() {
    value = iter.next().value;
    iterator(value, completed, done);
  }

  function objectIterator() {
    value = collection[keys[completed]];
    iterator(value, done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    value = collection[key];
    iterator(value, key, done);
  }

  function done(err, res) {
    if (err) {
      callback(err);
    } else if (!!res === bool) {
      iterate = throwError;
      callback(null, value);
    } else if (++completed === size) {
      iterate = throwError;
      callback(null);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.foldl" id="apidoc.element.neo-async.default.foldl">
        function <span class="apidocSignatureSpan">neo-async.default.</span>foldl
        <span class="apidocSignatureSpan">(collection, result, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduce(collection, result, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, keys, iter, iterate;
  var sync = false;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 4 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 4 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 4 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null, result);
  }
  iterate(result);

  function arrayIterator(result) {
    iterator(result, collection[completed], done);
  }

  function arrayIteratorWithIndex(result) {
    iterator(result, collection[completed], completed, done);
  }

  function symbolIterator() {
    iterator(result, iter.next().value, done);
  }

  function symbolIteratorWithKey() {
    iterator(result, iter.next().value, completed, done);
  }

  function objectIterator(result) {
    iterator(result, collection[keys[completed]], done);
  }

  function objectIteratorWithKey(result) {
    key = keys[completed];
    iterator(result, collection[key], key, done);
  }

  function done(err, result) {
    if (err) {
      callback(err, result);
    } else if (++completed === size) {
      iterator = throwError;
      callback(null, result);
    } else if (sync) {
      nextTick(function() {
        iterate(result);
      });
    } else {
      sync = true;
      iterate(result);
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.foldr" id="apidoc.element.neo-async.default.foldr">
        function <span class="apidocSignatureSpan">neo-async.default.</span>foldr
        <span class="apidocSignatureSpan">(collection, result, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduceRight(collection, result, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var resIndex, index, key, keys, iter, item, col, iterate;
  var sync = false;

  if (isArray(collection)) {
    resIndex = collection.length;
    iterate = iterator.length === 4 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    resIndex = collection.size;
    col = Array(resIndex);
    iter = collection[iteratorSymbol]();
    index = -1;
    while ((item = iter.next()).done === false) {
      col[++index] = item.value;
    }
    collection = col;
    iterate = iterator.length === 4 ? arrayIteratorWithIndex : arrayIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    resIndex = keys.length;
    iterate = iterator.length === 4 ? objectIteratorWithKey : objectIterator;
  }
  if (!resIndex) {
    return callback(null, result);
  }
  iterate(result);

  function arrayIterator(result) {
    iterator(result, collection[--resIndex], done);
  }

  function arrayIteratorWithIndex(result) {
    iterator(result, collection[--resIndex], resIndex, done);
  }

  function objectIterator(result) {
    iterator(result, collection[keys[--resIndex]], done);
  }

  function objectIteratorWithKey(result) {
    key = keys[--resIndex];
    iterator(result, collection[key], key, done);
  }

  function done(err, result) {
    if (err) {
      callback(err, result);
    } else if (resIndex === 0) {
      iterate = throwError;
      callback(null, result);
    } else if (sync) {
      nextTick(function() {
        iterate(result);
      });
    } else {
      sync = true;
      iterate(result);
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.forEach" id="apidoc.element.neo-async.default.forEach">
        function <span class="apidocSignatureSpan">neo-async.default.</span>forEach
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function each(collection, iterator, callback) {
  callback = callback || noop;
  var size, keys;
  var completed = 0;
  if (isArray(collection)) {
    size = collection.length;
    arrayEach(collection, iterator, done);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    symbolEach(collection, iterator, done);
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    baseEach(collection, iterator, done, keys);
  }
  if (!size) {
    callback(null);
  }

  function done(err, bool) {
    if (err) {
      callback = once(callback);
      callback(err);
    } else if (++completed === size) {
      callback(null);
    } else if (bool === false) {
      callback = once(callback);
      callback(null);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.forEachLimit" id="apidoc.element.neo-async.default.forEachLimit">
        function <span class="apidocSignatureSpan">neo-async.default.</span>forEachLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachLimit(collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, keys, iter, item, iterate;
  var sync = false;
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  } else {
    return callback(null);
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null);
  }
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    if (started &#x3c; size) {
      iterator(collection[started++], done);
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      iterator(collection[index], index, done);
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      iterator(item.value, done);
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      iterator(item.value, started++, done);
    }
  }

  function objectIterator() {
    if (started &#x3c; size) {
      iterator(collection[keys[started++]], done);
    }
  }

  function objectIteratorWithKey() {
    index = started++;
    if (index &#x3c; size) {
      key = keys[index];
      iterator(collection[key], key, done);
    }
  }

  function done(err, bool) {
    if (err) {
      iterate = noop;
      callback = once(callback);
      callback(err);
    } else if (++completed === size) {
      iterate = throwError;
      callback = onlyOnce(callback);
      callback(null);
    } else if (bool === false) {
      iterate = noop;
      callback = once(callback);
      callback(null);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.forEachOf" id="apidoc.element.neo-async.default.forEachOf">
        function <span class="apidocSignatureSpan">neo-async.default.</span>forEachOf
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function each(collection, iterator, callback) {
  callback = callback || noop;
  var size, keys;
  var completed = 0;
  if (isArray(collection)) {
    size = collection.length;
    arrayEach(collection, iterator, done);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    symbolEach(collection, iterator, done);
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    baseEach(collection, iterator, done, keys);
  }
  if (!size) {
    callback(null);
  }

  function done(err, bool) {
    if (err) {
      callback = once(callback);
      callback(err);
    } else if (++completed === size) {
      callback(null);
    } else if (bool === false) {
      callback = once(callback);
      callback(null);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.forEachOfLimit" id="apidoc.element.neo-async.default.forEachOfLimit">
        function <span class="apidocSignatureSpan">neo-async.default.</span>forEachOfLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachLimit(collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, keys, iter, item, iterate;
  var sync = false;
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  } else {
    return callback(null);
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null);
  }
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    if (started &#x3c; size) {
      iterator(collection[started++], done);
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      iterator(collection[index], index, done);
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      iterator(item.value, done);
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      iterator(item.value, started++, done);
    }
  }

  function objectIterator() {
    if (started &#x3c; size) {
      iterator(collection[keys[started++]], done);
    }
  }

  function objectIteratorWithKey() {
    index = started++;
    if (index &#x3c; size) {
      key = keys[index];
      iterator(collection[key], key, done);
    }
  }

  function done(err, bool) {
    if (err) {
      iterate = noop;
      callback = once(callback);
      callback(err);
    } else if (++completed === size) {
      iterate = throwError;
      callback = onlyOnce(callback);
      callback(null);
    } else if (bool === false) {
      iterate = noop;
      callback = once(callback);
      callback(null);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.forEachOfSeries" id="apidoc.element.neo-async.default.forEachOfSeries">
        function <span class="apidocSignatureSpan">neo-async.default.</span>forEachOfSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachSeries(collection, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, keys, iter, value, iterate;
  var sync = false;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null);
  }
  iterate();

  function arrayIterator() {
    iterator(collection[completed], done);
  }

  function arrayIteratorWithIndex() {
    iterator(collection[completed], completed, done);
  }

  function symbolIterator() {
    iterator(iter.next().value, done);
  }

  function symbolIteratorWithKey() {
    value = iter.next().value;
    iterator(value, completed, done);
  }

  function objectIterator() {
    iterator(collection[keys[completed]], done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    iterator(collection[key], key, done);
  }

  function done(err, bool) {
    if (err) {
      callback(err);
    } else if (++completed === size) {
      iterate = throwError;
      callback(null);
    } else if (bool === false) {
      iterate = throwError;
      callback(null);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.forEachSeries" id="apidoc.element.neo-async.default.forEachSeries">
        function <span class="apidocSignatureSpan">neo-async.default.</span>forEachSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachSeries(collection, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, keys, iter, value, iterate;
  var sync = false;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null);
  }
  iterate();

  function arrayIterator() {
    iterator(collection[completed], done);
  }

  function arrayIteratorWithIndex() {
    iterator(collection[completed], completed, done);
  }

  function symbolIterator() {
    iterator(iter.next().value, done);
  }

  function symbolIteratorWithKey() {
    value = iter.next().value;
    iterator(value, completed, done);
  }

  function objectIterator() {
    iterator(collection[keys[completed]], done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    iterator(collection[key], key, done);
  }

  function done(err, bool) {
    if (err) {
      callback(err);
    } else if (++completed === size) {
      iterate = throwError;
      callback(null);
    } else if (bool === false) {
      iterate = throwError;
      callback(null);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.forever" id="apidoc.element.neo-async.default.forever">
        function <span class="apidocSignatureSpan">neo-async.default.</span>forever
        <span class="apidocSignatureSpan">(iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forever(iterator, callback) {
  var sync = false;
  iterate();

  function iterate() {
    iterator(next);
  }

  function next(err) {
    if (err) {
      if (callback) {
        return callback(err);
      }
      throw err;
    }
    if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.groupBy" id="apidoc.element.neo-async.default.groupBy">
        function <span class="apidocSignatureSpan">neo-async.default.</span>groupBy
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function groupBy(collection, iterator, callback) {
  callback = callback || noop;
  var size;
  var completed = 0;
  var result = {};

  if (isArray(collection)) {
    size = collection.length;
    arrayEach(collection, iterator, createCallback);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    symbolEach(collection, iterator, createCallback);
  } else if (typeof collection === obj) {
    var keys = nativeKeys(collection);
    size = keys.length;
    baseEach(collection, iterator, createCallback, keys);
  }
  if (!size) {
    callback(null, {});
  }

  function createCallback(value) {
    var called = false;
    return function done(err, key) {
      if (called) {
        throwError();
      }
      called = true;
      if (err) {
        callback = once(callback);
        callback(err, objectClone(result));
        return;
      }
      var array = result[key];
      if (!array) {
        array = result[key] = [value];
      } else {
        array.push(value);
      }
      if (++completed === size) {
        callback(null, result);
      }
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [4.2, 6.4, 6.1];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, Math.floor(num));
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">groupBy</span>(array, iterator, function(err, res) {
*   console.log(res); // { &#x27;4&#x27;: [4.2], &#x27;6&#x27;: [6.1, 6.4] }
*   console.log(order); // [4.2, 6.1, 6.4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.groupByLimit" id="apidoc.element.neo-async.default.groupByLimit">
        function <span class="apidocSignatureSpan">neo-async.default.</span>groupByLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function groupByLimit(collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, value, keys, iter, item, iterate;
  var sync = false;
  var started = 0;
  var completed = 0;
  var result = {};

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null, result);
  }
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    if (started &#x3c; size) {
      value = collection[started++];
      iterator(value, createCallback(value));
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, index, createCallback(value));
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, createCallback(value));
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, started++, createCallback(value));
    }
  }

  function objectIterator() {
    if (started &#x3c; size) {
      value = collection[keys[started++]];
      iterator(value, createCallback(value));
    }
  }

  function objectIteratorWithKey() {
    if (started &#x3c; size) {
      key = keys[started++];
      value = collection[key];
      iterator(value, key, createCallback(value));
    }
  }

  function createCallback(value) {
    var called = false;
    return function(err, key) {
      if (called) {
        throwError();
      }
      called = true;
      if (err) {
        iterate = noop;
        callback = once(callback);
        callback(err, objectClone(result));
        return;
      }
      var array = result[key];
      if (!array) {
        result[key] = [value];
      } else {
        array.push(value);
      }
      if (++completed === size) {
        callback(null, result);
      } else if (sync) {
        nextTick(iterate);
      } else {
        sync = true;
        iterate();
      }
      sync = false;
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1.1, 5.9, 3.2, 3.9, 2.1];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, Math.floor(num));
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">groupByLimit</span>(array, 2, iterator, function(err, res) {
*   console.log(res); // { &#x27;1&#x27;: [1.1], &#x27;3&#x27;: [3.2, 3.9], &#x27;5&#x27;: [5.9], &#x27;2&#x27;: [2.1] }
*   console.log(order); // [1.1, 3.2, 5.9, 2.1, 3.9]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.groupBySeries" id="apidoc.element.neo-async.default.groupBySeries">
        function <span class="apidocSignatureSpan">neo-async.default.</span>groupBySeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function groupBySeries(collection, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, value, keys, iter, iterate;
  var sync = false;
  var completed = 0;
  var result = {};

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null, result);
  }
  iterate();

  function arrayIterator() {
    value = collection[completed];
    iterator(value, done);
  }

  function arrayIteratorWithIndex() {
    value = collection[completed];
    iterator(value, completed, done);
  }

  function symbolIterator() {
    value = iter.next().value;
    iterator(value, done);
  }

  function symbolIteratorWithKey() {
    value = iter.next().value;
    iterator(value, completed, done);
  }

  function objectIterator() {
    value = collection[keys[completed]];
    iterator(value, done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    value = collection[key];
    iterator(value, key, done);
  }

  function done(err, key) {
    if (err) {
      iterate = throwError;
      callback = onlyOnce(callback);
      callback(err, objectClone(result));
      return;
    }
    var array = result[key];
    if (!array) {
      array = result[key] = [value];
    } else {
      array.push(value);
    }
    if (++completed === size) {
      iterate = throwError;
      callback(null, result);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [4.2, 6.4, 6.1];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, Math.floor(num));
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">groupBySeries</span>(array, iterator, function(err, res) {
*   console.log(res); // { &#x27;4&#x27;: [4.2], &#x27;6&#x27;: [6.4, 6.1] }
*   console.log(order); // [4.2, 6.4, 6.1]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.inject" id="apidoc.element.neo-async.default.inject">
        function <span class="apidocSignatureSpan">neo-async.default.</span>inject
        <span class="apidocSignatureSpan">(collection, result, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduce(collection, result, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, keys, iter, iterate;
  var sync = false;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 4 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 4 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 4 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null, result);
  }
  iterate(result);

  function arrayIterator(result) {
    iterator(result, collection[completed], done);
  }

  function arrayIteratorWithIndex(result) {
    iterator(result, collection[completed], completed, done);
  }

  function symbolIterator() {
    iterator(result, iter.next().value, done);
  }

  function symbolIteratorWithKey() {
    iterator(result, iter.next().value, completed, done);
  }

  function objectIterator(result) {
    iterator(result, collection[keys[completed]], done);
  }

  function objectIteratorWithKey(result) {
    key = keys[completed];
    iterator(result, collection[key], key, done);
  }

  function done(err, result) {
    if (err) {
      callback(err, result);
    } else if (++completed === size) {
      iterator = throwError;
      callback(null, result);
    } else if (sync) {
      nextTick(function() {
        iterate(result);
      });
    } else {
      sync = true;
      iterate(result);
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.iterator" id="apidoc.element.neo-async.default.iterator">
        function <span class="apidocSignatureSpan">neo-async.default.</span>iterator
        <span class="apidocSignatureSpan">(tasks)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function iterator(tasks) {
  var size = 0;
  var keys = [];
  if (isArray(tasks)) {
    size = tasks.length;
  } else {
    keys = nativeKeys(tasks);
    size = keys.length;
  }
  return makeCallback(0);

  function makeCallback(index) {
    var fn = function() {
      if (size) {
        var key = keys[index] || index;
        tasks[key].apply(null, createArray(arguments));
      }
      return fn.next();
    };
    fn.next = function() {
      return (index &#x3c; size - 1) ? makeCallback(index + 1) : null;
    };
    return fn;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.log" id="apidoc.element.neo-async.default.log">
        function <span class="apidocSignatureSpan">neo-async.default.</span>log
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">log = function (fn) {
  var args = slice(arguments, 1);
  args.push(done);
  fn.apply(null, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done();
*   }, num * 10);
* };
* async.each(array, iterator, function(err, res) {
*   console.<span class="apidocCodeKeywordSpan">log</span>(res); // undefined
*   console.log(order); // [1, 2, 3]
* });
*
* @example
*
* // array with index
* var order = [];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.map" id="apidoc.element.neo-async.default.map">
        function <span class="apidocSignatureSpan">neo-async.default.</span>map
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (collection, iterator, callback) {
  callback = callback || noop;
  var size, keys, result;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    result = init(size);
    arrayEach(collection, iterator, createCallback);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    result = init(size);
    symbolEach(collection, iterator, createCallback);
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    result = init(size);
    baseEach(collection, iterator, createCallback, keys);
  }
  if (!size) {
    callback(null, init());
  }

  function createCallback(key) {
    return function done(err, res) {
      if (key === null) {
        throwError();
      }
      if (err) {
        key = null;
        callback = once(callback);
        callback(err, clone(result));
        return;
      }
      result[key] = res;
      key = null;
      if (++completed === size) {
        callback(null, result);
      }
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">map</span>(array, iterator, function(err, res) {
*   console.log(res); // [1, 3, 2];
*   console.log(order); // [1, 2, 3]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.mapLimit" id="apidoc.element.neo-async.default.mapLimit">
        function <span class="apidocSignatureSpan">neo-async.default.</span>mapLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mapLimit(collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, keys, iter, item, result, iterate;
  var sync = false;
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null, []);
  }
  result = Array(size);
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    index = started++;
    if (index &#x3c; size) {
      iterator(collection[index], createCallback(index));
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      iterator(collection[index], index, createCallback(index));
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      iterator(item.value, createCallback(started++));
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      iterator(item.value, started, createCallback(started++));
    }
  }

  function objectIterator() {
    index = started++;
    if (index &#x3c; size) {
      iterator(collection[keys[index]], createCallback(index));
    }
  }

  function objectIteratorWithKey() {
    index = started++;
    if (index &#x3c; size) {
      key = keys[index];
      iterator(collection[key], key, createCallback(index));
    }
  }

  function createCallback(index) {
    return function(err, res) {
      if (index === null) {
        throwError();
      }
      if (err) {
        index = null;
        iterate = noop;
        callback = once(callback);
        callback(err, createArray(result));
        return;
      }
      result[index] = res;
      index = null;
      if (++completed === size) {
        iterate = throwError;
        callback(null, result);
        callback = throwError;
      } else if (sync) {
        nextTick(iterate);
      } else {
        sync = true;
        iterate();
      }
      sync = false;
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 5, 3, 4, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">mapLimit</span>(array, 2, iterator, function(err, res) {
*   console.log(res); // [1, 5, 3, 4, 2]
*   console.log(order); // [1, 3, 5, 2, 4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.mapSeries" id="apidoc.element.neo-async.default.mapSeries">
        function <span class="apidocSignatureSpan">neo-async.default.</span>mapSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mapSeries(collection, iterator, callback) {
  callback = callback || noop;
  var size, key, keys, iter, value, result, iterate;
  var sync = false;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null, []);
  }
  result = Array(size);
  iterate();

  function arrayIterator() {
    iterator(collection[completed], done);
  }

  function arrayIteratorWithIndex() {
    iterator(collection[completed], completed, done);
  }

  function symbolIterator() {
    iterator(iter.next().value, done);
  }

  function symbolIteratorWithKey() {
    value = iter.next().value;
    iterator(value, completed, done);
  }

  function objectIterator() {
    iterator(collection[keys[completed]], done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    iterator(collection[key], key, done);
  }

  function done(err, res) {
    if (err) {
      iterate = throwError;
      callback = onlyOnce(callback);
      callback(err, createArray(result));
      return;
    }
    result[completed] = res;
    if (++completed === size) {
      iterate = throwError;
      callback(null, result);
      callback = throwError;
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">mapSeries</span>(array, iterator, function(err, res) {
*   console.log(res); // [1, 3, 2];
*   console.log(order); // [1, 3, 2]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.mapValues" id="apidoc.element.neo-async.default.mapValues">
        function <span class="apidocSignatureSpan">neo-async.default.</span>mapValues
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapValues = function (collection, iterator, callback) {
  callback = callback || noop;
  var size, keys, result;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    result = init(size);
    arrayEach(collection, iterator, createCallback);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    result = init(size);
    symbolEach(collection, iterator, createCallback);
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    result = init(size);
    baseEach(collection, iterator, createCallback, keys);
  }
  if (!size) {
    callback(null, init());
  }

  function createCallback(key) {
    return function done(err, res) {
      if (key === null) {
        throwError();
      }
      if (err) {
        key = null;
        callback = once(callback);
        callback(err, clone(result));
        return;
      }
      result[key] = res;
      key = null;
      if (++completed === size) {
        callback(null, result);
      }
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">mapValues</span>(array, iterator, function(err, res) {
*   console.log(res); // { &#x27;0&#x27;: 1, &#x27;1&#x27;: 3, &#x27;2&#x27;: 2 }
*   console.log(order); // [1, 2, 3]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.mapValuesLimit" id="apidoc.element.neo-async.default.mapValuesLimit">
        function <span class="apidocSignatureSpan">neo-async.default.</span>mapValuesLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mapValuesLimit(collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, keys, iter, item, iterate;
  var sync = false;
  var result = {};
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null, result);
  }
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    index = started++;
    if (index &#x3c; size) {
      iterator(collection[index], createCallback(index));
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      iterator(collection[index], index, createCallback(index));
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      iterator(item.value, createCallback(started++));
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      iterator(item.value, started, createCallback(started++));
    }
  }

  function objectIterator() {
    index = started++;
    if (index &#x3c; size) {
      key = keys[index];
      iterator(collection[key], createCallback(key));
    }
  }

  function objectIteratorWithKey() {
    index = started++;
    if (index &#x3c; size) {
      key = keys[index];
      iterator(collection[key], key, createCallback(key));
    }
  }

  function createCallback(key) {
    return function(err, res) {
      if (key === null) {
        throwError();
      }
      if (err) {
        key = null;
        iterate = noop;
        callback = once(callback);
        callback(err, objectClone(result));
        return;
      }
      result[key] = res;
      key = null;
      if (++completed === size) {
        callback(null, result);
      } else if (sync) {
        nextTick(iterate);
      } else {
        sync = true;
        iterate();
      }
      sync = false;
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 5, 3, 4, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">mapValuesLimit</span>(array, 2, iterator, function(err, res) {
*   console.log(res); // { &#x27;0&#x27;: 1, &#x27;1&#x27;: 5, &#x27;2&#x27;: 3, &#x27;3&#x27;: 4, &#x27;4&#x27;: 2 }
*   console.log(order); // [1, 3, 5, 2, 4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.mapValuesSeries" id="apidoc.element.neo-async.default.mapValuesSeries">
        function <span class="apidocSignatureSpan">neo-async.default.</span>mapValuesSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mapValuesSeries(collection, iterator, callback) {
  callback = callback || noop;
  var size, key, keys, iter, value, iterate;
  var sync = false;
  var result = {};
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null, result);
  }
  iterate();

  function arrayIterator() {
    key = completed;
    iterator(collection[completed], done);
  }

  function arrayIteratorWithIndex() {
    key = completed;
    iterator(collection[completed], completed, done);
  }

  function symbolIterator() {
    key = completed;
    value = iter.next().value;
    iterator(value, done);
  }

  function symbolIteratorWithKey() {
    key = completed;
    value = iter.next().value;
    iterator(value, completed, done);
  }

  function objectIterator() {
    key = keys[completed];
    iterator(collection[key], done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    iterator(collection[key], key, done);
  }

  function done(err, res) {
    if (err) {
      iterate = throwError;
      callback = onlyOnce(callback);
      callback(err, objectClone(result));
      return;
    }
    result[key] = res;
    if (++completed === size) {
      iterate = throwError;
      callback(null, result);
      callback = throwError;
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">mapValuesSeries</span>(array, iterator, function(err, res) {
*   console.log(res); // { &#x27;0&#x27;: 1, &#x27;1&#x27;: 3, &#x27;2&#x27;: 2 }
*   console.log(order); // [1, 3, 2]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.memoize" id="apidoc.element.neo-async.default.memoize">
        function <span class="apidocSignatureSpan">neo-async.default.</span>memoize
        <span class="apidocSignatureSpan">(fn, hasher)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function memoize(fn, hasher) {
  hasher = hasher || function(hash) {
    return hash;
  };

  var memo = {};
  var queues = {};
  var memoized = function() {
    var args = createArray(arguments);
    var callback = args.pop();
    var key = hasher.apply(null, args);
    if (has(memo, key)) {
      nextTick(function() {
        callback.apply(null, memo[key]);
      });
      return;
    }
    if (has(queues, key)) {
      return queues[key].push(callback);
    }

    queues[key] = [callback];
    args.push(done);
    fn.apply(null, args);

    function done() {
      var args = createArray(arguments);
      memo[key] = args;
      var q = queues[key];
      delete queues[key];

      var i = -1;
      var size = q.length;
      while (++i &#x3c; size) {
        q[i].apply(null, args);
      }
    }
  };
  memoized.memo = memo;
  memoized.unmemoized = fn;
  return memoized;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.nextTick" id="apidoc.element.neo-async.default.nextTick">
        function <span class="apidocSignatureSpan">neo-async.default.</span>nextTick
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nextTick(callback) {
  if (typeof callback !== &#x27;function&#x27;)
    throw new TypeError(&#x27;callback is not a function&#x27;);
  // on the way out, don&#x27;t bother. it won&#x27;t get fired anyway.
  if (process._exiting)
    return;

  var args;
  if (arguments.length &#x3e; 1) {
    args = new Array(arguments.length - 1);
    for (var i = 1; i &#x3c; arguments.length; i++)
      args[i - 1] = arguments[i];
  }

  nextTickQueue.push({
    callback,
    domain: process.domain || null,
    args
  });
  tickInfo[kLength]++;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.omit" id="apidoc.element.neo-async.default.omit">
        function <span class="apidocSignatureSpan">neo-async.default.</span>omit
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">omit = function (collection, iterator, callback) {
  callback = callback || noop;
  var size, keys;
  var completed = 0;
  var result = {};

  if (isArray(collection)) {
    size = collection.length;
    arrayEach(collection, iterator, createCallback);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    symbolEach(collection, iterator, createCallback);
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    baseEach(collection, iterator, createCallback, keys);
  }
  if (!size) {
    return callback(null, {});
  }

  function createCallback(key, value) {
    return function done(err, res) {
      if (key === null) {
        throwError();
      }
      if (err) {
        key = null;
        callback = once(callback);
        callback(err, objectClone(result));
        return;
      }
      if (!!res === bool) {
        result[key] = value;
      }
      key = null;
      if (++completed === size) {
        callback(null, result);
      }
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2, 4];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">omit</span>(array, iterator, function(err, res) {
*   console.log(res); // { &#x27;2&#x27;: 2, &#x27;3&#x27;: 4 }
*   console.log(order); // [1, 2, 3, 4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.omitLimit" id="apidoc.element.neo-async.default.omitLimit">
        function <span class="apidocSignatureSpan">neo-async.default.</span>omitLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">omitLimit = function (collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, value, keys, iter, item, iterate;
  var sync = false;
  var result = {};
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null, {});
  }
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, createCallback(value, index));
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, index, createCallback(value, index));
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, createCallback(value, started++));
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, started, createCallback(value, started++));
    }
  }

  function objectIterator() {
    if (started &#x3c; size) {
      key = keys[started++];
      value = collection[key];
      iterator(value, createCallback(value, key));
    }
  }

  function objectIteratorWithKey() {
    if (started &#x3c; size) {
      key = keys[started++];
      value = collection[key];
      iterator(value, key, createCallback(value, key));
    }
  }

  function createCallback(value, key) {
    return function(err, res) {
      if (key === null) {
        throwError();
      }
      if (err) {
        key = null;
        iterate = noop;
        callback = once(callback);
        callback(err, objectClone(result));
        return;
      }
      if (!!res === bool) {
        result[key] = value;
      }
      key = null;
      if (++completed === size) {
        iterate = throwError;
        callback = onlyOnce(callback);
        callback(null, result);
      } else if (sync) {
        nextTick(iterate);
      } else {
        sync = true;
        iterate();
      }
      sync = false;
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 5, 3, 4, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">omitLimit</span>(array, 2, iterator, function(err, res) {
*   console.log(res); // { &#x27;3&#x27;: 4, &#x27;4&#x27;: 2 }
*   console.log(order); // [1, 3, 5, 2, 4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.omitSeries" id="apidoc.element.neo-async.default.omitSeries">
        function <span class="apidocSignatureSpan">neo-async.default.</span>omitSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">omitSeries = function (collection, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, value, keys, iter, iterate;
  var sync = false;
  var result = {};
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null, {});
  }
  iterate();

  function arrayIterator() {
    key = completed;
    value = collection[completed];
    iterator(value, done);
  }

  function arrayIteratorWithIndex() {
    key = completed;
    value = collection[completed];
    iterator(value, completed, done);
  }

  function symbolIterator() {
    key = completed;
    value = iter.next().value;
    iterator(value, done);
  }

  function symbolIteratorWithKey() {
    key = completed;
    value = iter.next().value;
    iterator(value, key, done);
  }

  function objectIterator() {
    key = keys[completed];
    value = collection[key];
    iterator(value, done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    value = collection[key];
    iterator(value, key, done);
  }

  function done(err, res) {
    if (err) {
      callback(err, result);
      return;
    }
    if (!!res === bool) {
      result[key] = value;
    }
    if (++completed === size) {
      iterate = throwError;
      callback(null, result);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2, 4];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">omitSeries</span>(array, iterator, function(err, res) {
*   console.log(res); // { &#x27;2&#x27;: 2, &#x27;3&#x27;: 4 }
*   console.log(order); // [1, 3, 2, 4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.parallel" id="apidoc.element.neo-async.default.parallel">
        function <span class="apidocSignatureSpan">neo-async.default.</span>parallel
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parallel(tasks, callback) {
  callback = callback || noop;
  var size, keys, result;
  var completed = 0;

  if (isArray(tasks)) {
    size = tasks.length;
    result = Array(size);
    arrayEach(tasks, createCallback);
  } else if (tasks &#x26;&#x26; typeof tasks === obj) {
    keys = nativeKeys(tasks);
    size = keys.length;
    result = {};
    baseEach(tasks, createCallback, keys);
  }
  if (!size) {
    callback(null, result);
  }

  function createCallback(key) {
    return function(err, res) {
      if (key === null) {
        throwError();
      }
      if (err) {
        key = null;
        callback = once(callback);
        callback(err, result);
        return;
      }
      result[key] = arguments.length &#x3c;= 2 ? res : slice(arguments, 1);
      key = null;
      if (++completed === size) {
        callback(null, result);
      }
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*  function(done) {
*    setTimeout(function() {
*      order.push(4);
*      done(null, 4);
*    }, 20);
*  }
* ];
* async.<span class="apidocCodeKeywordSpan">parallel</span>(tasks, function(err, res) {
*   console.log(res); // [1, 2, 3, 4];
*   console.log(order); // [1, 4, 2, 3]
* });
*
* @example
*
* var order = [];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.parallelLimit" id="apidoc.element.neo-async.default.parallelLimit">
        function <span class="apidocSignatureSpan">neo-async.default.</span>parallelLimit
        <span class="apidocSignatureSpan">(tasks, limit, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parallelLimit(tasks, limit, callback) {
  callback = callback || noop;
  var size, index, key, keys, result, iterate;
  var sync = false;
  var started = 0;
  var completed = 0;

  if (isArray(tasks)) {
    size = tasks.length;
    result = Array(size);
    iterate = arrayIterator;
  } else if (tasks &#x26;&#x26; typeof tasks === obj) {
    keys = nativeKeys(tasks);
    size = keys.length;
    result = {};
    iterate = objectIterator;
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null, result);
  }
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    index = started++;
    if (index &#x3c; size) {
      tasks[index](createCallback(index));
    }
  }

  function objectIterator() {
    if (started &#x3c; size) {
      key = keys[started++];
      tasks[key](createCallback(key));
    }
  }

  function createCallback(key) {
    return function(err, res) {
      if (key === null) {
        throwError();
      }
      if (err) {
        key = null;
        iterate = noop;
        callback = once(callback);
        callback(err, result);
        return;
      }
      result[key] = arguments.length &#x3c;= 2 ? res : slice(arguments, 1);
      key = null;
      if (++completed === size) {
        callback(null, result);
      } else if (sync) {
        nextTick(iterate);
      } else {
        sync = true;
        iterate();
      }
      sync = false;
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*  function(done) {
*    setTimeout(function() {
*      order.push(4);
*      done(null, 4);
*    }, 40);
*  }
* ];
* async.<span class="apidocCodeKeywordSpan">parallelLimit</span>(tasks, 2, function(err, res) {
*   console.log(res); // [1, 2, 3, 4];
*   console.log(order); // [1, 3, 2, 4]
* });
*
* @example
*
* var order = [];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.pick" id="apidoc.element.neo-async.default.pick">
        function <span class="apidocSignatureSpan">neo-async.default.</span>pick
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pick = function (collection, iterator, callback) {
  callback = callback || noop;
  var size, keys;
  var completed = 0;
  var result = {};

  if (isArray(collection)) {
    size = collection.length;
    arrayEach(collection, iterator, createCallback);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    symbolEach(collection, iterator, createCallback);
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    baseEach(collection, iterator, createCallback, keys);
  }
  if (!size) {
    return callback(null, {});
  }

  function createCallback(key, value) {
    return function done(err, res) {
      if (key === null) {
        throwError();
      }
      if (err) {
        key = null;
        callback = once(callback);
        callback(err, objectClone(result));
        return;
      }
      if (!!res === bool) {
        result[key] = value;
      }
      key = null;
      if (++completed === size) {
        callback(null, result);
      }
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2, 4];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">pick</span>(array, iterator, function(err, res) {
*   console.log(res); // { &#x27;0&#x27;: 1, &#x27;1&#x27;: 3 }
*   console.log(order); // [1, 2, 3, 4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.pickLimit" id="apidoc.element.neo-async.default.pickLimit">
        function <span class="apidocSignatureSpan">neo-async.default.</span>pickLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pickLimit = function (collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, value, keys, iter, item, iterate;
  var sync = false;
  var result = {};
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null, {});
  }
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, createCallback(value, index));
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, index, createCallback(value, index));
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, createCallback(value, started++));
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, started, createCallback(value, started++));
    }
  }

  function objectIterator() {
    if (started &#x3c; size) {
      key = keys[started++];
      value = collection[key];
      iterator(value, createCallback(value, key));
    }
  }

  function objectIteratorWithKey() {
    if (started &#x3c; size) {
      key = keys[started++];
      value = collection[key];
      iterator(value, key, createCallback(value, key));
    }
  }

  function createCallback(value, key) {
    return function(err, res) {
      if (key === null) {
        throwError();
      }
      if (err) {
        key = null;
        iterate = noop;
        callback = once(callback);
        callback(err, objectClone(result));
        return;
      }
      if (!!res === bool) {
        result[key] = value;
      }
      key = null;
      if (++completed === size) {
        iterate = throwError;
        callback = onlyOnce(callback);
        callback(null, result);
      } else if (sync) {
        nextTick(iterate);
      } else {
        sync = true;
        iterate();
      }
      sync = false;
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 5, 3, 4, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">pickLimit</span>(array, 2, iterator, function(err, res) {
*   console.log(res); // { &#x27;0&#x27;: 1, &#x27;1&#x27;: 5, &#x27;2&#x27;: 3 }
*   console.log(order); // [1, 3, 5, 2, 4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.pickSeries" id="apidoc.element.neo-async.default.pickSeries">
        function <span class="apidocSignatureSpan">neo-async.default.</span>pickSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pickSeries = function (collection, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, value, keys, iter, iterate;
  var sync = false;
  var result = {};
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null, {});
  }
  iterate();

  function arrayIterator() {
    key = completed;
    value = collection[completed];
    iterator(value, done);
  }

  function arrayIteratorWithIndex() {
    key = completed;
    value = collection[completed];
    iterator(value, completed, done);
  }

  function symbolIterator() {
    key = completed;
    value = iter.next().value;
    iterator(value, done);
  }

  function symbolIteratorWithKey() {
    key = completed;
    value = iter.next().value;
    iterator(value, key, done);
  }

  function objectIterator() {
    key = keys[completed];
    value = collection[key];
    iterator(value, done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    value = collection[key];
    iterator(value, key, done);
  }

  function done(err, res) {
    if (err) {
      callback(err, result);
      return;
    }
    if (!!res === bool) {
      result[key] = value;
    }
    if (++completed === size) {
      iterate = throwError;
      callback(null, result);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2, 4];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">pickSeries</span>(array, iterator, function(err, res) {
*   console.log(res); // { &#x27;0&#x27;: 1, &#x27;1&#x27;: 3 }
*   console.log(order); // [1, 3, 2, 4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.priorityQueue" id="apidoc.element.neo-async.default.priorityQueue">
        function <span class="apidocSignatureSpan">neo-async.default.</span>priorityQueue
        <span class="apidocSignatureSpan">(worker, concurrency)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function priorityQueue(worker, concurrency) {
  var q = baseQueue(true, worker, concurrency);
  q.push = push;
  delete q.unshift;
  return q;

  function push(tasks, priority, callback) {
    q.started = true;
    priority = priority || 0;
    var _tasks = isArray(tasks) ? tasks : [tasks];
    var taskSize = _tasks.length;

    if (tasks === undefined || taskSize === 0) {
      if (q.idle()) {
        nextTick(q.drain);
      }
      return;
    }

    callback = typeof callback === func ? callback : noop;
    var nextNode = q._tasks.head;
    while (nextNode &#x26;&#x26; priority &#x3e;= nextNode.priority) {
      nextNode = nextNode.next;
    }
    while (taskSize--) {
      var item = {
        data: _tasks[taskSize],
        priority: priority,
        callback: callback
      };
      if (nextNode) {
        q._tasks.insertBefore(nextNode, item);
      } else {
        q._tasks.push(item);
      }
      nextTick(q.process);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.queue" id="apidoc.element.neo-async.default.queue">
        function <span class="apidocSignatureSpan">neo-async.default.</span>queue
        <span class="apidocSignatureSpan">(worker, concurrency)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function queue(worker, concurrency) {
  return baseQueue(true, worker, concurrency);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.race" id="apidoc.element.neo-async.default.race">
        function <span class="apidocSignatureSpan">neo-async.default.</span>race
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function race(tasks, callback) {
  callback = once(callback || noop);
  var size, keys;
  var index = -1;
  if (isArray(tasks)) {
    size = tasks.length;
    while (++index &#x3c; size) {
      tasks[index](callback);
    }
  } else if (tasks &#x26;&#x26; typeof tasks === obj) {
    keys = nativeKeys(tasks);
    size = keys.length;
    while (++index &#x3c; size) {
      tasks[keys[index]](callback);
    }
  } else {
    return callback(new TypeError(&#x27;First argument to race must be a collection of functions&#x27;));
  }
  if (!size) {
    callback(null);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*   function(done) {
*     setTimeout(function() {
*       called++;
*       done(null, &#x27;3&#x27;);
*     }, 10);
*   }
* ];
* async.<span class="apidocCodeKeywordSpan">race</span>(tasks, function(err, res) {
*   console.log(res); // &#x27;3&#x27;
*   console.log(called); // 1
*   setTimeout(function() {
*     console.log(called); // 3
*   }, 50);
* });
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.reduce" id="apidoc.element.neo-async.default.reduce">
        function <span class="apidocSignatureSpan">neo-async.default.</span>reduce
        <span class="apidocSignatureSpan">(collection, result, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduce(collection, result, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, keys, iter, iterate;
  var sync = false;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 4 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 4 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 4 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null, result);
  }
  iterate(result);

  function arrayIterator(result) {
    iterator(result, collection[completed], done);
  }

  function arrayIteratorWithIndex(result) {
    iterator(result, collection[completed], completed, done);
  }

  function symbolIterator() {
    iterator(result, iter.next().value, done);
  }

  function symbolIteratorWithKey() {
    iterator(result, iter.next().value, completed, done);
  }

  function objectIterator(result) {
    iterator(result, collection[keys[completed]], done);
  }

  function objectIteratorWithKey(result) {
    key = keys[completed];
    iterator(result, collection[key], key, done);
  }

  function done(err, result) {
    if (err) {
      callback(err, result);
    } else if (++completed === size) {
      iterator = throwError;
      callback(null, result);
    } else if (sync) {
      nextTick(function() {
        iterate(result);
      });
    } else {
      sync = true;
      iterate(result);
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var collection = [1, 3, 2, 4];
* var iterator = function(result, num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, result + num);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">reduce</span>(collection, 0, iterator, function(err, res) {
*   console.log(res); // 10
*   console.log(order); // [1, 3, 2, 4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.reduceRight" id="apidoc.element.neo-async.default.reduceRight">
        function <span class="apidocSignatureSpan">neo-async.default.</span>reduceRight
        <span class="apidocSignatureSpan">(collection, result, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduceRight(collection, result, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var resIndex, index, key, keys, iter, item, col, iterate;
  var sync = false;

  if (isArray(collection)) {
    resIndex = collection.length;
    iterate = iterator.length === 4 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    resIndex = collection.size;
    col = Array(resIndex);
    iter = collection[iteratorSymbol]();
    index = -1;
    while ((item = iter.next()).done === false) {
      col[++index] = item.value;
    }
    collection = col;
    iterate = iterator.length === 4 ? arrayIteratorWithIndex : arrayIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    resIndex = keys.length;
    iterate = iterator.length === 4 ? objectIteratorWithKey : objectIterator;
  }
  if (!resIndex) {
    return callback(null, result);
  }
  iterate(result);

  function arrayIterator(result) {
    iterator(result, collection[--resIndex], done);
  }

  function arrayIteratorWithIndex(result) {
    iterator(result, collection[--resIndex], resIndex, done);
  }

  function objectIterator(result) {
    iterator(result, collection[keys[--resIndex]], done);
  }

  function objectIteratorWithKey(result) {
    key = keys[--resIndex];
    iterator(result, collection[key], key, done);
  }

  function done(err, result) {
    if (err) {
      callback(err, result);
    } else if (resIndex === 0) {
      iterate = throwError;
      callback(null, result);
    } else if (sync) {
      nextTick(function() {
        iterate(result);
      });
    } else {
      sync = true;
      iterate(result);
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var collection = [1, 3, 2, 4];
* var iterator = function(result, num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, result + num);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">reduceRight</span>(collection, 0, iterator, function(err, res) {
*   console.log(res); // 10
*   console.log(order); // [4, 2, 3, 1]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.reflect" id="apidoc.element.neo-async.default.reflect">
        function <span class="apidocSignatureSpan">neo-async.default.</span>reflect
        <span class="apidocSignatureSpan">(func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reflect(func) {
  return function( /* args..., callback */ ) {
    var callback;
    switch (arguments.length) {
      case 1:
        callback = arguments[0];
        return func(done);
      case 2:
        callback = arguments[1];
        return func(arguments[0], done);
      default:
        var args = createArray(arguments);
        var lastIndex = args.length - 1;
        callback = args[lastIndex];
        args[lastIndex] = done;
        func.apply(this, args);
    }

    function done(err, res) {
      if (err) {
        return callback(null, {
          error: err
        });
      }
      if (arguments.length &#x3e; 2) {
        res = slice(arguments, 1);
      }
      callback(null, {
        value: res
      });
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.reflectAll" id="apidoc.element.neo-async.default.reflectAll">
        function <span class="apidocSignatureSpan">neo-async.default.</span>reflectAll
        <span class="apidocSignatureSpan">(tasks)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reflectAll(tasks) {
  var size, newTasks, keys;
  if (isArray(tasks)) {
    size = tasks.length;
    newTasks = Array(size);
    arrayEachSync(tasks, iterate);
  } else if (tasks &#x26;&#x26; typeof tasks === obj) {
    keys = nativeKeys(tasks);
    size = keys.length;
    newTasks = {};
    baseEachSync(tasks, iterate, keys);
  }
  return newTasks;

  function iterate(func, key) {
    newTasks[key] = reflect(func);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.reject" id="apidoc.element.neo-async.default.reject">
        function <span class="apidocSignatureSpan">neo-async.default.</span>reject
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reject = function (collection, iterator, callback) {
  callback = callback || noop;
  var size, keys, result;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    result = Array(size);
    arrayEach(collection, iterator, createCallback);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    result = Array(size);
    symbolEach(collection, iterator, createCallback);
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    result = Array(size);
    baseEach(collection, iterator, createCallback, keys);
  }
  if (!size) {
    return callback(null, []);
  }

  function createCallback(index, value) {
    return function done(err, res) {
      if (index === null) {
        throwError();
      }
      if (err) {
        index = null;
        callback = once(callback);
        callback(err);
        return;
      }
      if (!!res === bool) {
        result[index] = value;
      }
      index = null;
      if (++completed === size) {
        callback(null, compact(result));
      }
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">reject</span>(array, iterator, function(err, res) {
*   console.log(res); // [2];
*   console.log(order); // [1, 2, 3]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.rejectLimit" id="apidoc.element.neo-async.default.rejectLimit">
        function <span class="apidocSignatureSpan">neo-async.default.</span>rejectLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rejectLimit = function (collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, value, keys, iter, item, iterate, result;
  var sync = false;
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null, []);
  }
  result = Array(size);
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, createCallback(value, index));
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, index, createCallback(value, index));
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, createCallback(value, started++));
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, started, createCallback(value, started++));
    }
  }

  function objectIterator() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[keys[index]];
      iterator(value, createCallback(value, index));
    }
  }

  function objectIteratorWithKey() {
    index = started++;
    if (index &#x3c; size) {
      key = keys[index];
      value = collection[key];
      iterator(value, key, createCallback(value, index));
    }
  }

  function createCallback(value, index) {
    return function(err, res) {
      if (index === null) {
        throwError();
      }
      if (err) {
        index = null;
        iterate = noop;
        callback = once(callback);
        callback(err);
        return;
      }
      if (!!res === bool) {
        result[index] = value;
      }
      index = null;
      if (++completed === size) {
        callback = onlyOnce(callback);
        callback(null, compact(result));
      } else if (sync) {
        nextTick(iterate);
      } else {
        sync = true;
        iterate();
      }
      sync = false;
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 5, 3, 4, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">rejectLimit</span>(array, 2, iterator, function(err, res) {
*   console.log(res); // [4, 2]
*   console.log(order); // [1, 3, 5, 2, 4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.rejectSeries" id="apidoc.element.neo-async.default.rejectSeries">
        function <span class="apidocSignatureSpan">neo-async.default.</span>rejectSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rejectSeries = function (collection, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, value, keys, iter, iterate;
  var sync = false;
  var completed = 0;
  var result = [];

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null, []);
  }
  iterate();

  function arrayIterator() {
    value = collection[completed];
    iterator(value, done);
  }

  function arrayIteratorWithIndex() {
    value = collection[completed];
    iterator(value, completed, done);
  }

  function symbolIterator() {
    value = iter.next().value;
    iterator(value, done);
  }

  function symbolIteratorWithKey() {
    value = iter.next().value;
    iterator(value, completed, done);
  }

  function objectIterator() {
    key = keys[completed];
    value = collection[key];
    iterator(value, done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    value = collection[key];
    iterator(value, key, done);
  }

  function done(err, res) {
    if (err) {
      callback(err);
      return;
    }
    if (!!res === bool) {
      result[result.length] = value;
    }
    if (++completed === size) {
      iterate = throwError;
      callback(null, result);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">rejectSeries</span>(array, iterator, function(err, res) {
*   console.log(res); // [2];
*   console.log(order); // [1, 3, 2]
* });
*
* @example
*
* // object
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.retry" id="apidoc.element.neo-async.default.retry">
        function <span class="apidocSignatureSpan">neo-async.default.</span>retry
        <span class="apidocSignatureSpan">(opts, task, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function retry(opts, task, callback) {
  var times, intervalFunc, errorFilter;
  var count = 0;
  if (arguments.length &#x3c; 3 &#x26;&#x26; typeof opts === func) {
    callback = task || noop;
    task = opts;
    opts = null;
    times = DEFAULT_TIMES;
  } else {
    callback = callback || noop;
    switch (typeof opts) {
      case &#x27;object&#x27;:
        if (typeof opts.errorFilter === func) {
          errorFilter = opts.errorFilter;
        }
        var interval = opts.interval;
        switch (typeof interval) {
          case func:
            intervalFunc = interval;
            break;
          case &#x27;string&#x27;:
          case &#x27;number&#x27;:
            interval = +interval;
            intervalFunc = interval ? function() {
              return interval;
            } : function() {
              return DEFAULT_INTERVAL;
            };
            break;
        }
        times = +opts.times || DEFAULT_TIMES;
        break;
      case &#x27;number&#x27;:
        times = opts || DEFAULT_TIMES;
        break;
      case &#x27;string&#x27;:
        times = +opts || DEFAULT_TIMES;
        break;
      default:
        throw new Error(&#x27;Invalid arguments for async.retry&#x27;);
    }
  }
  if (typeof task !== &#x27;function&#x27;) {
    throw new Error(&#x27;Invalid arguments for async.retry&#x27;);
  }

  if (intervalFunc) {
    task(intervalCallback);
  } else {
    task(simpleCallback);
  }

  function simpleIterator() {
    task(simpleCallback);
  }

  function simpleCallback(err, res) {
    if (++count === times || !err || errorFilter &#x26;&#x26; !errorFilter(err)) {
      if (arguments.length &#x3c;= 2) {
        return callback(err, res);
      }
      var args = createArray(arguments);
      return callback.apply(null, args);
    }
    simpleIterator();
  }

  function intervalIterator() {
    task(intervalCallback);
  }

  function intervalCallback(err, res) {
    if (++count === times || !err || errorFilter &#x26;&#x26; !errorFilter(err)) {
      if (arguments.length &#x3c;= 2) {
        return callback(err, res);
      }
      var args = createArray(arguments);
      return callback.apply(null, args);
    }
    setTimeout(intervalIterator, intervalFunc(count));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.retryable" id="apidoc.element.neo-async.default.retryable">
        function <span class="apidocSignatureSpan">neo-async.default.</span>retryable
        <span class="apidocSignatureSpan">(opts, task)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function retryable(opts, task) {
  if (!task) {
    task = opts;
    opts = null;
  }
  return done;

  function done() {
    var taskFn;
    var args = createArray(arguments);
    var lastIndex = args.length - 1;
    var callback = args[lastIndex];
    switch (task.length) {
      case 1:
        taskFn = task1;
        break;
      case 2:
        taskFn = task2;
        break;
      case 3:
        taskFn = task3;
        break;
      default:
        taskFn = task4;
    }
    if (opts) {
      retry(opts, taskFn, callback);
    } else {
      retry(taskFn, callback);
    }

    function task1(done) {
      task(done);
    }

    function task2(done) {
      task(args[0], done);
    }

    function task3(done) {
      task(args[0], args[1], done);
    }

    function task4(callback) {
      args[lastIndex] = callback;
      task.apply(null, args);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.safe" id="apidoc.element.neo-async.default.safe">
        function <span class="apidocSignatureSpan">neo-async.default.</span>safe
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function safe() {
  createImmediate();
  return exports;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.select" id="apidoc.element.neo-async.default.select">
        function <span class="apidocSignatureSpan">neo-async.default.</span>select
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">select = function (collection, iterator, callback) {
  callback = callback || noop;
  var size, keys, result;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    result = Array(size);
    arrayEach(collection, iterator, createCallback);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    result = Array(size);
    symbolEach(collection, iterator, createCallback);
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    result = Array(size);
    baseEach(collection, iterator, createCallback, keys);
  }
  if (!size) {
    return callback(null, []);
  }

  function createCallback(index, value) {
    return function done(err, res) {
      if (index === null) {
        throwError();
      }
      if (err) {
        index = null;
        callback = once(callback);
        callback(err);
        return;
      }
      if (!!res === bool) {
        result[index] = value;
      }
      index = null;
      if (++completed === size) {
        callback(null, compact(result));
      }
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.selectLimit" id="apidoc.element.neo-async.default.selectLimit">
        function <span class="apidocSignatureSpan">neo-async.default.</span>selectLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selectLimit = function (collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, value, keys, iter, item, iterate, result;
  var sync = false;
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null, []);
  }
  result = Array(size);
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, createCallback(value, index));
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, index, createCallback(value, index));
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, createCallback(value, started++));
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, started, createCallback(value, started++));
    }
  }

  function objectIterator() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[keys[index]];
      iterator(value, createCallback(value, index));
    }
  }

  function objectIteratorWithKey() {
    index = started++;
    if (index &#x3c; size) {
      key = keys[index];
      value = collection[key];
      iterator(value, key, createCallback(value, index));
    }
  }

  function createCallback(value, index) {
    return function(err, res) {
      if (index === null) {
        throwError();
      }
      if (err) {
        index = null;
        iterate = noop;
        callback = once(callback);
        callback(err);
        return;
      }
      if (!!res === bool) {
        result[index] = value;
      }
      index = null;
      if (++completed === size) {
        callback = onlyOnce(callback);
        callback(null, compact(result));
      } else if (sync) {
        nextTick(iterate);
      } else {
        sync = true;
        iterate();
      }
      sync = false;
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.selectSeries" id="apidoc.element.neo-async.default.selectSeries">
        function <span class="apidocSignatureSpan">neo-async.default.</span>selectSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selectSeries = function (collection, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, value, keys, iter, iterate;
  var sync = false;
  var completed = 0;
  var result = [];

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null, []);
  }
  iterate();

  function arrayIterator() {
    value = collection[completed];
    iterator(value, done);
  }

  function arrayIteratorWithIndex() {
    value = collection[completed];
    iterator(value, completed, done);
  }

  function symbolIterator() {
    value = iter.next().value;
    iterator(value, done);
  }

  function symbolIteratorWithKey() {
    value = iter.next().value;
    iterator(value, completed, done);
  }

  function objectIterator() {
    key = keys[completed];
    value = collection[key];
    iterator(value, done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    value = collection[key];
    iterator(value, key, done);
  }

  function done(err, res) {
    if (err) {
      callback(err);
      return;
    }
    if (!!res === bool) {
      result[result.length] = value;
    }
    if (++completed === size) {
      iterate = throwError;
      callback(null, result);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.seq" id="apidoc.element.neo-async.default.seq">
        function <span class="apidocSignatureSpan">neo-async.default.</span>seq
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function seq() {
  var fns = createArray(arguments);

  return function() {

    var self = this;
    var args = createArray(arguments);
    var callback = args[args.length - 1];
    if (typeof callback === func) {
      args.pop();
    } else {
      callback = noop;
    }
    reduce(fns, args, iterator, done);

    function iterator(newargs, fn, callback) {
      var func = function(err) {
        var nextargs = slice(arguments, 1);
        callback(err, nextargs);
      };
      newargs.push(func);
      fn.apply(self, newargs);
    }

    function done(err, res) {
      res = isArray(res) ? res : [res];
      res.unshift(err);
      callback.apply(self, res);
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.series" id="apidoc.element.neo-async.default.series">
        function <span class="apidocSignatureSpan">neo-async.default.</span>series
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function series(tasks, callback) {
  callback = callback || noop;
  var size, key, keys, result, iterate;
  var sync = false;
  var completed = 0;

  if (isArray(tasks)) {
    size = tasks.length;
    result = Array(size);
    iterate = arrayIterator;
  } else if (tasks &#x26;&#x26; typeof tasks === obj) {
    keys = nativeKeys(tasks);
    size = keys.length;
    result = {};
    iterate = objectIterator;
  } else {
    return callback(null);
  }
  if (!size) {
    return callback(null, result);
  }
  iterate();

  function arrayIterator() {
    key = completed;
    tasks[completed](done);
  }

  function objectIterator() {
    key = keys[completed];
    tasks[key](done);
  }

  function done(err, res) {
    if (err) {
      iterate = throwError;
      callback = onlyOnce(callback);
      callback(err, result);
      return;
    }
    result[key] = arguments.length &#x3c;= 2 ? res : slice(arguments, 1);
    if (++completed === size) {
      iterate = throwError;
      callback(null, result);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*  function(done) {
*    setTimeout(function() {
*      order.push(4);
*      done(null, 4);
*    }, 20);
*  }
* ];
* async.<span class="apidocCodeKeywordSpan">series</span>(tasks, function(err, res) {
*   console.log(res); // [1, 2, 3, 4];
*   console.log(order); // [1, 2, 3, 4]
* });
*
* @example
*
* var order = [];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.setImmediate" id="apidoc.element.neo-async.default.setImmediate">
        function <span class="apidocSignatureSpan">neo-async.default.</span>setImmediate
        <span class="apidocSignatureSpan">(callback, arg1, arg2, arg3)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setImmediate = function (callback, arg1, arg2, arg3) {
  if (typeof callback !== &#x27;function&#x27;) {
    throw new TypeError(&#x27;&#x22;callback&#x22; argument must be a function&#x27;);
  }

  var i, args;

  switch (arguments.length) {
    // fast cases
    case 1:
      break;
    case 2:
      args = [arg1];
      break;
    case 3:
      args = [arg1, arg2];
      break;
    default:
      args = [arg1, arg2, arg3];
      for (i = 4; i &#x3c; arguments.length; i++)
        // extend array dynamically, makes .apply run much faster in v6.0.0
        args[i - 1] = arguments[i];
      break;
  }
  return createImmediate(args, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.some" id="apidoc.element.neo-async.default.some">
        function <span class="apidocSignatureSpan">neo-async.default.</span>some
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function some(collection, iterator, callback) {
  callback = callback || noop;
  detect(collection, iterator, done);

  function done(err, res) {
    if (err) {
      return callback(err);
    }
    callback(null, !!res);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">some</span>(array, iterator, function(err, res) {
*   console.log(res); // true
*   console.log(order); // [1]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.someLimit" id="apidoc.element.neo-async.default.someLimit">
        function <span class="apidocSignatureSpan">neo-async.default.</span>someLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function someLimit(collection, limit, iterator, callback) {
  callback = callback || noop;
  detectLimit(collection, limit, iterator, done);

  function done(err, res) {
    if (err) {
      return callback(err);
    }
    callback(null, !!res);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 5, 3, 4, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">someLimit</span>(array, 2, iterator, function(err, res) {
*   console.log(res); // true
*   console.log(order); // [1]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.someSeries" id="apidoc.element.neo-async.default.someSeries">
        function <span class="apidocSignatureSpan">neo-async.default.</span>someSeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function someSeries(collection, iterator, callback) {
  callback = callback || noop;
  detectSeries(collection, iterator, done);

  function done(err, res) {
    if (err) {
      return callback(err);
    }
    callback(null, !!res);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num % 2);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">someSeries</span>(array, iterator, function(err, res) {
*   console.log(res); // true
*   console.log(order); // [1]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.sortBy" id="apidoc.element.neo-async.default.sortBy">
        function <span class="apidocSignatureSpan">neo-async.default.</span>sortBy
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sortBy(collection, iterator, callback) {
  callback = callback || noop;
  var size, result;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    result = Array(size);
    arrayEach(collection, iterator, createCallback);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    result = Array(size);
    symbolEach(collection, iterator, createCallback);
  } else if (typeof collection === obj) {
    var keys = nativeKeys(collection);
    size = keys.length;
    result = Array(size);
    baseEach(collection, iterator, createCallback, keys);
  }
  if (!size) {
    callback(null, []);
  }

  function createCallback(value) {
    var called = false;
    return function done(err, criteria) {
      if (called) {
        throwError();
      }
      called = true;
      result[completed] = {
        value: value,
        criteria: criteria
      };
      if (err) {
        callback = once(callback);
        callback(err);
      } else if (++completed === size) {
        result.sort(sortIterator);
        callback(null, pluck(result, &#x27;value&#x27;));
      }
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">sortBy</span>(array, iterator, function(err, res) {
*   console.log(res); // [1, 2, 3];
*   console.log(order); // [1, 2, 3]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.sortByLimit" id="apidoc.element.neo-async.default.sortByLimit">
        function <span class="apidocSignatureSpan">neo-async.default.</span>sortByLimit
        <span class="apidocSignatureSpan">(collection, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sortByLimit(collection, limit, iterator, callback) {
  callback = callback || noop;
  var size, index, key, value, keys, iter, item, result, iterate;
  var sync = false;
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null, []);
  }
  result = Array(size);
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    if (started &#x3c; size) {
      value = collection[started++];
      iterator(value, createCallback(value));
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      value = collection[index];
      iterator(value, index, createCallback(value));
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, createCallback(value));
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      value = item.value;
      iterator(value, started++, createCallback(value));
    }
  }

  function objectIterator() {
    if (started &#x3c; size) {
      value = collection[keys[started++]];
      iterator(value, createCallback(value));
    }
  }

  function objectIteratorWithKey() {
    if (started &#x3c; size) {
      key = keys[started++];
      value = collection[key];
      iterator(value, key, createCallback(value));
    }
  }

  function createCallback(value) {
    var called = false;
    return function(err, criteria) {
      if (called) {
        throwError();
      }
      called = true;
      result[completed] = {
        value: value,
        criteria: criteria
      };
      if (err) {
        iterate = noop;
        callback(err);
        callback = noop;
      } else if (++completed === size) {
        result.sort(sortIterator);
        callback(null, pluck(result, &#x27;value&#x27;));
      } else if (sync) {
        nextTick(iterate);
      } else {
        sync = true;
        iterate();
      }
      sync = false;
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 5, 3, 4, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">sortByLimit</span>(array, 2, iterator, function(err, res) {
*   console.log(res); // [1, 2, 3, 4, 5]
*   console.log(order); // [1, 3, 5, 2, 4]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.sortBySeries" id="apidoc.element.neo-async.default.sortBySeries">
        function <span class="apidocSignatureSpan">neo-async.default.</span>sortBySeries
        <span class="apidocSignatureSpan">(collection, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sortBySeries(collection, iterator, callback) {
  callback = onlyOnce(callback || noop);
  var size, key, value, keys, iter, result, iterate;
  var sync = false;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    iterate = iterator.length === 3 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    iterate = iterator.length === 3 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    iterate = iterator.length === 3 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null, []);
  }
  result = Array(size);
  iterate();

  function arrayIterator() {
    value = collection[completed];
    iterator(value, done);
  }

  function arrayIteratorWithIndex() {
    value = collection[completed];
    iterator(value, completed, done);
  }

  function symbolIterator() {
    value = iter.next().value;
    iterator(value, done);
  }

  function symbolIteratorWithKey() {
    value = iter.next().value;
    iterator(value, completed, done);
  }

  function objectIterator() {
    value = collection[keys[completed]];
    iterator(value, done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    value = collection[key];
    iterator(value, key, done);
  }

  function done(err, criteria) {
    result[completed] = {
      value: value,
      criteria: criteria
    };
    if (err) {
      callback(err);
    } else if (++completed === size) {
      iterate = throwError;
      result.sort(sortIterator);
      callback(null, pluck(result, &#x27;value&#x27;));
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var array = [1, 3, 2];
* var iterator = function(num, done) {
*   setTimeout(function() {
*     order.push(num);
*     done(null, num);
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">sortBySeries</span>(array, iterator, function(err, res) {
*   console.log(res); // [1, 2, 3];
*   console.log(order); // [1, 3, 2]
* });
*
* @example
*
* // array with index
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.timeout" id="apidoc.element.neo-async.default.timeout">
        function <span class="apidocSignatureSpan">neo-async.default.</span>timeout
        <span class="apidocSignatureSpan">(func, millisec, info)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function timeout(func, millisec, info) {
  var callback, timer;
  return wrappedFunc;

  function wrappedFunc() {
    timer = setTimeout(timeoutCallback, millisec);
    var args = createArray(arguments);
    var lastIndex = args.length - 1;
    callback = args[lastIndex];
    args[lastIndex] = injectedCallback;
    simpleApply(func, args);
  }

  function timeoutCallback() {
    var name = func.name || &#x27;anonymous&#x27;;
    var err = new Error(&#x27;Callback function &#x22;&#x27; + name + &#x27;&#x22; timed out.&#x27;);
    err.code = &#x27;ETIMEDOUT&#x27;;
    if (info) {
      err.info = info;
    }
    timer = null;
    callback(err);
  }

  function injectedCallback() {
    if (timer !== null) {
      simpleApply(callback, createArray(arguments));
      clearTimeout(timer);
    }
  }

  function simpleApply(func, args) {
    switch(args.length) {
      case 0:
        func();
        break;
      case 1:
        func(args[0]);
        break;
      case 2:
        func(args[0], args[1]);
        break;
      default:
        func.apply(null, args);
        break;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.times" id="apidoc.element.neo-async.default.times">
        function <span class="apidocSignatureSpan">neo-async.default.</span>times
        <span class="apidocSignatureSpan">(n, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function times(n, iterator, callback) {
  callback = callback || noop;
  n = +n;
  if (isNaN(n) || n &#x3c; 1) {
    return callback(null, []);
  }
  var result = Array(n);
  timesSync(n, iterate);

  function iterate(num) {
    iterator(num, createCallback(num));
  }

  function createCallback(index) {
    return function(err, res) {
      if (index === null) {
        throwError();
      }
      result[index] = res;
      index = null;
      if (err) {
        callback(err);
        callback = noop;
      } else if (--n === 0) {
        callback(null, result);
      }
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Function} iterator
 * @param {Function} callback
 * @example
 *
 * var iterator = function(n, done) {
 *   done(null, n);
 * };
 * async.<span class="apidocCodeKeywordSpan">times</span>(4, iterator, function(err, res) {
 *   console.log(res); // [0, 1, 2, 3];
 * });
 *
 */
function times(n, iterator, callback) {
  callback = callback || noop;
  n = +n;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.timesLimit" id="apidoc.element.neo-async.default.timesLimit">
        function <span class="apidocSignatureSpan">neo-async.default.</span>timesLimit
        <span class="apidocSignatureSpan">(n, limit, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function timesLimit(n, limit, iterator, callback) {
  callback = callback || noop;
  n = +n;
  if (isNaN(n) || n &#x3c; 1 || isNaN(limit) || limit &#x3c; 1) {
    return callback(null, []);
  }
  var result = Array(n);
  var sync = false;
  var started = 0;
  var completed = 0;
  timesSync(limit &#x3e; n ? n : limit, iterate);

  function iterate() {
    var index = started++;
    if (index &#x3c; n) {
      iterator(index, createCallback(index));
    }
  }

  function createCallback(index) {
    return function(err, res) {
      if (index === null) {
        throwError();
      }
      result[index] = res;
      index = null;
      if (err) {
        callback(err);
        callback = noop;
      } else if (++completed &#x3e;= n) {
        callback(null, result);
        callback = throwError;
      } else if (sync) {
        nextTick(iterate);
      } else {
        sync = true;
        iterate();
      }
      sync = false;
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Function} iterator
 * @param {Function} callback
 * @example
 *
 * var iterator = function(n, done) {
 *   done(null, n);
 * };
 * async.<span class="apidocCodeKeywordSpan">timesLimit</span>(4, 2, iterator, function(err, res) {
 *   console.log(res); // [0, 1, 2, 3];
 * });
 *
 */
function timesLimit(n, limit, iterator, callback) {
  callback = callback || noop;
  n = +n;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.timesSeries" id="apidoc.element.neo-async.default.timesSeries">
        function <span class="apidocSignatureSpan">neo-async.default.</span>timesSeries
        <span class="apidocSignatureSpan">(n, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function timesSeries(n, iterator, callback) {
  callback = callback || noop;
  n = +n;
  if (isNaN(n) || n &#x3c; 1) {
    return callback(null, []);
  }
  var result = Array(n);
  var sync = false;
  var completed = 0;
  iterate();

  function iterate() {
    iterator(completed, done);
  }

  function done(err, res) {
    result[completed] = res;
    if (err) {
      callback(err);
      callback = throwError;
    } else if (++completed &#x3e;= n) {
      callback(null, result);
      callback = throwError;
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Function} iterator
 * @param {Function} callback
 * @example
 *
 * var iterator = function(n, done) {
 *   done(null, n);
 * };
 * async.<span class="apidocCodeKeywordSpan">timesSeries</span>(4, iterator, function(err, res) {
 *   console.log(res); // [0, 1, 2, 3];
 * });
 *
 */
function timesSeries(n, iterator, callback) {
  callback = callback || noop;
  n = +n;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.transform" id="apidoc.element.neo-async.default.transform">
        function <span class="apidocSignatureSpan">neo-async.default.</span>transform
        <span class="apidocSignatureSpan">(collection, accumulator, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function transform(collection, accumulator, iterator, callback) {
  if (arguments.length === 3) {
    callback = iterator;
    iterator = accumulator;
    accumulator = undefined;
  }
  callback = callback || noop;
  var size, keys, result;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    result = accumulator !== undefined ? accumulator : [];
    arrayEach(collection, result, iterator, done);
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    result = accumulator !== undefined ? accumulator : {};
    symbolEach(collection, result, iterator, done);
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    result = accumulator !== undefined ? accumulator : {};
    baseEach(collection, result, iterator, done, keys);
  }
  if (!size) {
    callback(null, accumulator !== undefined ? accumulator : result || {});
  }

  function done(err, bool) {
    if (err) {
      callback = once(callback);
      callback(err, isArray(result) ? createArray(result) : objectClone(result));
    } else if (++completed === size) {
      callback(null, result);
    } else if (bool === false) {
      callback = once(callback);
      callback(null, isArray(result) ? createArray(result) : objectClone(result));
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var iterator = function(result, num, done) {
*   setTimeout(function() {
*     order.push(num);
*     result.push(num)
*     done();
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">transform</span>(collection, iterator, function(err, res) {
*   console.log(res); // [1, 2, 3, 4]
*   console.log(order); // [1, 2, 3, 4]
* });
*
* @example
*
* // array with index and accumulator
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.transformLimit" id="apidoc.element.neo-async.default.transformLimit">
        function <span class="apidocSignatureSpan">neo-async.default.</span>transformLimit
        <span class="apidocSignatureSpan">(collection, limit, accumulator, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function transformLimit(collection, limit, accumulator, iterator, callback) {
  if (arguments.length === 4) {
    callback = iterator;
    iterator = accumulator;
    accumulator = undefined;
  }
  callback = callback || noop;
  var size, index, key, keys, iter, item, iterate, result;
  var sync = false;
  var started = 0;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    result = accumulator !== undefined ? accumulator : [];
    iterate = iterator.length === 4 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    result = accumulator !== undefined ? accumulator : {};
    iterate = iterator.length === 4 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    result = accumulator !== undefined ? accumulator : {};
    iterate = iterator.length === 4 ? objectIteratorWithKey : objectIterator;
  }
  if (!size || isNaN(limit) || limit &#x3c; 1) {
    return callback(null, accumulator !== undefined ? accumulator : result || {});
  }
  timesSync(limit &#x3e; size ? size : limit, iterate);

  function arrayIterator() {
    index = started++;
    if (index &#x3c; size) {
      iterator(result, collection[index], onlyOnce(done));
    }
  }

  function arrayIteratorWithIndex() {
    index = started++;
    if (index &#x3c; size) {
      iterator(result, collection[index], index, onlyOnce(done));
    }
  }

  function symbolIterator() {
    if ((item = iter.next()).done === false) {
      iterator(result, item.value, onlyOnce(done));
    }
  }

  function symbolIteratorWithKey() {
    if ((item = iter.next()).done === false) {
      iterator(result, item.value, started++, onlyOnce(done));
    }
  }

  function objectIterator() {
    index = started++;
    if (index &#x3c; size) {
      iterator(result, collection[keys[index]], onlyOnce(done));
    }
  }

  function objectIteratorWithKey() {
    index = started++;
    if (index &#x3c; size) {
      key = keys[index];
      iterator(result, collection[key], key, onlyOnce(done));
    }
  }

  function done(err, bool) {
    if (err) {
      iterate = noop;
      callback(err, isArray(result) ? createArray(result) : objectClone(result));
      callback = noop;
    } else if (++completed === size) {
      callback(null, result);
    } else if (bool === false) {
      iterate = noop;
      callback(null, isArray(result) ? createArray(result) : objectClone(result));
      callback = noop;
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var iterator = function(result, num, done) {
*   setTimeout(function() {
*     order.push(num);
*     result.push(num);
*     done();
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">transformLimit</span>(array, 2, iterator, function(err, res) {
*   console.log(res); // [1, 3, 5, 2, 4]
*   console.log(order); // [1, 3, 5, 2, 4]
* });
*
* @example
*
* // array with index and accumulator
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.transformSeries" id="apidoc.element.neo-async.default.transformSeries">
        function <span class="apidocSignatureSpan">neo-async.default.</span>transformSeries
        <span class="apidocSignatureSpan">(collection, accumulator, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function transformSeries(collection, accumulator, iterator, callback) {
  if (arguments.length === 3) {
    callback = iterator;
    iterator = accumulator;
    accumulator = undefined;
  }
  callback = onlyOnce(callback || noop);
  var size, key, keys, iter, iterate, result;
  var sync = false;
  var completed = 0;

  if (isArray(collection)) {
    size = collection.length;
    result = accumulator !== undefined ? accumulator : [];
    iterate = iterator.length === 4 ? arrayIteratorWithIndex : arrayIterator;
  } else if (!collection) {
  } else if (iteratorSymbol &#x26;&#x26; collection[iteratorSymbol]) {
    size = collection.size;
    iter = collection[iteratorSymbol]();
    result = accumulator !== undefined ? accumulator : {};
    iterate = iterator.length === 4 ? symbolIteratorWithKey : symbolIterator;
  } else if (typeof collection === obj) {
    keys = nativeKeys(collection);
    size = keys.length;
    result = accumulator !== undefined ? accumulator : {};
    iterate = iterator.length === 4 ? objectIteratorWithKey : objectIterator;
  }
  if (!size) {
    return callback(null, accumulator !== undefined ? accumulator : result || {});
  }
  iterate();

  function arrayIterator() {
    iterator(result, collection[completed], done);
  }

  function arrayIteratorWithIndex() {
    iterator(result, collection[completed], completed, done);
  }

  function symbolIterator() {
    iterator(result, iter.next().value, done);
  }

  function symbolIteratorWithKey() {
    iterator(result, iter.next().value, completed, done);
  }

  function objectIterator() {
    iterator(result, collection[keys[completed]], done);
  }

  function objectIteratorWithKey() {
    key = keys[completed];
    iterator(result, collection[key], key, done);
  }

  function done(err, bool) {
    if (err) {
      callback(err, result);
    } else if (++completed === size) {
      iterate = throwError;
      callback(null, result);
    } else if (bool === false) {
      iterate = throwError;
      callback(null, result);
    } else if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var iterator = function(result, num, done) {
*   setTimeout(function() {
*     order.push(num);
*     result.push(num)
*     done();
*   }, num * 10);
* };
* async.<span class="apidocCodeKeywordSpan">transformSeries</span>(collection, iterator, function(err, res) {
*   console.log(res); // [1, 3, 2, 4]
*   console.log(order); // [1, 3, 2, 4]
* });
*
* @example
*
* // array with index and accumulator
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.unmemoize" id="apidoc.element.neo-async.default.unmemoize">
        function <span class="apidocSignatureSpan">neo-async.default.</span>unmemoize
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unmemoize(fn) {
  return function() {
    return (fn.unmemoized || fn).apply(null, arguments);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.until" id="apidoc.element.neo-async.default.until">
        function <span class="apidocSignatureSpan">neo-async.default.</span>until
        <span class="apidocSignatureSpan">(test, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function until(test, iterator, callback) {
  callback = callback || noop;
  var sync = false;
  if (!test()) {
    iterate();
  } else {
    callback(null);
  }

  function iterate() {
    if (sync) {
      nextTick(next);
    } else {
      sync = true;
      iterator(done);
    }
    sync = false;
  }

  function next() {
    iterator(done);
  }

  function done(err, arg) {
    if (err) {
      return callback(err);
    }
    if (arguments.length &#x3c;= 2) {
      if (!test(arg)) {
        iterate();
      } else {
        callback(null, arg);
      }
      return;
    }
    arg = slice(arguments, 1);
    if (!test.apply(null, arg)) {
      iterate();
    } else {
      callback.apply(null, [null].concat(arg));
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.waterfall" id="apidoc.element.neo-async.default.waterfall">
        function <span class="apidocSignatureSpan">neo-async.default.</span>waterfall
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function waterfall(tasks, callback) {
  callback = callback || noop;
  if (!checkWaterfallTasks(tasks, callback)) {
    return;
  }
  var done, called, sync;
  var completed = 0;
  var size = tasks.length;
  var func = tasks[completed];
  var args = [];
  iterate();

  function iterate() {
    called = false;
    switch (args.length) {
      case 0:
      case 1:
        return func(next);
      case 2:
        return func(args[1], next);
      case 3:
        return func(args[1], args[2], next);
      case 4:
        return func(args[1], args[2], args[3], next);
      case 5:
        return func(args[1], args[2], args[3], args[4], next);
      case 6:
        return func(args[1], args[2], args[3], args[4], args[5], next);
      default:
        args = slice(args, 1);
        args.push(next);
        return func.apply(null, args);
    }
  }

  function next(err, res) {
    if (called) {
      throwError();
    }
    called = true;
    if (err) {
      done = callback;
      callback = throwError;
      done(err);
      return;
    }
    if (++completed === size) {
      done = callback;
      callback = throwError;
      if (arguments.length &#x3c;= 2) {
        done(err, res);
      } else {
        done.apply(null, createArray(arguments));
      }
      return;
    }
    args = arguments;
    func = tasks[completed] || throwError;
    if (sync) {
      nextTick(iterate);
    } else {
      sync = true;
      iterate();
    }
    sync = false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *   function(arg1, next) {
 *     setTimeout(function() {
 *       order.push(4);
 *       next(null, 1, 2, 3, 4);
 *     }, 40);
 *   }
 * ];
 * async.<span class="apidocCodeKeywordSpan">waterfall</span>(tasks, function(err, arg1, arg2, arg3, arg4) {
 *   console.log(arg1, arg2, arg3, arg4); // 1 2 3 4
 * });
 *
 */
function waterfall(tasks, callback) {
  callback = callback || noop;
  if (!checkWaterfallTasks(tasks, callback)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.whilst" id="apidoc.element.neo-async.default.whilst">
        function <span class="apidocSignatureSpan">neo-async.default.</span>whilst
        <span class="apidocSignatureSpan">(test, iterator, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function whilst(test, iterator, callback) {
  callback = callback || noop;
  var sync = false;
  if (test()) {
    iterate();
  } else {
    callback(null);
  }

  function iterate() {
    if (sync) {
      nextTick(next);
    } else {
      sync = true;
      iterator(done);
    }
    sync = false;
  }

  function next() {
    iterator(done);
  }

  function done(err, arg) {
    if (err) {
      return callback(err);
    }
    if (arguments.length &#x3c;= 2) {
      if (test(arg)) {
        iterate();
      } else {
        callback(null, arg);
      }
      return;
    }
    arg = slice(arguments, 1);
    if (test.apply(null, arg)) {
      iterate();
    } else {
      callback.apply(null, [null].concat(arg));
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.neo-async.default.wrapSync" id="apidoc.element.neo-async.default.wrapSync">
        function <span class="apidocSignatureSpan">neo-async.default.</span>wrapSync
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asyncify(fn) {
  return function( /* args..., callback */ ) {
    var args = createArray(arguments);
    var callback = args.pop();
    var result;
    try {
      result = fn.apply(this, args);
    } catch (e) {
      return callback(e);
    }
    if (result &#x26;&#x26; typeof result === obj &#x26;&#x26; typeof result.then === func) {
      result.then(function(value) {
        callback(null, value);
      }, function(err) {
        callback(err.message ? err : new Error(err));
      });
    } else {
      callback(null, result);
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
